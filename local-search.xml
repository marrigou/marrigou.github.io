<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【教程02】GPT 辅助</title>
    <link href="/2023/11/02/GPT%20%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/11/02/GPT%20%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.promptgenius.site/">提示精灵-主页</a><br><a href="https://cookbook.openai.com/">OpenAI Cookbook</a><br><a href="https://articles.zsxq.com/id_1gr9k9156w4h.html">知识星球 </a><br><strong>一、核心要素</strong><br>向 GPT 有效提问，有个专业词叫 Prompt，核心动作就三个：任务、指令、角色。<br>任务指的是你提问的主题；<br>指令指的是你对主题的限制条件；<br>角色指的是你让 GPT 以什么角色来回答你的问题；</p><p>为了让 GPT 更能清楚我的指令，小林给出具体的规则，以及加上&lt;&gt;，&lt;&gt;的重点是让 GPT 意识到这是重点。<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231108233606.png" alt="image.png|500"></p><p><a href="https://futureforce.feishu.cn/file/CMpdbLxAhon5K5x5C1OcciYwnOf">OpenAI:GPT 最佳实践中文大白话版本</a></p><ol><li>清晰告诉GPT想要什么<ol><li>输入越清晰越具体越好</li><li>要长输出还是短输出，指单词数、句子数、段落数等，一个汉字大概是2~2.5个tokens，100个tokens带个是75个单词，可以统一规定输出是多少tokens</li><li>要专家级输出还是简单输出</li><li>嫌输出格式不好，那就给个样例</li><li>角色扮演一直好用</li><li>使用分隔符把话和话分开，三引号、xml标记也可以，主要是为了区分出不同文本</li><li>展开解题步骤</li><li>多给几个例子</li></ol></li><li>给GPT发阅读材料<ol><li>要求按阅读材料作答，不开放作答</li><li>增加要求：要求GPT将阅读材料中的原文引用出来</li></ol></li><li>把复杂任务拆解成子任务</li><li>时不时对以上的对话内容进行总结，做个前情提要</li><li>如果GPT没有输出完全，可以告诉他“哎，还没做完呢”</li></ol><h1 id="提示词教程"><a href="#提示词教程" class="headerlink" title="提示词教程"></a>提示词教程</h1><p><a href="https://zhuanlan.zhihu.com/p/625565256">[Misc] 科研实用 ChatGPT Prompts&#x2F;Tricks - 知乎</a><br><a href="https://www.zhihu.com/question/592937997/answer/2962566176">chatgpt学术提问模板有哪些？chatgpt的prompt有哪些？ - 知乎</a><br><a href="https://www.zhihu.com/question/593971202/answer/2972199269">你在使用ChatGPT进行论文润色时的指令有哪些? - 知乎</a><br><a href="https://b.ai6868.top/?p=354">ChatGPT 100条 指令大全 更能解决你的问题！ChatGPT 万能指令(必看)！！！ - GPT 账号网</a><br><a href="https://www.promptingguide.ai/zh">提示工程指南 | Prompt Engineering Guide</a><br><a href="https://www.promptgenius.site/">提示精灵-主页</a></p><h1 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h1><h2 id="了解、检索新的研究领域"><a href="#了解、检索新的研究领域" class="headerlink" title="了解、检索新的研究领域"></a>了解、检索新的研究领域</h2><p>场景：</p><ul><li><ol><li>你想了解一个新的研究领域，或</li></ol></li><li><ol start="2"><li>你对一个特定技术感兴趣，但不知道该技术是否&#x2F;在哪些领域被讨论过。<br>示例Prompt:</li></ol></li><li><ol><li>I’m a researcher working in [研究领域], can you introduce me the field of [你感兴趣的子领域] from the perspective of XXX, XXX, and [其他解释角度] ?</li></ol></li><li><ol start="2"><li>I’m a researcher working in [研究领域]. I’m thinking of [感兴趣的技术方案的描述]. Has this strategy been discussed in the related research literature? If so, show me some examples of how existing works achieved this.</li></ol></li></ul><h2 id="获取参考文献"><a href="#获取参考文献" class="headerlink" title="获取参考文献"></a>获取参考文献</h2><p>ChatGPT经常会使用&#x2F;给出不存在的参考文献，使用以下prompt可以很大程度上避免这种情况发生：<br>Please attach all your references at the last in [你想要的格式] format. Make sure that they can be found on Google Scholar.</p><h2 id="润色语言"><a href="#润色语言" class="headerlink" title="润色语言"></a>润色语言</h2><p>场景：</p><ul><li><ol><li>论文写作润色，</li></ol></li><li><ol start="2"><li>Rebuttal&#x2F;邮件润色。</li></ol></li><li>1）I’m a researcher working in [研究领域]. I want you to act as an English translator, spelling corrector, and improver. Please polish my text to meet the academic standard in my research area, your goal is to improve the spelling, grammar, <a href="https://www.zhihu.com/search?q=clarity&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222972199269%22%7D">clarity</a>, concision, and overall readability. When necessary, rewrite the whole sentence. Furthermore, list all modifications and explain the reasons to do so in a markdown table. Now please polish the following text: [文本]</li></ul><ol start="2"><li>I’m doing a rebuttal for a paper submitted to a venue in the field of [研究领域]. My goal is to answer reviewers’ questions in polite, professional, and academic language. Following these standards, please help me correct the grammar mistakes and make the language more natural and fluent, and keep the meaning of the sentences if possible. Following is the text to be rephrased: [文本]</li><li>请帮我润色我的论文。我需要进行语法和拼写检查，优化句子结构和表达，调整逻辑和结构，确保学术用语和术语准确，检查引用和参考文献格式，调整风格和语气，补充和删除必要的内容，检查图表和图示，确认格式和排版是否正确。[在这里粘贴您的论文] 请在润色过程中提供详细的反馈和建议，以指导您的修改。谢谢！</li><li>请你现在扮演一个[这里放你所研究的领域] 领域的专家，从专业的角度，您认为上面这些内容是否有需要修改的地方？注意，不要全文修改，您需要一一指出需要修改的地方，并且给出修改意见以及推荐的修改内容。</li><li>Prompt: I want you to act as an academic journal editor. Please rephrase the paragraph from an academic angle based on the writing style of the Nature journal.</li></ol><h2 id="简单修改"><a href="#简单修改" class="headerlink" title="简单修改"></a>简单修改</h2><ol><li>Prompt: Please rewrite and revise this paragraph in Chinese</li></ol><h2 id="起标题"><a href="#起标题" class="headerlink" title="起标题"></a>起标题</h2><ol><li>Prompt: I am writing a scientific paper. Can you help me think a good acronym of the following topic: A New low power Implantable Wireless Brain Machine Interface.</li><li>Prompt: “ALOWIBMI” is not good. can you find other one with positive meaning?</li></ol><h2 id="催稿"><a href="#催稿" class="headerlink" title="催稿"></a>催稿</h2><ol><li>Prompt: I am a graduate student. I want to write an email to the reviewer of Nature journal to ask him to accelerate the review process of my submitted paper.</li></ol><h2 id="简写-降低重复率"><a href="#简写-降低重复率" class="headerlink" title="简写&#x2F;降低重复率"></a>简写&#x2F;降低重复率</h2><p>Prompt: </p><ul><li>1）Please keep your answer concise and less ChatGPT-like.</li><li>2）请你充当一位[某个]领域的专家，对文本去重。如果文本中连续13个字一样，就算重复。你需要通过调整主谓宾语序替换同义词、增减字数等方法，来达到论文去重的目的。请你修改下面这段文字：[文本内容]</li></ul><h2 id="内容扩写"><a href="#内容扩写" class="headerlink" title="内容扩写"></a>内容扩写</h2><p>Prompt： 请你参考[某某领域]同类论文，帮我在[研究背景和意义]这一级目录下面，再增加三个子目录，并写出三个子目录的主要内容。</p><h2 id="优化语法句法"><a href="#优化语法句法" class="headerlink" title="优化语法句法"></a>优化语法句法</h2><p>Prompt：[文本内容]这段文本在语法上是不正确的，请你修改这段文本。<br>Prompt：[文本内容]这段文本的主语和动词在这句话中不一致，请你改正这段文本。<br>Prompt：[文本内容]这段文本似乎不合适，请你重新措辞以表达更清晰。<br>Prompt：[文本内容]我在这段文本中使用了被动语态，请你考虑改用主动语态。</p><h2 id="内容改写"><a href="#内容改写" class="headerlink" title="内容改写"></a>内容改写</h2><p>Prompt：[文本内容]请你对文本进行微调。<br>Prompt：[文本内容]请你提高文本流畅度和连贯性。<br>Prompt：[文本内容]请你重新构建内容。</p><h2 id="理解code"><a href="#理解code" class="headerlink" title="理解code"></a>理解code</h2><ol><li>Prompt: What does the following code do? [insert code here]</li><li>你现在是一个 [程式语言] 专家，请告诉我以下的程式码在做什么。[附上程式码]</li></ol><h2 id="重构code"><a href="#重构code" class="headerlink" title="重构code"></a>重构code</h2><ol><li>你现在是一个 Clean Code 专家，我有以下的程式码，请用更干净简洁的方式改写，让我的同事们可以更容易维护程式码。另外，也解释为什么你要这样重构，让我能把重构的方式的说明加到 Pull Request 当中。[附上程式码]</li></ol><h2 id="改bug"><a href="#改bug" class="headerlink" title="改bug"></a>改bug</h2><ol><li>你现在是一个 [程式语言] 专家，我有一段程式码，我预期这段程式码可以 [做到某个功能]，只是它通过不了 [测试案例] 这个测试案例。请帮我找出我哪里写错了，以及用正确的方式改写。[附上程式码]</li></ol><h2 id="写测试"><a href="#写测试" class="headerlink" title="写测试"></a>写测试</h2><ol><li>你现在是一个 [程式语言] 专家，我有一段程式码 [附上程式码]，请帮我写一个测试，请至少提供五个测试案例，同时要包含到极端的状况，让我能够确定这段程式码的输出是正确的。</li></ol><h2 id="给代码添加注释"><a href="#给代码添加注释" class="headerlink" title="给代码添加注释"></a>给代码添加注释</h2><ol><li>Prompt: Add comments to the following code [insert code here]</li></ol><h2 id="设计神经网络"><a href="#设计神经网络" class="headerlink" title="设计神经网络"></a>设计神经网络</h2><p>下面是我的需求（比较零散、没有考虑逻辑顺序的、头脑风暴后的结果，）： 1、学习、实践并且自己构建深度学习的神经网络，主要使用Pytorch框架，构建中可能需要掌握的知识比如：卷积核计算公式、其他等等 2、根据实际问题，需要调整神经网络哪里会有比较好的效果，我们着重在自己构建网络、修改别人的网络、利用别人的网络&#x2F;经典的网络解决具体算法应用问题 3、我会上传一段之前与ChatGPT大模型的对话内容，其中包含了我某些方面的需求，你可以初步知道我总需求中的小需求之一 4、定制辅导：你是一位长时间伴随我达成上述目标的导师，所以你要自己学习，回顾我们所有的对话，根据我的所有提问，推测我在神经网络学习与实践方面的水平，然后你以后的回答做出相应的调整或者优化网络 5、我在某些时候可能会要求你提出完整训练代码，包括训练测试评估等等，还有我会向你提供训练评估结果，你告诉我怎么调参 6、哪些工具&#x2F;网站代码&#x2F;python第三方库&#x2F;帮助构建、查看模型结构、网络可视化、训练评估可视化或者其他帮助的工具网站 7、根据我上面的需求，你可以建议我还可以提哪些需求</p><p>我总结一下应该着重关注的主要需求： 第一重要：实践构建应用神经网络； 第二重要：根据实践中的问题修改优化网络、优化训练技巧、调参；</p><p>Here are my needs (relatively scattered, without considering the logical order, the result of brainstorming):</p><ol><li>Learn, practice and build deep learning neural network by yourself, mainly using the Pytorch framework, the knowledge that may need to be mastered in the construction, such as convolution kernel calculation formula, etc.</li><li>According to the actual problems, where the neural network needs to be adjusted to have better effects, we focus on building our own network, modifying others’ network, and using others’ network&#x2F;classic network to solve specific algorithm application problems.</li><li>I will upload a previous dialogue with the ChatGPT large model, which contains some aspects of my needs, so you can preliminarily know one of the small needs in my total needs.</li><li>Customized tutoring: you are a long-time mentor who accompanied me to achieve the above goals, so you have to learn by yourself, review all our conversations, and estimate my level of neural network learning and practice according to all my questions, and then make corresponding adjustments or optimize the network in your future answers.</li><li>At some point, I may ask you to provide complete training code, including training test evaluation, etc., and I will provide you with the training evaluation results, and you tell me how to adjust the parameters. 6. Which tools&#x2F;website code&#x2F;python third-party libraries&#x2F;tools&#x2F;websites help build, view model structure, network visualization, training evaluation visualization or other help?</li><li>According to my requirements above, can you suggest what requirements I can also mention?</li></ol><p>I summarize the main requirements that should be focused on: First important: practice building applied neural networks; Second important: modify and optimize the network according to the problems in practice, optimize training techniques, adjust parameters;</p><h1 id="英文表述"><a href="#英文表述" class="headerlink" title="英文表述"></a>英文表述</h1><ul><li>“Subtle edits only”: 仅对文本进行微调</li><li>“Minor edits”: 进行一些小的编辑</li><li>“Rephrase for clarity”: 改写以提高表达清晰度</li><li>“Simplify sentence structure”: 简化句子结构</li><li>“Check grammar and spelling”: 检查语法和拼写</li><li>“Enhance flow and coherence”: 提高文本流畅度和连贯性</li><li>“Improve word choice”: 改善用词</li><li>“Revise for style”: 为文本调整风格</li><li>“Significant edits”: 进行重大编辑</li><li>“Restructure content”: 重新构建内容</li></ul><h1 id="账号购买"><a href="#账号购买" class="headerlink" title="账号购买"></a>账号购买</h1><p><a href="https://buy.doudianpu.com/">ChatGPT 成品号特价 - 稳定、可靠</a><br><a href="https://nf.video/">银河录像局 次世代合租平台</a><br><a href="https://naifeistation.com/?invite=216">星际放映厅-专业级流媒体合租平台</a><br><a href="https://api.ycestore.com/buy/4">ChatGPT Plus 代升级 | GPT-4.0 解锁开通 | 正规 Visa&#x2F;MasterCard 信用卡 | 可续费 | 永久质保 | 老王的2号杂货铺</a><br><a href="https://bento.me/xydzip">微信foryglin 支持淘宝</a><br><a href="https://m.ai6868.top/buy/5">ChatGPT -4 Plus账号【更懂你的AI】拼车 30天 | CHATGPT 账号网 最新ChatGPT注册方法教程【ChatGPT账号购买】</a><br><a href="https://link3.cc/aichatgpt">AI意识觉醒 | Link3</a><br><a href="http://www.hxdgpt.com/">首页 | chatgpt账号推送</a></p><h1 id="GPT网站"><a href="#GPT网站" class="headerlink" title="GPT网站"></a>GPT网站</h1><p><a href="https://chatglm.cn/main/detail">智谱清言</a> 中文、对话、文档、代码<br><a href="https://docsgpt.arc53.com/">Site Unreachable</a><br><a href="https://app.writesonic.com/library/a2ad892a-bcc4-44c1-9d11-56682fc14a2d/all">app.writesonic.com&#x2F;login</a><br><a href="https://www.chatyy.com/search">ChatYY</a><br><a href="https://hi.zhangsan.cloud/chat">Ai Loading</a><br><a href="https://toolai.io/zh/">ToolAI 全球最完整最全面的AI人工智能工具集合</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【教程03】Windows 设置不显示时间</title>
    <link href="/2023/11/02/windows%20%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/"/>
    <url>/2023/11/02/windows%20%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<ol><li>控制面板<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006193816.png" alt="image.png"></li><li>其他设置<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006193842.png" alt="image.png|500"></li><li>修改短时间为s<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006193942.png" alt="image.png|458"></li><li>如果想重新显示时间，点击重置<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006194028.png" alt="image.png|175"></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【教程01】cheat engine使用指南</title>
    <link href="/2023/08/26/cheat%20engine%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/08/26/cheat%20engine%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>备注：文章采用的例子是肥鹅健身房，并不是一个好例子，因为虽然明面上修改了，实际上并没有，毕竟是流水很大的游戏了，这些数据肯定是进服务器校验的，没给封号就已经算仁慈了。但是，有一些游戏是可以永久性修改的，也实验成功了，暂时还没去深究底层原理是什么。</p><ol><li><p>电脑端打开小游戏程序<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006114504.png" alt="image.png|500"></p></li><li><p>ctrl+alt+delete打开任务管理器，找到微信<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115934.png" alt="image.png|500"><br>展开<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115959.png" alt="image.png|225"><br>随便选一个右键，选择转到详细信息<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006120021.png" alt="image.png|355"><br>找到占用内存最多的程序对应的PID值，23640<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006120117.png" alt="image.png|500"><br>23640的十六进制值为5C58<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006120231.png" alt="image.png|475"></p></li><li><p>打开 cheat engine<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006114638.png" alt="image.png|500"></p></li><li><p>打开进程列表，选择“当前进程”，找到5C58对应的进程，打开<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006120346.png" alt="image.png|500"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006114848.png" alt="image.png|500"></p></li><li><p>找到要修改的数据，比如能量是316，在cheat engine中的数值框中输入316*2后的结果<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115248.png" alt="image.png|950"></p></li><li><p>首次扫描<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115343.png" alt="image.png|473"><br>右边会显示扫描结果<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115412.png" alt="image.png|500"></p></li><li><p>在小游戏中让能量值发生变化<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115537.png" alt="image.png|446"><br>比如，由之前的316变成了315<br>接下来在cheat engine中修改数值为315*2后的结果630，点击再次扫描<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115655.png" alt="image.png|500"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java学习日志</title>
    <link href="/2023/06/28/%E9%9F%A9%E9%A1%BA%E5%B9%B3JAVA/"/>
    <url>/2023/06/28/%E9%9F%A9%E9%A1%BA%E5%B9%B3JAVA/</url>
    
    <content type="html"><![CDATA[<h1 id="2-java概述"><a href="#2-java概述" class="headerlink" title="2.java概述"></a>2.java概述</h1><h2 id="2-3-java技术体系平台"><a href="#2-3-java技术体系平台" class="headerlink" title="2.3 java技术体系平台"></a>2.3 java技术体系平台</h2><ol><li>java SE 标准版</li><li>java EE 企业版</li><li>java ME 小型版</li></ol><h2 id="2-4-java-重要特点"><a href="#2-4-java-重要特点" class="headerlink" title="2.4 java 重要特点"></a>2.4 java 重要特点</h2><ol><li>面向对象 oop</li><li>强壮的。强类型机制、异常处理、垃圾自动收集<ol><li>强类型：变量必须声明类型后才能使用</li></ol></li><li>跨平台。</li><li>解释型语言。</li></ol><h2 id="2-6-java运行机制和运行过程"><a href="#2-6-java运行机制和运行过程" class="headerlink" title="2.6 java运行机制和运行过程"></a>2.6 java运行机制和运行过程</h2><h3 id="2-6-2-java核心机制-java虚拟机-JVM"><a href="#2-6-2-java核心机制-java虚拟机-JVM" class="headerlink" title="2.6.2 java核心机制-java虚拟机 JVM"></a>2.6.2 java核心机制-java虚拟机 JVM</h3><ol><li>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK 中.</li><li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li><li>java -&gt; 编译javac -&gt; .class -&gt; 运行java</li></ol><h2 id="2-7-什么是JDK、JRE"><a href="#2-7-什么是JDK、JRE" class="headerlink" title="2.7 什么是JDK、JRE"></a>2.7 什么是JDK、JRE</h2><h3 id="2-7-1-JDK"><a href="#2-7-1-JDK" class="headerlink" title="2.7.1 JDK"></a>2.7.1 JDK</h3><ol><li>Java Development Kit。JAVA开发工具包</li><li>JDK &#x3D; JRE + java 的开发工具 [java, javac,javadoc,javap 等]</li><li>JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。</li></ol><h3 id="2-7-2-JRE"><a href="#2-7-2-JRE" class="headerlink" title="2.7.2 JRE"></a>2.7.2 JRE</h3><ol><li>Java Runtime Environment。Java 运行环境</li><li>JRE &#x3D; JVM + Java 的核心类库[类]</li></ol><h3 id="2-7-3-JDK、JRE和JVM包含关系"><a href="#2-7-3-JDK、JRE和JVM包含关系" class="headerlink" title="2.7.3 JDK、JRE和JVM包含关系"></a>2.7.3 JDK、JRE和JVM包含关系</h3><ol><li>JDK &#x3D; JRE + 开发工具集</li><li>JRE &#x3D; JVM + Java SE 标准类库</li></ol><h2 id="2-13-Java开发注意事项和细节"><a href="#2-13-Java开发注意事项和细节" class="headerlink" title="2.13 Java开发注意事项和细节"></a>2.13 Java开发注意事项和细节</h2><ol><li>严格区分大小写</li><li>一个源文件最多只能有一个public类</li><li>public类，则文件名必须按该类名命名</li></ol><h2 id="2-15-转义字符"><a href="#2-15-转义字符" class="headerlink" title="2.15 转义字符"></a>2.15 转义字符</h2><h3 id="2-15-1-常用的转义字符"><a href="#2-15-1-常用的转义字符" class="headerlink" title="2.15.1 常用的转义字符"></a>2.15.1 常用的转义字符</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\t</span>  一个制表位，实现对齐的功能<br><span class="hljs-string">\n</span> ：换行符<br><span class="hljs-string">\\</span> ：一个<span class="hljs-string">\</span><br><span class="hljs-string">\r</span> :一个回车<br></code></pre></td></tr></table></figure><h2 id="2-19-DOS命令"><a href="#2-19-DOS命令" class="headerlink" title="2.19 DOS命令"></a>2.19 DOS命令</h2><h3 id="2-19-3-常用的DOS命令"><a href="#2-19-3-常用的DOS命令" class="headerlink" title="2.19.3 常用的DOS命令"></a>2.19.3 常用的DOS命令</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dos">查看当前目录是有什么内容 <span class="hljs-built_in">dir</span><br>切换到其他盘下：盘符号 <span class="hljs-built_in">cd</span> : change directory<br>切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\表示上一级目录<br>切换到根目录：<span class="hljs-built_in">cd</span> \<br>查看指定的目录下所有的子级目录 <span class="hljs-built_in">tree</span><br>清屏 <span class="hljs-built_in">cls</span><br></code></pre></td></tr></table></figure><h1 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h1><h2 id="3-6-数据类型"><a href="#3-6-数据类型" class="headerlink" title="3.6 数据类型"></a>3.6 数据类型</h2><ol><li>java数据类型分为两大类：基本数据类型、引用类型<ol><li>基本数据类型<ol><li>整数类型：byte 1, short 2, int 4, long 8</li><li>浮点类型：float 4, doublue 8</li><li>字符型：char</li><li>布尔型：boolean</li></ol></li><li>引用类型<ol><li>类：class</li><li>接口：interface</li><li>数组：[]</li></ol></li></ol></li></ol><h2 id="3-8-浮点类型"><a href="#3-8-浮点类型" class="headerlink" title="3.8 浮点类型"></a>3.8 浮点类型</h2><h2 id="3-8-4"><a href="#3-8-4" class="headerlink" title="3.8.4"></a>3.8.4</h2><ol><li>浮点数&#x3D;符号位+指数位+尾数位</li></ol><h3 id="3-8-5-浮点数使用细节"><a href="#3-8-5-浮点数使用细节" class="headerlink" title="3.8.5 浮点数使用细节"></a>3.8.5 浮点数使用细节</h3><ol><li>浮点数常量有两种表现形式：<ol><li>十进制：5.12    5.12f   .512</li><li>科学计数法：5.12e2   5E2</li></ol></li><li>通常情况下，使用double</li></ol><h2 id="3-9-Java-Api-文档"><a href="#3-9-Java-Api-文档" class="headerlink" title="3.9 Java Api 文档"></a>3.9 Java Api 文档</h2><p><a href="https://itmyhome.com/java-api/">Java API中文在线文档 - itmyhome</a></p><h2 id="3-10-字符类型"><a href="#3-10-字符类型" class="headerlink" title="3.10 字符类型"></a>3.10 字符类型</h2><h3 id="3-10-3"><a href="#3-10-3" class="headerlink" title="3.10.3"></a>3.10.3</h3><ol><li>使用单引号括起来</li><li>允许赋值转义字符：char a &#x3D; ‘\n’</li><li>java中，char本质是一个整数，可以进行运算</li><li>可以赋值一个整数，输出对应的Unicode编码</li><li>a是97</li></ol><h2 id="3-15-基本数据类型转换"><a href="#3-15-基本数据类型转换" class="headerlink" title="3.15 基本数据类型转换"></a>3.15 基本数据类型转换</h2><h3 id="3-15-1-自动类型转换"><a href="#3-15-1-自动类型转换" class="headerlink" title="3.15.1 自动类型转换"></a>3.15.1 自动类型转换</h3><ol><li>char -&gt; int -&gt; long -&gt; float -&gt; double</li><li>byte -&gt;  short -&gt; int -&gt; long -&gt; float -&gt; double</li></ol><h3 id="3-15-4-强制类型转换细节"><a href="#3-15-4-强制类型转换细节" class="headerlink" title="3.15.4 强制类型转换细节"></a>3.15.4 强制类型转换细节</h3><ol><li>强制转换符号()只针对最近的操作数</li></ol><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h1><h3 id="4-8-标识符命名规范"><a href="#4-8-标识符命名规范" class="headerlink" title="4.8 标识符命名规范"></a>4.8 标识符命名规范</h3><ol><li>包名：都是小写 aa.bb.cc</li><li>类名、接口名：大驼峰 XxxYyyZzz</li><li>变量名、方法名：小驼峰 xxxYyyZzz</li><li>常量名：所有字母都大写 X_Y_Z</li></ol><h2 id="4-12-进制"><a href="#4-12-进制" class="headerlink" title="4.12 进制"></a>4.12 进制</h2><h3 id="4-12-1-进制介绍"><a href="#4-12-1-进制介绍" class="headerlink" title="4.12.1 进制介绍"></a>4.12.1 进制介绍</h3><ol><li>二进制：0b或0B开头</li><li>八进制：0开头</li><li>十六进制：0x或0X开头，A-F不区分大小写</li></ol><h2 id="4-27-原码、反码、补码"><a href="#4-27-原码、反码、补码" class="headerlink" title="4.27 原码、反码、补码"></a>4.27 原码、反码、补码</h2><ol><li>二进制最高位是符号位：0位正数、1为负数</li><li>正数的原码、反码、补码一样</li><li>负数的反码 &#x3D; 原码符号位不变，其他位取反</li><li>负数的补码 &#x3D; 反码 + 1</li><li>java中的数都是有符号的</li><li>计算机运行时，都是以补码的方式运算</li></ol><h2 id="4-28-位运算符"><a href="#4-28-位运算符" class="headerlink" title="4.28 位运算符"></a>4.28 位运算符</h2><ol><li>&amp;</li><li>|</li><li>^</li><li>~</li><li><blockquote><blockquote><p>：符号位不变，用符号位补溢出的高位</p></blockquote></blockquote></li><li>&lt;&lt;：符号位不变，低位补0</li><li><blockquote><blockquote><blockquote><p>：逻辑右移，无符号右移，低位溢出，高位补0</p></blockquote></blockquote></blockquote></li></ol><h1 id="5-程序控制结构"><a href="#5-程序控制结构" class="headerlink" title="5.程序控制结构"></a>5.程序控制结构</h1><h2 id="5-9-do-while循环"><a href="#5-9-do-while循环" class="headerlink" title="5.9 do..while循环"></a>5.9 do..while循环</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">do</span>&#123;<br>循环体;<br>&#125;<span class="hljs-keyword">while</span><span class="hljs-comment">(循环条件)</span>;<br></code></pre></td></tr></table></figure><ol><li>先执行一次，再判断，至少会执行一次</li><li>最后有一个分号</li></ol><h1 id="6-数组、排序和查找"><a href="#6-数组、排序和查找" class="headerlink" title="6.数组、排序和查找"></a>6.数组、排序和查找</h1><h2 id="6-2-数组的使用"><a href="#6-2-数组的使用" class="headerlink" title="6.2 数组的使用"></a>6.2 数组的使用</h2><h3 id="6-2-1-动态初始化"><a href="#6-2-1-动态初始化" class="headerlink" title="6.2.1 动态初始化"></a>6.2.1 动态初始化</h3><ol><li>声明数组<ol><li>int a[]; 或者 int[] a;</li></ol></li><li>创建数组<ol><li>a&#x3D;new int[10];</li></ol></li></ol><h3 id="6-2-2-静态初始化"><a href="#6-2-2-静态初始化" class="headerlink" title="6.2.2 静态初始化"></a>6.2.2 静态初始化</h3><ol><li>int[] a &#x3D; {1,2,3,4};</li></ol><h2 id="6-5-数组赋值机制"><a href="#6-5-数组赋值机制" class="headerlink" title="6.5 数组赋值机制"></a>6.5 数组赋值机制</h2><ol><li>数组在默认情况下是引用传递，赋值的是地址<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>[] arr1 = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">12</span>&#125;;<br><span class="hljs-built_in">int</span>[] arr2 = arr1;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-6-数组拷贝"><a href="#6-6-数组拷贝" class="headerlink" title="6.6 数组拷贝"></a>6.6 数组拷贝</h2><ol><li>开辟新的数据空间<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(int i<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;i&lt;n;i++)&#123;</span><br>arr2[i] <span class="hljs-operator">=</span> arr1[i]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-10-冒泡排序"><a href="#6-10-冒泡排序" class="headerlink" title="6.10 冒泡排序"></a>6.10 冒泡排序</h2><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><h2 id="6-16-二维数组使用细节"><a href="#6-16-二维数组使用细节" class="headerlink" title="6.16 二维数组使用细节"></a>6.16 二维数组使用细节</h2><ol><li>二维数组声明方式 <ol><li><code>int[][]y  int[]y[]  int y[][]</code></li></ol></li><li><code>int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;&#125;</code></li></ol><h1 id="7-面向对象编程"><a href="#7-面向对象编程" class="headerlink" title="7.面向对象编程"></a>7.面向对象编程</h1><h2 id="7-1-类与对象"><a href="#7-1-类与对象" class="headerlink" title="7.1 类与对象"></a>7.1 类与对象</h2><h3 id="7-1-8-类和对象的区别和联系"><a href="#7-1-8-类和对象的区别和联系" class="headerlink" title="7.1.8 类和对象的区别和联系"></a>7.1.8 类和对象的区别和联系</h3><ol><li>类是抽象的，是数据类型</li><li>对象是具体的，是实例</li><li>类是对象的模板</li></ol><h3 id="7-1-11-如何创建对象"><a href="#7-1-11-如何创建对象" class="headerlink" title="7.1.11 如何创建对象"></a>7.1.11 如何创建对象</h3><ol><li>先声明再创建<ol><li>Cat cat;</li><li>cat &#x3D; new Cat();</li></ol></li><li>直接创建<ol><li>Cat cat &#x3D; new Cat();</li></ol></li></ol><h3 id="7-1-13-类和对象的内存分配机制"><a href="#7-1-13-类和对象的内存分配机制" class="headerlink" title="7.1.13 类和对象的内存分配机制"></a>7.1.13 类和对象的内存分配机制</h3><ol><li>java内存的结构分析<ol><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象（Cat cat、数组等）</li><li>方法区：常量池、类加载信息</li><li>示意图</li></ol></li></ol><h2 id="7-2-成员方法"><a href="#7-2-成员方法" class="headerlink" title="7.2 成员方法"></a>7.2 成员方法</h2><h3 id="7-2-7-注意事项和使用细节"><a href="#7-2-7-注意事项和使用细节" class="headerlink" title="7.2.7 注意事项和使用细节"></a>7.2.7 注意事项和使用细节</h3><ol><li>一个方法最多有一个返回值，多个结果用数组返回</li><li>返回类型可以是任意类型</li><li>如果方法是void类型，可以没用return，或者只写return</li><li>方法名采用小驼峰命名</li><li>方法定义时的参数称为形参，调用时传入的参数称为实参</li><li>方法中不能再定义方法</li></ol><h2 id="7-5-方法重载-OverLoad"><a href="#7-5-方法重载-OverLoad" class="headerlink" title="7.5 方法重载 OverLoad"></a>7.5 方法重载 OverLoad</h2><h3 id="7-5-1-基本介绍"><a href="#7-5-1-基本介绍" class="headerlink" title="7.5.1 基本介绍"></a>7.5.1 基本介绍</h3><ol><li>java中允许同一个类中，多个同名方法存在，但是每个方法形参列表不一样</li></ol><h3 id="7-5-4-注意事项和使用细节"><a href="#7-5-4-注意事项和使用细节" class="headerlink" title="7.5.4 注意事项和使用细节"></a>7.5.4 注意事项和使用细节</h3><ol><li>方法名：必须相同</li><li>形参列表：必须不同</li><li>返回类型：不做要求</li></ol><h2 id="7-6-可变参数"><a href="#7-6-可变参数" class="headerlink" title="7.6 可变参数"></a>7.6 可变参数</h2><h3 id="7-6-1-基本概念"><a href="#7-6-1-基本概念" class="headerlink" title="7.6.1 基本概念"></a>7.6.1 基本概念</h3><ol><li>java允许将同一个类中多个同名同功能但是参数不同的方法，封装成一个方法。</li></ol><h3 id="7-6-4-注意事项和使用细节"><a href="#7-6-4-注意事项和使用细节" class="headerlink" title="7.6.4 注意事项和使用细节"></a>7.6.4 注意事项和使用细节</h3><ol><li>可变参数的实参可以是0个或者任意个</li><li>实际上是数组</li><li>可以用数组表示，也可以用int…，三个点表示</li><li>可变参数和普通类型的参数一起放在形参列表，必须保证可变参数在最后</li><li>一个形参列表中，只能出现一个可变参数</li></ol><h2 id="7-7-作用域"><a href="#7-7-作用域" class="headerlink" title="7.7 作用域"></a>7.7 作用域</h2><h3 id="7-7-1-基本使用"><a href="#7-7-1-基本使用" class="headerlink" title="7.7.1 基本使用"></a>7.7.1 基本使用</h3><ol><li>java中，主要变量是属性（成员变量、全局变量）和局部变量</li><li>局部变量一般指在成员方法中定义的变量</li><li>全局变量作用域为整个类体</li><li>局部变量作用域在定义它的代码块中</li><li>全局变量可以不赋值，直接使用，有默认值；局部变量必须赋值后才能使用</li><li>属性和局部变量可以重名，访问时就近原则</li><li>在同一个作用域中，变量不能重名</li><li>属性生命周期较长，伴随对象的创建而创建，销毁而销毁；局部变量生命周期较短，伴随代码块的执行而创建，随代码块的结束而销毁。</li><li>作用域范围不同<ol><li>全局变量：可以被本类或其他类使用</li><li>局部变量：只能在本类的对应方法中使用</li></ol></li><li>修饰符不同<ol><li>全局变量：可以加修饰符</li><li>局部变量：不能加修饰符</li></ol></li></ol><h2 id="7-8-构造方法、构造器"><a href="#7-8-构造方法、构造器" class="headerlink" title="7.8 构造方法、构造器"></a>7.8 构造方法、构造器</h2><h3 id="7-8-1-需求"><a href="#7-8-1-需求" class="headerlink" title="7.8.1 需求"></a>7.8.1 需求</h3><ol><li>之前创建对象的时候，是先把一个对象创建好后，再给对应的属性赋值</li><li>如果要求在创建对象的时候，直接指定属性值，可以使用构造器</li></ol><h3 id="7-8-2-基本语法"><a href="#7-8-2-基本语法" class="headerlink" title="7.8.2 基本语法"></a>7.8.2 基本语法</h3><ol><li>构造器的修饰符可以任意</li><li>构造器没有返回值</li><li>方法名和类名必须一样</li><li>参数列表和成员方法一样的规制</li><li>构造器的调用，由系统完成</li></ol><h3 id="7-8-3"><a href="#7-8-3" class="headerlink" title="7.8.3"></a>7.8.3</h3><ol><li>构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。</li><li><ol><li>方法名和类名相同</li></ol></li><li><ol start="2"><li>没有返回值</li></ol></li><li><ol start="3"><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。</li></ol></li></ol><h3 id="7-8-3-快速入门"><a href="#7-8-3-快速入门" class="headerlink" title="7.8.3 快速入门"></a>7.8.3 快速入门</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Person p = <span class="hljs-built_in">new</span> Person(&quot;smith&quot;,<span class="hljs-number">80</span>);<br><br><span class="hljs-keyword">class</span> Person&#123;<br>String <span class="hljs-type">name</span>;<br><span class="hljs-type">int</span> age;<br><span class="hljs-built_in">public</span> Person(String <span class="hljs-type">name</span>, <span class="hljs-type">int</span> age)&#123;<br><span class="hljs-type">name</span> = <span class="hljs-type">name</span>;<br>age = age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-8-5-注意事项和细节"><a href="#7-8-5-注意事项和细节" class="headerlink" title="7.8.5 注意事项和细节"></a>7.8.5 注意事项和细节</h3><ol><li>一个类可以定义多个不同的构造器，即构造器重载</li><li>构造器名和类名相同</li><li>构造器没有返回值</li><li>构造器是完成对象的初始化，不是创建对象</li><li>创建对象时，系统自动调用该类的构造方法</li><li>如果程序没有定义构造器，系统会自动给类生成一个默认的无参构造器</li><li>一旦定义了构造器，默认的构造器就被覆盖了，除非显式地定义一下</li></ol><h2 id="7-10-this关键字"><a href="#7-10-this关键字" class="headerlink" title="7.10 this关键字"></a>7.10 this关键字</h2><ol><li>jvm给每个对象分配this，代表当前对象</li><li>this关键字可以访问本类的属性、方法、构造器</li><li>this用于区分当前类的属性和局部变量</li><li>访问成员方法的语法：this.方法名（参数列表）</li><li>访问构造器语法：<ol><li>this(参数列表)</li><li>只能在构造器中使用，即只能在构造器中访问另外一个构造器，必须放在第一条语句</li></ol></li><li>this不能在类定义的外部使用，只能在类定义的方法中使用</li></ol><h1 id="8-面向对象编程（中级部分）"><a href="#8-面向对象编程（中级部分）" class="headerlink" title="8.面向对象编程（中级部分）"></a>8.面向对象编程（中级部分）</h1><h2 id="8-3-IDEA"><a href="#8-3-IDEA" class="headerlink" title="8.3 IDEA"></a>8.3 IDEA</h2><p><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">GitHub - judasn&#x2F;IntelliJ-IDEA-Tutorial: IntelliJ IDEA 简体中文专题教程</a></p><h3 id="8-3-5-常用快捷键"><a href="#8-3-5-常用快捷键" class="headerlink" title="8.3.5 常用快捷键"></a>8.3.5 常用快捷键</h3><p><a href="https://www.jianshu.com/p/5de7cca0fefc">IntelliJ Idea 常用快捷键列表 - 简书</a></p><h3 id="8-3-6-模板-自定义模板"><a href="#8-3-6-模板-自定义模板" class="headerlink" title="8.3.6 模板&#x2F;自定义模板"></a>8.3.6 模板&#x2F;自定义模板</h3><p>file - settings - editor - live templates</p><h2 id="8-4-包"><a href="#8-4-包" class="headerlink" title="8.4 包"></a>8.4 包</h2><h3 id="8-4-3-包基本语法"><a href="#8-4-3-包基本语法" class="headerlink" title="8.4.3 包基本语法"></a>8.4.3 包基本语法</h3><p><code>package com.edu</code> 声明当前类所在的包，放在文件最上面</p><ol><li>package 关键字，表示打包</li><li>com.edu 表示包名</li><li>com.公司名.项目名.业务模块名</li></ol><h2 id="8-5-访问修饰符"><a href="#8-5-访问修饰符" class="headerlink" title="8.5 访问修饰符"></a>8.5 访问修饰符</h2><h3 id="8-5-1-基本介绍"><a href="#8-5-1-基本介绍" class="headerlink" title="8.5.1 基本介绍"></a>8.5.1 基本介绍</h3><ol><li>java提供四种访问修饰符，用来控制类、方法和属性的访问权限<ol><li>public：对外公开</li><li>protected：对子类和同一个包中的类公开</li><li>默认：同一个包中的类公开</li><li>private：只有类本身可以访问</li></ol></li><li>只有default和public才能修饰类</li></ol><h2 id="8-6-面向对象编程的三大特征"><a href="#8-6-面向对象编程的三大特征" class="headerlink" title="8.6 面向对象编程的三大特征"></a>8.6 面向对象编程的三大特征</h2><h3 id="8-6-1-基本介绍"><a href="#8-6-1-基本介绍" class="headerlink" title="8.6.1 基本介绍"></a>8.6.1 基本介绍</h3><ol><li>封装、继承和多态</li></ol><h3 id="8-6-2-封装介绍"><a href="#8-6-2-封装介绍" class="headerlink" title="8.6.2 封装介绍"></a>8.6.2 封装介绍</h3><ol><li>封装是把抽象出的数据(属性)和对数据的操作方法封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的方法才能对数据进行操作</li><li>好处<ol><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ol></li><li>封装的实现步骤<ol><li>将属性私有化</li><li>提供public的set方法</li><li>提供public的get方法</li></ol></li></ol><h2 id="8-8-继承"><a href="#8-8-继承" class="headerlink" title="8.8 继承"></a>8.8 继承</h2><ol><li>继承可以解决代码复用</li><li>当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法</li><li>子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类</li></ol><h3 id="8-8-1-继承的基本语法"><a href="#8-8-1-继承的基本语法" class="headerlink" title="8.8.1 继承的基本语法"></a>8.8.1 继承的基本语法</h3><ol><li>class 子类 extends 父类</li><li>子类自动拥有父类定义的属性和方法</li><li>父类叫超类、基类</li><li>子类叫派生类</li></ol><h3 id="8-8-6-继承的细节"><a href="#8-8-6-继承的细节" class="headerlink" title="8.8.6 继承的细节"></a>8.8.6 继承的细节</h3><ol><li>子类继承了所有的属性和方法，非私有的方法和属性可以直接方法，私有属性和方法不能在子类直接访问，只能通过父类提供的公共方法访问</li><li>子类必须调用父类的构造器，完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译失败</li><li>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</li><li>super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)</li><li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java 所有类都是 Object 类的子类, Object 是所有类的基类.</li><li>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制</li><li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系<br><a href="https://zhuanlan.zhihu.com/p/663091776">设计与对象：理解“有一个（Has-a）”与“是一个（Is-a）”关系 Professional C++ (English Edition) 5th Edition - 知乎</a></li></ol><h2 id="8-9-super关键字"><a href="#8-9-super关键字" class="headerlink" title="8.9 super关键字"></a>8.9 super关键字</h2><ol><li>super代表父类的引用，用于访问父类的属性、方法、构造器</li><li>当子类有和父类重名的属性或者方法时，为了访问父类的成员，必须通过super</li><li>super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，可以用super访问爷爷类的成员；如果多个基类都有相同名的成员，那就super就近原则</li></ol><h2 id="8-10-方法重写-覆盖"><a href="#8-10-方法重写-覆盖" class="headerlink" title="8.10 方法重写&#x2F;覆盖"></a>8.10 方法重写&#x2F;覆盖</h2><ol><li>方法覆盖或重写，是子类的一个方法和父类的某个方法在名称、返回类型、参数一样，那么就是子类覆盖了父类的方法</li><li>子类方法的返回类型需要和父类返回类型一样，或者是父类返回类型的子类也可以，比如父类是Object，子类是String</li><li>子类方法不能缩小父类方法的访问权限</li></ol><h3 id="8-10-4-重写和重载"><a href="#8-10-4-重写和重载" class="headerlink" title="8.10.4 重写和重载"></a>8.10.4 重写和重载</h3><ol><li>重载 overload ，作用在本类，方法名必须一致，形参列表不同，返回类型和修饰符无要求</li><li>重写 override，作用在父子类，方法名必须一致，形参列表一样，返回类型一样或子类，修饰符不能缩小</li></ol><h2 id="8-11-多态"><a href="#8-11-多态" class="headerlink" title="8.11 多态"></a>8.11 多态</h2><ol><li>多态是建立在封装和继承的基础上</li></ol><h3 id="8-11-3"><a href="#8-11-3" class="headerlink" title="8.11.3"></a>8.11.3</h3><ol><li>方法的多态<ol><li>重写和重载就是多态</li></ol></li><li>对象的多态<ol><li>一个对象的编译类型和运行类型可以不一致</li><li>&#x3D;的左边是编译类型，右边是运行类型</li><li>编译类型在定义对象时就确定了，不能改变</li><li>运行类型可以变化<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Animal animal <span class="hljs-operator">=</span> new Dog()<span class="hljs-comment">;</span><br><span class="hljs-attribute">animal</span> <span class="hljs-operator">=</span> new Cat()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="8-11-5-多态注意事项和细节"><a href="#8-11-5-多态注意事项和细节" class="headerlink" title="8.11.5 多态注意事项和细节"></a>8.11.5 多态注意事项和细节</h3><ol><li>多态的前提：两个对象或者类存在继承关系</li><li>多态的向上转型<ol><li>语法：父类类型  引用名 &#x3D; new 子类类型();</li><li>本质：父类的引用指向了子类的对象</li><li>特点：<ol><li>可以调用父类中所有的成员</li><li>不能调用子类中特有的成员</li><li>最终运行效果看子类的具体实现</li></ol></li></ol></li><li>多态的向下转型<ol><li>语法：子类类型  引用名 &#x3D; (子类类型) 父类引用;</li><li>只能强转父类的引用，不能强转父类的对象</li><li>向下转型后，可以调用子类类型中所有的成员</li></ol></li><li>属性没有重写一说</li><li>instanceOf用来判断对象的运行类型是否是xx类型或者xx类型的子类型</li></ol><h2 id="8-11-7-java的动态绑定机制"><a href="#8-11-7-java的动态绑定机制" class="headerlink" title="8.11.7 java的动态绑定机制"></a>8.11.7 java的动态绑定机制</h2><ol><li>当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</li><li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li></ol><h3 id="8-11-8-多态的应用"><a href="#8-11-8-多态的应用" class="headerlink" title="8.11.8 多态的应用"></a>8.11.8 多态的应用</h3><ol><li>多态数组<ol><li>数组的定义类型为父类类型，里面保存的实际元素为子类类型</li><li>执行子类特有的方法的话，先用instanceof判断子类类型，然后强转子类类型，就可以执行子类特有方法</li></ol></li><li>多态参数<ol><li>方法定义的形参类型为父类类型，实参允许位子类类型</li></ol></li></ol><h2 id="8-12-Object详解"><a href="#8-12-Object详解" class="headerlink" title="8.12 Object详解"></a>8.12 Object详解</h2><h3 id="8-12-1-equals方法"><a href="#8-12-1-equals方法" class="headerlink" title="8.12.1 equals方法"></a>8.12.1 equals方法</h3><ol><li>&#x3D;&#x3D; <ol><li>如果判断基本类型，判断的是值是否相等</li><li>如果判断引用类型，判断的是地址是否相等，判断是不是同一个对象</li></ol></li><li>equals<ol><li>只能判断引用类型，用于判断内容是否相等</li></ol></li></ol><h3 id="8-12-4-hashCode方法"><a href="#8-12-4-hashCode方法" class="headerlink" title="8.12.4 hashCode方法"></a>8.12.4 hashCode方法</h3><ol><li>返回对象的哈希码值</li><li>两个引用，如果指向的是同一个对象，哈希值肯定是相同的</li><li>哈希值主要根据地址号来的，但是不完全等价于地址</li></ol><h3 id="8-12-5-toString方法"><a href="#8-12-5-toString方法" class="headerlink" title="8.12.5 toString方法"></a>8.12.5 toString方法</h3><ol><li>默认返回：全类名+@+哈希值的十六进制</li><li>子类往往会重写toString方法，用于返回对象的属性信息</li></ol><h3 id="8-12-6-finalize-方法"><a href="#8-12-6-finalize-方法" class="headerlink" title="8.12.6 finalize 方法"></a>8.12.6 finalize 方法</h3><ol><li>当对象被回收时，系统自动调用该对象的finalize方法</li><li>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法。</li><li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li></ol><h3 id="8-13-断点调试"><a href="#8-13-断点调试" class="headerlink" title="8.13 断点调试"></a>8.13 断点调试</h3><ol><li>断点调试过程中，是运行状态，以对象的运行类型来执行的</li><li>快捷键<ol><li>F7 跳入方法内</li><li>F8 逐行执行代码</li><li>shift + F8 跳出</li><li>F9 执行到下一个断点</li></ol></li></ol><h1 id="10-面向对象编程（高级部分）"><a href="#10-面向对象编程（高级部分）" class="headerlink" title="10. 面向对象编程（高级部分）"></a>10. 面向对象编程（高级部分）</h1><h2 id="10-1-类变量和类方法"><a href="#10-1-类变量和类方法" class="headerlink" title="10.1 类变量和类方法"></a>10.1 类变量和类方法</h2><h3 id="10-1-4-类变量内存分布"><a href="#10-1-4-类变量内存分布" class="headerlink" title="10.1.4 类变量内存分布"></a>10.1.4 类变量内存分布</h3><ol><li>static 变量是对象共享</li><li>不管static变量在哪，同一个类所有对象共享</li><li>static 类变量，在类加载的时候就生成了</li></ol><h3 id="10-1-5-什么是类变量"><a href="#10-1-5-什么是类变量" class="headerlink" title="10.1.5 什么是类变量"></a>10.1.5 什么是类变量</h3><ol><li>类变量也叫静态变量&#x2F;静态属性</li><li>该类所有对象共享的变量</li><li>任何一个该类的对象访问它的时候，取到的值是相同的值</li></ol><h3 id="10-1-6-定义类变量"><a href="#10-1-6-定义类变量" class="headerlink" title="10.1.6 定义类变量"></a>10.1.6 定义类变量</h3><ol><li>访问修饰符 static 数据类型 变量名</li><li>static 访问修饰符 数据类型 变量名</li></ol><h3 id="10-1-7-访问类变量"><a href="#10-1-7-访问类变量" class="headerlink" title="10.1.7 访问类变量"></a>10.1.7 访问类变量</h3><ol><li>类名.类变量名（推荐）</li><li>对象名.类变量名</li><li>类变量的访问权限受访问修饰符限制</li></ol><h3 id="10-1-8-类变量使用和注意事项"><a href="#10-1-8-类变量使用和注意事项" class="headerlink" title="10.1.8 类变量使用和注意事项"></a>10.1.8 类变量使用和注意事项</h3><ol><li>当我们需要让某个类的所有对象共享一个变量时，就可以考虑使用类变量</li><li>加上static称为类变量或静态变量，否则称为实例变量、普通变量、非静态变量</li><li>实例变量不能通过 类名.类变量名 访问</li><li>类变量是在类加载时就初始化了，即使没有创建对象，只要类加噪了就可以使用类变量</li><li>类变量生命周期是随类的加载开始，类的消亡而消亡</li></ol><h3 id="10-1-9-类方法基本介绍"><a href="#10-1-9-类方法基本介绍" class="headerlink" title="10.1.9 类方法基本介绍"></a>10.1.9 类方法基本介绍</h3><ol><li>类方法也叫静态方法</li><li>形式：<ol><li>访问修饰符 static 数据返回类型 方法名(){} 推荐</li><li>static 访问修饰符 数据返回类型 方法名(){}</li></ol></li><li>类方法的调用<ol><li>类名.类方法名  </li><li>对象名.类方法名</li></ol></li><li>类方法的经典使用场景<ol><li>当方法中不涉及到任何和对象相关的成员，就可以将方法设计成静态方法<ol><li>比如工具类的方法 utils</li><li>把一些通用的方法设计成静态方法，这样不需要创建对象就可以使用</li></ol></li></ol></li><li>注意事项和细节<ol><li>类方法和普通方法都随着类的加载而加载，将结构信息存储在方法区</li><li>类方法中没有this的参数，普通方法中隐含着this的参数</li><li>类方法可以通过类名调用，可以通过对象名调用</li><li>普通方法和对象有关，需要通过对象名调用</li><li>类方法中不允许使用和对象有关的关键字，比如this和super</li><li>类方法只能访问静态变量或静态方法</li><li>普通方法既可以访问非静态成员，也可以访问静态成员</li></ol></li></ol><h2 id="10-2-理解main方法语法"><a href="#10-2-理解main方法语法" class="headerlink" title="10.2 理解main方法语法"></a>10.2 理解main方法语法</h2><ol><li>public static void main(String[] args)<ol><li>main 方法时虚拟机调用</li><li>java虚拟机需要调用类的main方法，所以访问权限必须是public</li><li>java虚拟机在执行main方法时不必创建对象，所以是static</li></ol></li><li>main() 方法中，可以直接调用main方法所在类的静态方法或静态属性<ol><li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol></li></ol><h2 id="10-3-代码块"><a href="#10-3-代码块" class="headerlink" title="10.3 代码块"></a>10.3 代码块</h2><ol><li>代码块又称为初始化块，类似于方法，但是没有方法名、返回、参数，只有方法体</li><li>加载类时，创建对象时隐式调用</li><li>语法 ： <ol><li>static{}; 静态代码块，随着类的加载而执行，只会执行一次</li><li>{}; 非静态代码块，创建一个对象就执行</li></ol></li><li>相当于另外一种形式的构造器，可以做初始化操作</li><li>场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性</li><li>类什么时候被加载<ol><li>创建对象实例时  new</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时</li></ol></li><li>创建一个对象时，在一个类中调用顺序：</li></ol><h2 id="10-4-单例模式"><a href="#10-4-单例模式" class="headerlink" title="10.4 单例模式"></a>10.4 单例模式</h2><ol><li>单例：单个实例</li><li>采取一定的方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</li><li>两种方式<ol><li>饿汉式<ol><li>构造器私有化 -&gt; 防止直接new</li><li>类的内部创建private static对象</li><li>向外暴露一个静态公共方法，public getInstance</li><li>饿汉式的缺点是创建了对象但是没有使用，导致资源的浪费</li></ol></li><li>懒汉式<ol><li>构造器私有化</li><li>定义静态属性对象 private static Cat cat;</li><li>提供public static方法，可以返回一个Cat对象</li><li>只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象</li></ol></li><li>区别<ol><li>主要区别是创建对象的时机不同，饿汉式是类加载时就创建了对象实例，懒汉是在使用时才创建</li><li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li><li>饿汉式存在资源浪费的可能</li></ol></li></ol></li></ol><h2 id="10-5-final关键字"><a href="#10-5-final关键字" class="headerlink" title="10.5 final关键字"></a>10.5 final关键字</h2><ol><li>final 可以修饰类、属性、方法、局部变量</li><li>需求<ol><li>不希望类被继承时，可以用final修饰</li><li>不希望父类的某个方法被子类重写</li><li>不希望类的某个属性的值被修改</li><li>不希望某个局部变量值被修改</li></ol></li><li>注意<ol><li>final修饰的属性又叫常量，一般用 XX_XX_XX 命令</li><li>final修饰的属性在定义时，必须赋初值，并且以后不能再修改<ol><li>赋值的位置可以在定义时、构造器中、代码块中</li></ol></li><li>如果final修饰的属性是静态的，初始化的位置只能是定义时、静态代码块中</li><li>final类不能被继承，但是可以实例化对象</li><li>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</li><li>一般来说，如果一个类已经是final类了，就没必要将该方法修饰成final方法。都已经不能被继承了，还怎么可以重写方法</li><li>final不能修饰构造方法</li><li><strong>final和static往往搭配使用，不会导致类加载</strong></li><li>包装类都是final类，Integer  Double  Float  Boolean  String</li></ol></li></ol><h2 id="10-6-抽象类"><a href="#10-6-抽象类" class="headerlink" title="10.6 抽象类"></a>10.6 抽象类</h2><ol><li>当父类的某些方法需要声明，但是不确定如何实现时，可以将其声明为抽象方法，这个类就是抽象类</li><li>抽象方法就是没有实现的方法</li><li>用abstract修饰的类就是抽象类</li><li>抽象类不一定要包含抽象方法，有抽象方法类一定要声明abstract</li><li>abstract只能修饰类和方法，不能修饰其他</li><li>抽象类可以有任意成员，本质还是类</li><li>抽象方法不能有主体，也就是不能有实现，也就是不能有大括号，有了大括号就意味着实现</li><li>如果一个类继承了抽象类，必须实现抽象类中所有的抽象方法，除非自己也声明abstract</li><li>抽象方法不能被private final static这三个关键字修饰</li></ol><h2 id="10-7-抽象类最佳实践-模板设计模式"><a href="#10-7-抽象类最佳实践-模板设计模式" class="headerlink" title="10.7 抽象类最佳实践 - 模板设计模式"></a>10.7 抽象类最佳实践 - 模板设计模式</h2><ol><li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行拓展、改造，但是子类总体上会保留抽象类的行为方式。</li><li>模板设计模式能解决的问题<ol><li>当功能内部一部分实现是确定的，一部分实现是不确定的，就可以把不确定的部分暴露出去，让子类去实现</li><li>编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式</li></ol></li></ol><h2 id="10-8-接口"><a href="#10-8-接口" class="headerlink" title="10.8 接口"></a>10.8 接口</h2><ol><li>接口是将一些没有实现的方法封装到一起，到某个类要使用的时候，根据具体情况把这些方法写出来<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名&#123;<br>属性<br>抽象方法<br>&#125;<br>class 类名 implements 接口&#123;<br>自己属性<br>自己方法<br>&#125;<br></code></pre></td></tr></table></figure></li><li>接口是更加抽象的抽象类，接口里的所有方法都没有方法体 jdk7</li><li>接口体现了程序设计的多态和高内聚低耦合的设计思想</li><li>jdk8后，接口类可以有静态方法、普通方法，也就是可以有方法的具体实现</li><li>注意<ol><li>接口不能被实例化</li><li>接口中所有方法都是public方法，接口中的抽象方法可以不用abstract修饰</li><li>抽象类实现接口可以不用实现接口的方法</li><li>一个普通类实现接口必须将接口的所有方法都实现</li><li>一个类可以同时实现多个接口 <code>class A implements B,C&#123;&#125;</code></li><li>接口中的属性只能是public static final修饰</li><li>接口中属性的访问：接口名.属性名</li><li>接口不能继承其他的类，但是可以继承多个接口 <code>interface A extends B,C&#123;&#125;</code></li><li>接口的修饰符和类一样，只能是默认或者public</li></ol></li><li>实现接口 vs 继承类<ol><li>继承的价值：解决代码的复用性和可维护性</li><li>接口的价值：设计好规范(方法)，让其他类去实现</li><li>接口比继承更灵活，继承是 is-a关系 ，接口是like-a关系</li><li>接口在一定程度上实现代码解耦，即接口规范性+动态绑定机制</li></ol></li><li>接口的多态性<ol><li>多态参数：用到接口的参数，可以用实现了接口的子类代替</li><li>多态数组：</li><li>接口存在多态传递</li></ol></li><li>可以使用接口定义对象，比如<code>Interface A = new A实现类();</code></li></ol><h2 id="10-9-内部类"><a href="#10-9-内部类" class="headerlink" title="10.9 内部类"></a>10.9 内部类</h2><ol><li>定义类在局部位置(方法中&#x2F;代码块)<ol><li>局部内部类</li><li>匿名内部类</li></ol></li><li>定义类在成员位置<ol><li>成员内部类</li><li>静态内部类</li></ol></li><li>一个类的内部又完整地嵌套了另一个类结构，被嵌套的类称为内部类，嵌套其他类的类称为外部类，是我们类的第五大成员（属性、方法、构造器、代码块、内部类）</li><li>内部类最大的特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系</li><li>语法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>内部类的分类<ol><li>定义在外部类局部位置，比如方法内<ol><li>局部内部类，有类名</li><li>匿名内部类，没有类名</li></ol></li><li>定义在外部类的成员位置上<ol><li>成员内部类，没用static修饰</li><li>静态内部类，使用static修饰</li></ol></li></ol></li></ol><h3 id="10-9-5-局部内部类的使用"><a href="#10-9-5-局部内部类的使用" class="headerlink" title="10.9.5 局部内部类的使用"></a>10.9.5 局部内部类的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> n+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</li><li>可以直接访问外部类所有成员，包含私有的属性和方法</li><li>不能添加添加访问修饰符，但是可以使用final修饰</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>局部内部类可以直接访问外部类的成员</li><li>外部类要想访问局部内部类的成员，方式是创建对象再访问，必须在作用域中</li><li>外部其他类不能访问局部内部类</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则；如果要访问外部类的成员，可以使用 外部类名.this.成员 访问</li></ol><h3 id="10-9-6-匿名内部类的使用（重要）"><a href="#10-9-6-匿名内部类的使用（重要）" class="headerlink" title="10.9.6 匿名内部类的使用（重要）"></a>10.9.6 匿名内部类的使用（重要）</h3><ol><li>本质是类</li><li>内部类</li><li>该类没有名字，其实系统低层会分配一个名字，我们也可以打印出来，但是不能在代码流程中使用</li><li>同时也是一个对象</li><li>匿名内部类定义在外部类的局部位置，比如方法中，没有类名</li><li>语法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类或接口(参数列表)&#123;<br>类体<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java\接口">//5. tiger的编译类型 ? IA<br>//6. tiger的运行类型 ? 就是匿名内部类  Outer04$1<br>IA tiger = new IA() &#123;  <br>    @Override  <br>    public void cry() &#123;  <br>        System.out.println(&quot;老虎叫唤...&quot;);  <br>    &#125;  <br>&#125;;<br><br>class Outer04$1 implements IA &#123;  <br>    @Override    public void cry() &#123;        System.out.println(&quot;老虎叫唤...&quot;);  <br>    &#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">father</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>(<span class="hljs-string">&quot;jack&quot;</span>)&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;匿名内部类重写了test方法&quot;</span>);  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure></li><li>匿名内部类使用一次就不能再使用了，但是new 的对象是可以重复使用，比如tiger</li><li>匿名内部类的语法比较奇特<ol><li>匿名内部类既是一个类的定义，同时本身也是一个对象，因此从语法上，它既有定义类的特征，也有创建对象的特征<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">88</span>;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//可以直接访问外部类的所有成员，包含私有的  </span><br>        <span class="hljs-comment">//如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，  </span><br>        <span class="hljs-comment">//默认遵循就近原则，如果想访问外部类的成员，则可以使用 （外部类名.this.成员）去访问  </span><br>        System.out.println(<span class="hljs-string">&quot;匿名内部类重写了 hi方法 n1=&quot;</span> + n1 +  <br>                <span class="hljs-string">&quot; 外部内的n1=&quot;</span> + Outer05.<span class="hljs-built_in">this</span>.n1 );  <br>    &#125;  <br>&#125;;  <br>p.hi();<span class="hljs-comment">//动态绑定, 运行类型是 Outer05$1</span><br></code></pre></td></tr></table></figure></li></ol></li><li>可以直接访问外部类的所有成员，包含私有的</li><li>不能添加访问修饰符，它的地位就是一个局部变量</li><li>作用域：仅仅在定义它的方法或代码块</li><li>匿名内部类访问外部类成员：直接访问</li><li>外部其他类不能访问匿名内部类</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则；如果要访问外部类的成员，可以使用 外部类名.this.成员 访问</li></ol><h3 id="10-9-7-匿名内部类的最佳实践"><a href="#10-9-7-匿名内部类的最佳实践" class="headerlink" title="10.9.7 匿名内部类的最佳实践"></a>10.9.7 匿名内部类的最佳实践</h3><ol><li>当做实参直接传递，简洁高效<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IL</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;  <br>&#125;<br>f1(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IL</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;这是一副名画~~...&quot;</span>);  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h3 id="10-9-9-成员内部类"><a href="#10-9-9-成员内部类" class="headerlink" title="10.9.9 成员内部类"></a>10.9.9 成员内部类</h3><ol><li>成员内部类定义在外部类的成员位置，没有static修饰</li><li>可以直接访问外部类的所有成员，包含私有的</li><li>可以添加任意访问修饰符，因为地位就是一个成员</li><li>作用域：整个类体</li><li>成员内部类访问外部类成员，直接访问</li><li>外部类访问成员内部类，创建对象再访问，私有成员也可以直接访问，毕竟都是在同一个外部类中</li><li>外部其他类访问成员内部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一种方式</span><br><span class="hljs-comment">// outer08.new Inner08(); 相当于把 new Inner08()当做是outer08成员</span><br>Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> outer08.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();  <br>inner08.say();<br><span class="hljs-comment">// 第二方式 在外部类中，编写一个方法，可以返回 Inner08对象  </span><br>Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance</span> <span class="hljs-operator">=</span> outer08.getInner08Instance();  <br>inner08Instance.say();<br><span class="hljs-keyword">public</span> Inner08 <span class="hljs-title function_">getInner08Instance</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则；如果要访问外部类的成员，可以使用 外部类名.this.成员 访问</li></ol><h3 id="10-9-10-静态内部类的使用"><a href="#10-9-10-静态内部类的使用" class="headerlink" title="10.9.10 静态内部类的使用"></a>10.9.10 静态内部类的使用</h3><ol><li>静态内部类定义在外部类的成员位置，有static修饰</li><li>可以直接访问外部类的所有静态成员，包含私有的，但是不能直接访问非静态成员</li><li>可以使用任意访问修饰符</li><li>作用域：整个类体</li><li>静态内部类可以直接访问外部类所有静态成员</li><li>成员内部类访问外部类成员，直接访问</li><li>其他同成员内部类</li></ol><h1 id="11-枚举和注解"><a href="#11-枚举和注解" class="headerlink" title="11.枚举和注解"></a>11.枚举和注解</h1><ol><li>分析问题<ol><li>创建的对象有以下特点<ol><li>季节的值是有限的几个值</li><li>只读，不需要修改</li></ol></li></ol></li><li>解决方案<ol><li>枚举 enum</li><li>枚举是一组常量的集合</li><li>枚举是一种特殊的类，里面只包含一组有限的特定的对象</li></ol></li><li>实现方式<ol><li>自定义实现枚举</li><li>使用enum关键字实现枚举</li></ol></li><li>自定义实现枚举<ol><li>构造器私有化，目的防止直接new</li><li>不需要提供setXxx方法</li><li>对枚举对象&#x2F;属性使用final + static 修饰，实现低层优化</li><li>枚举对象名称通常使用全部大写</li><li>枚举对象根据需要，也可以有多个属性</li><li>本类内部创建一组对象，比如春夏秋冬四个对象</li><li>对外暴露对象，在对象前加 public final static 修饰符</li></ol></li></ol><h2 id="11-7-enum关键字"><a href="#11-7-enum关键字" class="headerlink" title="11.7 enum关键字"></a>11.7 enum关键字</h2><ol><li>使用关键字enum替代class，<code>class Season</code> -&gt; <code>enum Season</code></li><li>自定义格式<code>public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;)</code>，关键字格式<code>SPRING(&quot;春天&quot;, &quot;温暖&quot;) 解读 常量名(实参列表)</code></li><li>如果有多个常量（对象），使用逗号间隔即可</li><li>如果使用 enum 来实现枚举，要求将定义常量对象，写在前面</li></ol><h3 id="11-7-2-enum关键字实现枚举注意事项"><a href="#11-7-2-enum关键字实现枚举注意事项" class="headerlink" title="11.7.2 enum关键字实现枚举注意事项"></a>11.7.2 enum关键字实现枚举注意事项</h3><ol><li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类</li><li>传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)</li><li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li><li>当有多个枚举对象时，使用,间隔，最后有一个分号结尾</li><li>枚举对象必须放在枚举类的行首</li></ol><h2 id="11-9-enum常用方法说明"><a href="#11-9-enum常用方法说明" class="headerlink" title="11.9 enum常用方法说明"></a>11.9 enum常用方法说明</h2><ol><li>关键字enum隐式继承Enum类，使用可以使用Enum类相关方法</li><li>name：返回当前对象名（常量名）</li><li>ordinal：返回当前对象的位置号，默认从 0 开始</li><li>values：返回当前枚举类中所有的常量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Season2[] values = Season2.values();  <br>System.out.println(<span class="hljs-string">&quot;===遍历取出枚举对象(增强for)====&quot;</span>);  <br><span class="hljs-keyword">for</span> (Season2 season: values) &#123;<span class="hljs-comment">//增强for循环  </span><br>    System.out.println(season);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li>valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</li><li>compareTo：比较两个枚举常量，比较的就是编号</li><li>toString:Enum 类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息</li></ol><h2 id="11-11-enum实现接口"><a href="#11-11-enum实现接口" class="headerlink" title="11.11 enum实现接口"></a>11.11 enum实现接口</h2><ol><li>使用enum关键字后，就不能再继承其他类了，因为enum隐式继承Enum，java是单继承机制</li><li>枚举类和普通类一样可以实现接口<code>enum 类名 implements 接口 1，接口 2&#123;&#125;</code></li></ol><h2 id="11-12-注解"><a href="#11-12-注解" class="headerlink" title="11.12 注解"></a>11.12 注解</h2><ol><li>注解 annotation 也被称为元数据，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息</li><li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</li><li>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。</li></ol><h2 id="11-13-基本的Annotation介绍"><a href="#11-13-基本的Annotation介绍" class="headerlink" title="11.13 基本的Annotation介绍"></a>11.13 基本的Annotation介绍</h2><ol><li>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用</li><li>三个基本的注解<ol><li>@Override：限定某个方法，是重写父类方法<ol><li>如果你写了@Override注解，编译器就会去检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误</li><li>只能修饰方法，不能修饰其他类、包、属性等</li></ol></li><li>@Deprecated：用于表示某个程序元素（类、方法等）已过时<ol><li>可以修饰方法、类、字段、包、参数等</li><li>不推荐使用，但是可以继续使用</li><li>作用可以做到新旧版本的兼容和过渡</li></ol></li><li>@SuppressWarning：抑制编译器警告<ol><li>在{“”} 中，可以写入你希望抑制(不显示)警告信息<ol><li>all，抑制所有警告</li><li>cast，抑制与强制转型作业相关的警告</li><li>boxing，抑制与封装&#x2F;拆装作业相关的警告</li><li>null，抑制与空值分析相关的警告</li><li>…</li><li>unchecked 忽略没有检查的警告</li><li>rawtypes 忽略没有指定泛型的警告</li><li>unused 忽略没有使用某个变量的警告</li></ol></li><li>作用范围和放置的位置相关</li></ol></li></ol></li><li>@interface不是接口类，而是注解类</li><li>@Target 是修饰注解的注解，称为元注解</li></ol><h2 id="11-15-JDK的元注解（了解）"><a href="#11-15-JDK的元注解（了解）" class="headerlink" title="11.15 JDK的元注解（了解）"></a>11.15 JDK的元注解（了解）</h2><ol><li>元注解本身作用不大，是用来修饰注解的注解</li><li>元注解种类<ol><li>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME<ol><li>RetentionPolicy.SOURCE：编译器使用后，直接丢弃这种策略的注解</li><li>.CLASS：编译器将注解记录在class文件中，当运行java程序时，jvm不会保留注解，默认值</li><li>.RUNTIME：编译器将注解记录在class文件中，运行java程序时，JVM会保留注解。程序可以通过反射获取该注解</li></ol></li><li>Target &#x2F;&#x2F; 指定注解可以在哪些地方使用，注入范围<ol><li>Target.METHOD</li><li>.PARAMTER</li><li>.TYPE</li><li>.PACKAGE</li><li>…</li></ol></li><li>Documented &#x2F;&#x2F;指定该注解是否会在 javadoc 体现</li><li>Inherited &#x2F;&#x2F;子类会继承父类注解</li></ol></li></ol><h1 id="12-异常-Exception"><a href="#12-异常-Exception" class="headerlink" title="12.异常-Exception"></a>12.异常-Exception</h1><h2 id="12-2-异常捕获"><a href="#12-2-异常捕获" class="headerlink" title="12.2 异常捕获"></a>12.2 异常捕获</h2><ol><li>try-catch 异常处理机制解决异常问题</li><li>代码块 - 选中 - ctrl+alt+t - try-catch</li></ol><h2 id="12-3-异常介绍"><a href="#12-3-异常介绍" class="headerlink" title="12.3 异常介绍"></a>12.3 异常介绍</h2><ol><li>程序执行中发生的不正常情况，开发过程中的语法错误和逻辑错误不是异常</li><li>异常事件分为两类<ol><li>Error：JVM无法解决的问题，比如JVM系统内部错误、资源耗尽、StackOverflowError和OOM</li><li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理，比如空指针访问、试图读取不存在的文件、网络连接中断等<ol><li>运行时异常</li><li>编译时异常</li></ol></li></ol></li></ol><h2 id="12-4-异常体系图"><a href="#12-4-异常体系图" class="headerlink" title="12.4 异常体系图"></a>12.4 异常体系图</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240411165727.png" alt="image.png"></p><ol><li>运行时异常可以不做处理</li><li>编译时异常，必须要处理的异常</li><li>常见运行时异常包括<ol><li>NullPointerException 空指针异常</li><li>ArithmeticException 数学运算异常</li><li>ArrayIndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 类型转换异常</li><li>NumberFormatException 数字格式不正常异常</li></ol></li></ol><h2 id="12-6-编译异常"><a href="#12-6-编译异常" class="headerlink" title="12.6 编译异常"></a>12.6 编译异常</h2><ol><li>常见编译异常<ol><li>SQLException 操作数据库，查询表可能发生异常</li><li>IOExcetion 操作文件时，发生的异常</li><li>FileNotFoundException 操作一个不存在的文件时，发生异常</li><li>ClassNotFoundException 加载类，该类不存在时，异常</li><li>EOFException  操作文件，到文件末尾，发生异常</li><li>IllegalArgumentException 参数异常</li></ol></li></ol><h2 id="12-8-异常处理"><a href="#12-8-异常处理" class="headerlink" title="12.8 异常处理"></a>12.8 异常处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>代码可能有异常<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>捕获到异常时，将异常封装成Exception对象e，传递给<span class="hljs-keyword">catch</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>不管<span class="hljs-keyword">try</span>代码块是否有异常发生，都要执行<span class="hljs-keyword">finally</span><br>通常将资源的释放操作放在<span class="hljs-keyword">finally</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>方式<ol><li>try - cathc -finally<ol><li>程序员在代码捕获发生的异常，自行处理</li></ol></li><li>throws<ol><li>将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者JVM<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240411171245.png" alt="image.png|500"></li></ol></li></ol></li></ol><h2 id="12-9-try-catch-异常处理"><a href="#12-9-try-catch-异常处理" class="headerlink" title="12.9 try-catch 异常处理"></a>12.9 try-catch 异常处理</h2><ol><li>可以有多个catch语句，捕获不同的异常，要求父类异常在后，子类异常在前，如果发生异常只会匹配一个catch</li></ol><h2 id="12-10-throws异常处理"><a href="#12-10-throws异常处理" class="headerlink" title="12.10 throws异常处理"></a>12.10 throws异常处理</h2><ol><li>如果一个方法可能生成某种异常，但不确定如何处理，则此方法应显式声明抛出异常，表示该方法将不对这些异常进行处理，而该方法的调用者负责处理</li><li>throws可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li></ol><h2 id="12-11-自定义异常"><a href="#12-11-自定义异常" class="headerlink" title="12.11 自定义异常"></a>12.11 自定义异常</h2><ol><li>步骤<ol><li>定义类：自定义异常类名，继承Exception或RuntimeException</li><li>如果继承Exception，属于编译异常</li><li>如果继承RuntimeException，属于运行异常，一般都设置这个<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeException</span><span class="hljs-params">(String message)</span> &#123;<span class="hljs-comment">//构造器  </span><br>        <span class="hljs-built_in">super</span>(message);  <br>    &#125;  <br>&#125;<br><span class="hljs-keyword">if</span>(!(age &gt;= <span class="hljs-number">18</span> &amp;&amp; age &lt;= <span class="hljs-number">120</span>)) &#123;  <br>    <span class="hljs-comment">//这里我们可以通过构造器，设置信息  </span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeException</span>(<span class="hljs-string">&quot;年龄需要在 18~120之间&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="12-12-throw和throws的区别"><a href="#12-12-throw和throws的区别" class="headerlink" title="12.12 throw和throws的区别"></a>12.12 throw和throws的区别</h2><ol><li>throws：异常处理的一种方式，位置在方法声明处，后面跟异常类型</li><li>throw：手动生成异常对象的关键帧，位置在方法体中，后面跟异常对象</li></ol><h1 id="13-常用类"><a href="#13-常用类" class="headerlink" title="13.常用类"></a>13.常用类</h1><h2 id="13-1-包装类"><a href="#13-1-包装类" class="headerlink" title="13.1 包装类"></a>13.1 包装类</h2><ol><li>针对八种基本数据类型相应的引用类型</li><li>Boolean&#x2F;Character&#x2F;Byte&#x2F;Short&#x2F;Integer&#x2F;Long&#x2F;Float&#x2F;Double</li><li>jdk5前，手动装箱和拆箱，装箱：基本类型-&gt;包装类型</li><li>jdk5后，自动装箱和拆箱<ol><li>自动装箱int-&gt;Integer底层调用的是valueOf()，如Integer.valueOf()</li><li>拆箱 Integer-&gt;int，Integer.intValue()</li></ol></li></ol><h3 id="13-1-5-包装类型和-String-类型的相互转换"><a href="#13-1-5-包装类型和-String-类型的相互转换" class="headerlink" title="13.1.5 包装类型和 String 类型的相互转换"></a>13.1.5 包装类型和 String 类型的相互转换</h3><ol><li>Integer -&gt; String<ol><li>Integer.toString()</li><li>String.value(Integer i)</li><li>i+””</li></ol></li><li>String -&gt; Integer<ol><li>Integer.parseInt(str)</li><li>new Integer(str) &#x2F;&#x2F; 构造器</li></ol></li></ol><h2 id="13-2-String类"><a href="#13-2-String类" class="headerlink" title="13.2 String类"></a>13.2 String类</h2><ol><li>两种创建String对象的方式<ol><li>直接赋值：String s &#x3D; “123”;</li><li>调用构造器：String s &#x3D; new String(“123”);</li></ol></li><li>string是final类，代表不可变，一旦被分配内容，内容不可再变，每次更新实际改的是地址，效率较低</li><li>StringBuffer保存的是字符串变量，里面的值可以更改，更新的是内容不用更新地址，效率较高</li><li>String-&gt;StringBuffer<ol><li>方式1：StringBuffer stringBuffer &#x3D; new StringBuffer(str);</li><li>方式2：StringBuffer stringBuffer &#x3D; new StringBuffer(); stringBuffer &#x3D; stringBuffer.append(str);</li></ol></li><li>StringBuffer -&gt; String<ol><li>方式1：String s &#x3D; stringBuffer3.toString();</li><li>方式2：String s1 &#x3D; new String(stringBuffer3);</li></ol></li><li>StringBuilder，同StringBuffer，不是线程安全的，如果单线程使用优先使用，在大多数实现中，比StringBuffer快</li></ol><h2 id="13-8-Arrays类"><a href="#13-8-Arrays类" class="headerlink" title="13.8 Arrays类"></a>13.8 Arrays类</h2><ol><li>Arrays.toString(arr) 返回数组的字符串形式</li><li>Arrays.sort()</li><li>Arrays.binarySearch(arr, 3) 二分查找</li><li>Integer[] newArr &#x3D; Arrays.copyOf(arr, arr.length)</li><li>Arrays.fill(arr, 99)</li><li>Arrays.equals(arr1, arr2) 比较两个数组元素内容是否完全一致</li><li>List&lt;Integer&gt; asList &#x3D; Arrays.asList(arr) 转换成list</li></ol><h2 id="13-9-System类"><a href="#13-9-System类" class="headerlink" title="13.9 System类"></a>13.9 System类</h2><ol><li>exit(0) 退出当前程序,0表示正常退出状态</li><li>System.arraycopy(arr1, 0, arr2, 0, 3)</li><li>currentTimeMillens:返回当前时间距离1970-1-1到现在的毫秒数</li><li>System.gc()  垃圾回收机制</li></ol><h2 id="13-10-BigInteger和BigDecimal类"><a href="#13-10-BigInteger和BigDecimal类" class="headerlink" title="13.10 BigInteger和BigDecimal类"></a>13.10 BigInteger和BigDecimal类</h2><ol><li>BI：保存比较大的整型</li><li>BD：保存精度更高的浮点数</li><li>常见方法<ol><li>add 加</li><li>subtract 减</li><li>multiply 乘</li><li>divide 除</li></ol></li></ol><h2 id="13-11-日期类"><a href="#13-11-日期类" class="headerlink" title="13.11 日期类"></a>13.11 日期类</h2><ol><li>Date：精确到毫秒，代表特定瞬间<ol><li>Date d1 &#x3D; new Date(); &#x2F;&#x2F;获取当前系统时间</li></ol></li><li>SimpleDateFormat：格式和解析日期的类<ol><li>SimpleDateFormat sdf &#x3D; new SimpleDateFormat(“yyyy 年 MM 月 dd 日 hh:mm:ss E”);</li></ol></li><li>Calendar 是一个抽象类， 并且构造器是 private<ol><li>通过 getInstance() 来获取实例 Calendar c &#x3D; Calendar.getInstance();</li><li>c.get(Calendar.MONTH) + 1</li><li>c.get(Calendar.DAY_OF_MONTH)</li><li>…</li></ol></li><li>LocalDate&#x2F;LocalTime&#x2F;LocalDateTime<ol><li>使用 now() 返回表示当前日期时间的 对象</li><li>使用 DateTimeFormatter 对象来进行格式化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> dateTimeFormatter.format(ldt);<br>System.out.println(<span class="hljs-string">&quot;格式化的日期=&quot;</span> + format);<br></code></pre></td></tr></table></figure></li></ol></li><li>Instant 时间戳<ol><li>Instant now &#x3D; Instant.now();  获取表示当前时间戳的对象</li><li>Date date &#x3D; Date.from(now);   通过 from 可以把 Instant 转成 Date   </li><li>Instant instant &#x3D; date.toInstant();   通过 date 的 toInstant() 可以把 date 转成 Instant 对象</li></ol></li></ol><h1 id="14-集合"><a href="#14-集合" class="headerlink" title="14.集合"></a>14.集合</h1><ol><li>集合动态保存任意多个对象<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240412153126.png" alt="image.png"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240412153139.png" alt="image.png|474"></li></ol><h2 id="14-3-Collection接口"><a href="#14-3-Collection接口" class="headerlink" title="14.3 Collection接口"></a>14.3 Collection接口</h2><h3 id="14-3-2-Collection接口遍历元素方式"><a href="#14-3-2-Collection接口遍历元素方式" class="headerlink" title="14.3.2 Collection接口遍历元素方式"></a>14.3.2 Collection接口遍历元素方式</h3><ol><li>Iterator 迭代器<ol><li>Iterator 仅用于遍历集合，本身并不存放对象</li><li><code>Iterator iterator = coll.iterator();</code> 得到集合的迭代器</li><li>hashNext() 判断是否还有下一个元素</li><li>next() 下移元素，取出元素</li></ol></li><li>增强for循环<ol><li>增强for就是简化版的iterator</li><li>只能用来遍历集合或数组</li><li><code>for(元素类型 元素名：集合名或数组名)</code></li></ol></li></ol><h2 id="14-4-接口和常用方法"><a href="#14-4-接口和常用方法" class="headerlink" title="14.4 接口和常用方法"></a>14.4 接口和常用方法</h2><ol><li>List集合类中元素有序，添加元素顺序和取出顺序一致，可重复</li><li>每个元素都有对应的顺序索引，所以支持索引</li><li>List接口的实现类有ArrayLsit、LinkedList、Vector</li><li>常用方法<ol><li>add(元素)</li><li>add(index, 元素)</li><li>indexOf(元素)</li><li>get(index)</li><li>lastIndexOf(obj)</li><li>remove(obj)</li><li>set(index, obj)</li><li>subList(fromIndex, toIndex)</li></ol></li></ol><h3 id="14-4-4-List的三种遍历方式"><a href="#14-4-4-List的三种遍历方式" class="headerlink" title="14.4.4 List的三种遍历方式"></a>14.4.4 List的三种遍历方式</h3><ol><li>迭代器<ol><li>while(iterator.hasNext()){print(iterator.next())}</li></ol></li><li>增强for<ol><li>for(Object o : list)</li></ol></li><li>普通for</li></ol><h2 id="14-5-ArrayList-低层结构和源码分析"><a href="#14-5-ArrayList-低层结构和源码分析" class="headerlink" title="14.5 ArrayList 低层结构和源码分析"></a>14.5 ArrayList 低层结构和源码分析</h2><ol><li>ArrayList可以加入null，并且多个</li><li>ArrayList低层由数组实现</li><li>ArrayList基本等同于Vector，线程不安全，执行效率高，多线程情况下不建议用ArrayList</li><li>低层源码<ol><li>ArrayList中维护了应该Object类型的数组，elementData</li><li>transient Object[] elementData  &#x2F;&#x2F; transient表示瞬间短暂，表示该属性不会被序号号</li><li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加则扩容elementData为10，如果再次扩容，则扩容1.5倍</li><li>如果使用指定大小的构造器，则初始容量为指定大小，如扩容，扩1.5倍</li></ol></li></ol><h2 id="14-6-Vector-低层结构和源码分析"><a href="#14-6-Vector-低层结构和源码分析" class="headerlink" title="14.6 Vector 低层结构和源码分析"></a>14.6 Vector 低层结构和源码分析</h2><ol><li>Vector 底层也是一个对象数组，protected Object[] elementData;</li><li>Vector 是线程同步的，即线程安全的，操作方法带 synchronized</li><li>扩容<ol><li>无参构造，默认10，按2倍扩容</li><li>有参指定大小，2倍扩容</li></ol></li></ol><h2 id="14-7-LinkedList-低层结构和源码分析"><a href="#14-7-LinkedList-低层结构和源码分析" class="headerlink" title="14.7 LinkedList 低层结构和源码分析"></a>14.7 LinkedList 低层结构和源码分析</h2><ol><li>LinkedList底层实现了双向链表和双端队列特点</li><li>可以添加任意元素，重复元素，包括null</li><li>线程不安全，没有实现同步</li><li>底层操作机制<ol><li>LinkedList底层维护了一个双向链表</li><li>两个属性 first和last 分别指向首节点和尾结点</li><li>每个节点，里面又维护了 prev、next、item 三个属性</li></ol></li></ol><h2 id="14-8-ArrayList-和-LinkedList-比较"><a href="#14-8-ArrayList-和-LinkedList-比较" class="headerlink" title="14.8 ArrayList 和 LinkedList 比较"></a>14.8 ArrayList 和 LinkedList 比较</h2><ol><li>如果改查操作多，选择Arraylist</li><li>如果增删操作多，选择linkedList</li></ol><h2 id="14-9-Set接口和常用方法"><a href="#14-9-Set接口和常用方法" class="headerlink" title="14.9 Set接口和常用方法"></a>14.9 Set接口和常用方法</h2><ol><li>无序、没有索引</li><li>不允许重复元素，最多包含一个null</li><li>遍历方式<ol><li>迭代器</li><li>增强for</li><li>不能索引获取</li></ol></li></ol><h2 id="14-10-HashSet"><a href="#14-10-HashSet" class="headerlink" title="14.10 HashSet"></a>14.10 HashSet</h2><ol><li>HashSet实际上是HashMap</li><li>不能加入相同元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">set.add(<span class="hljs-string">&quot;lucy&quot;</span>);<span class="hljs-comment">//添加成功</span><br>set.add(<span class="hljs-string">&quot;lucy&quot;</span>);<span class="hljs-comment">//加入不了</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;tom&quot;</span>));<span class="hljs-comment">//OK</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;tom&quot;</span>));<span class="hljs-comment">//Ok</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hsp&quot;</span>));<span class="hljs-comment">//ok</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hsp&quot;</span>));<span class="hljs-comment">//加入不了.</span><br></code></pre></td></tr></table></figure></li><li>HashSet低层是HashMap，HashMap底层是数组+链表+红黑树<ol><li>添加一个元素时，先得到hash值，转换成 索引值</li><li>找到存储数据表 table，看这个索引位置是否已经存放元素</li><li>如果没有，直接加入</li><li>如果有，调用equals比较，如果相同，放弃添加，如果不同则添加到最后</li><li>java8后，如果一条链表的元素个数达到 TREEIFY_THREASHOLD 默认8，并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY 默认64，就会转换成红黑树，否则采用数组扩容机制</li></ol></li></ol><h2 id="14-11-LinkedHashSet"><a href="#14-11-LinkedHashSet" class="headerlink" title="14.11 LinkedHashSet"></a>14.11 LinkedHashSet</h2><ol><li>LinkedHashSet是HashSet子类</li><li>LinkedHashSet底层是LinkedHashMap，底层维护了一个 数组+双向链表</li><li>LinkedHashSet根据元素的 hashCode 值来决定元素的存储位置，同时用链表维护元素的次序，使得元素看起来是以插入顺序保存的</li><li>LinkedHashSet 不允许添加重复元素</li><li>说明<ol><li>每个节点都有before和after属性，这样可以形成双向链表</li><li>在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链表，如果已经存在则不添加</li></ol></li></ol><h2 id="14-12-Map-接口和常用方法"><a href="#14-12-Map-接口和常用方法" class="headerlink" title="14.12 Map 接口和常用方法"></a>14.12 Map 接口和常用方法</h2><ol><li>Map和Collection并列存在，用于保存具有映射关系的数据：key-value</li><li>key和value可以是任意引用类型的数据</li><li>key可以为null仅限一个，value也可以为null可以多个</li><li>一对k-v是放在 HashMap&amp;Node中，又因为Node实现了Entry接口，所以有些书也会说一对k-v就是一个Entry</li><li>Map接口遍历方法<ol><li>cotainsKey：查找键是否存在</li><li>keySet：获取所有的键 <code>Set keyset = map.keySet();</code></li><li>entrySet：获取所有关系 k-v </li><li>values：获取所有的值 <code>Collection values = map.values();</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Set</span> <span class="hljs-variable">entrySet</span> <span class="hljs-operator">=</span> map.entrySet();<span class="hljs-comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span><br><span class="hljs-comment">//(1) 增强 for</span><br><span class="hljs-keyword">for</span> (Object entry : entrySet) &#123;<br><span class="hljs-comment">//将 entry 转成 Map.Entry</span><br>Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Map.Entry) entry;<br>System.out.println(m.getKey() + <span class="hljs-string">&quot;-&quot;</span> + m.getValue());<br>&#125;<br><span class="hljs-comment">//(2) 迭代器</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator3</span> <span class="hljs-operator">=</span> entrySet.iterator();<br><span class="hljs-keyword">while</span> (iterator3.hasNext()) &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> iterator3.next();<br><span class="hljs-comment">//System.out.println(next.getClass());</span><br><span class="hljs-comment">//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span><br><span class="hljs-comment">//向下转型 Map.Entry</span><br>Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Map.Entry) entry;<br>System.out.println(m.getKey() + <span class="hljs-string">&quot;-&quot;</span> + m.getValue());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="14-13-HashMap"><a href="#14-13-HashMap" class="headerlink" title="14.13 HashMap"></a>14.13 HashMap</h2><ol><li>Map接口的常用实现类：HashMap，Hashtable、Properties</li><li>HashMap 是Map接口使用率最高的实现类</li><li>HashMap 以 key-val 对的方式存储数据</li><li>key不能重复，如果添加相同的key，会覆盖原来的key-val</li><li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式存储</li><li>HashMap 没有实现同步，因此线程不安全，没有 synchronized</li><li>扩容机制，同HashSet<ol><li>HashMap底层维护了Node类型的数组 table，默认为null</li><li>创建对象时，加载因子 loadfactor 初始化为0.75</li><li>当添加key-val 时，通过key的哈希值得到在table的索引，然后判断该索引处是否有元素，如果没有元素直接添加。如果索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，直接替换val，如果不相等需要判断是树结构还是链表结构，做出相应处理。如果容量不够，需要扩容。</li><li>第一次添加，需要扩容table容量为16， 临界值 为12 </li><li>再扩容，需要扩容table容量为原来的两倍</li></ol></li></ol><h2 id="14-14-HashTable"><a href="#14-14-HashTable" class="headerlink" title="14.14 HashTable"></a>14.14 HashTable</h2><ol><li>hashtable的key、value都不能为null，否则抛异常</li><li>hashtable的使用方法和HashMap一样</li><li>hashtable底层是线程安全的，效率较低</li></ol><h2 id="14-15-Properties"><a href="#14-15-Properties" class="headerlink" title="14.15 Properties"></a>14.15 Properties</h2><ol><li>Properties类继承了Hashtable类，并实现了Map接口</li><li>Properties 还可以用于 从xx.properties 文件中，加载数据到Properties类对象，并进行读取和修改</li><li>xx.properties文件通常作为配置文件</li></ol><h2 id="14-16-开发中如何选择集合实现类"><a href="#14-16-开发中如何选择集合实现类" class="headerlink" title="14.16 开发中如何选择集合实现类"></a>14.16 开发中如何选择集合实现类</h2><ol><li>判断存储类型，是一组对象还是一组键值对</li><li>一组对象：Collection<ol><li>允许重复：List<ol><li>增删多：LinkedList</li><li>改查多：Arraylist</li></ol></li><li>不允许重复<ol><li>无序：HashSet</li><li>排序：TreeSet</li><li>插入和取出顺一致：LinkedHashSet</li></ol></li></ol></li><li>一组键值对<ol><li>键无序：HashMap</li><li>键排序：TreeMap</li><li>键插入和取出顺序一致：LinkedHashMap</li><li>读取文件：Properties</li></ol></li></ol><h2 id="14-17-Collections-工具类"><a href="#14-17-Collections-工具类" class="headerlink" title="14.17 Collections 工具类"></a>14.17 Collections 工具类</h2><ol><li>排序操作，均为static方法<ol><li>reverse(List)</li><li>shuffle(List)</li><li>sort(List)</li><li>sort(List, Comparator)</li><li>swap(List, int, int)</li></ol></li><li>查找替换<ol><li>Object max(Collection)</li><li>Object max(Collection, Comparator) 根据指定顺序返回给定集合的最大值</li><li>Object min(Collection)</li><li>Object min(Collection, Comparator) </li><li>int frequency(Collection, Object) 返回集合指定元素出现的次数</li><li>void copy(List dest, List src) 将src中的内如复制到dest中</li><li>boolean replaceAll(List list, Object oldVal, Object newVal) 使用新值替换所有的旧值</li></ol></li></ol><h1 id="15-泛型"><a href="#15-泛型" class="headerlink" title="15.泛型"></a>15.泛型</h1><h2 id="15-1-泛型的理解和好处"><a href="#15-1-泛型的理解和好处" class="headerlink" title="15.1 泛型的理解和好处"></a>15.1 泛型的理解和好处</h2><ol><li>传统方法存在的问题<ol><li>不能对加入到集合的数据类型进行约束</li><li>遍历的时候，需要进行类型转换，如果集合中的数据量较大，效率低</li></ol></li><li>泛型 <code>ArrayList&lt;Dog&gt; arr = new ArrayList&lt;Dog&gt;()</code></li><li>泛型的好处<ol><li>编译时，检查添加元素的类型，提高安全性</li><li>减少类型转换次数，提高效率<ol><li>不使用泛型：Dog -&gt; 加入 -&gt; Object -&gt; 取出 -&gt; Dog</li><li>使用泛型：Dog -&gt; Dog -&gt; Dog</li></ol></li><li>不再提示编译警告</li></ol></li></ol><h2 id="15-3-泛型介绍"><a href="#15-3-泛型介绍" class="headerlink" title="15.3 泛型介绍"></a>15.3 泛型介绍</h2><ol><li>泛型 &#x3D;&gt; Integer、String、Dog…</li><li>泛型又称为参数化类型，解决数据类型的安全性问题</li><li>在类声明或实例化时只要指定好需要的类型就好</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生classcastexception异常</li><li>泛型的作用：<ol><li>可以在类声明时通过一个标识表示类中某个属性的类型</li><li>某个方法的返回值的类型</li><li>参数类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型</span><br>Person&lt;String&gt; person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;String&gt;(<span class="hljs-string">&quot;韩顺平教育&quot;</span>);<br><span class="hljs-comment">// 泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，</span><br><span class="hljs-comment">// 或者是某个方法的返回值的类型，或者是参数类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;E&gt; &#123;<br>E s ;<span class="hljs-comment">//E 表示 s 的数据类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(E s)</span> &#123;<span class="hljs-comment">//E 也可以是参数类型</span><br><span class="hljs-built_in">this</span>.s = s;<br>&#125;<br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回类型使用 E</span><br><span class="hljs-keyword">return</span> s;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="15-4-泛型的语法"><a href="#15-4-泛型的语法" class="headerlink" title="15.4 泛型的语法"></a>15.4 泛型的语法</h2><h3 id="15-4-1-泛型的声明"><a href="#15-4-1-泛型的声明" class="headerlink" title="15.4.1 泛型的声明"></a>15.4.1 泛型的声明</h3><ol><li>interface 接口 &lt;T&gt;{} 和 clss 类 &lt;K,V&gt;{}<ol><li>其中，TKV不代表值，代表类型</li><li>任意字母都可以</li></ol></li></ol><h3 id="15-4-2-泛型的实例化"><a href="#15-4-2-泛型的实例化" class="headerlink" title="15.4.2 泛型的实例化"></a>15.4.2 泛型的实例化</h3><ol><li>在类名后指定类型参数的类型<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">List&lt;Customer&gt; iterator <span class="hljs-operator">=</span> customer.iteratr()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="15-4-4-注意事项和细节"><a href="#15-4-4-注意事项和细节" class="headerlink" title="15.4.4 注意事项和细节"></a>15.4.4 注意事项和细节</h3><ol><li>T K V都必须是引用类型，不能是基本数据类型</li><li>给泛型指定具体类型后 ，可以传入该类型或其子类类型</li><li>泛型的使用形式：<ol><li><code>List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;()</code></li><li><code>List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;()</code> 推荐，编译器会进行类型推断</li></ol></li><li>如果 <code>List list3 = new ArrayList()</code> 默认给它的泛型是Object</li></ol><h2 id="15-6-自定义泛型"><a href="#15-6-自定义泛型" class="headerlink" title="15.6 自定义泛型"></a>15.6 自定义泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 &lt;T,R,V...&gt;&#123;<br>成员<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>&lt;T, R, M&gt;&#123;<br>String name;<br>T s;<br>R m;<br><span class="hljs-keyword">public</span> M <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br><span class="hljs-comment">//因为数组在 new 不能确定 T 的类型，就无法在内存开空间</span><br>T[] ts; <span class="hljs-comment">// ok</span><br>T[] ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// no</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>细节：<ol><li>普通成员可以使用泛型，比如属性、方法</li><li>使用泛型的数组不能初始化</li><li>静态方法中不能使用类的泛型，静态是和类相关的，在类加载时，对象还没创建</li><li>泛型类的类型是在创建对象时确定的，因为创建对象时，需要指定确定类型</li><li>如果在创建对象时，没有指定类型，默认为Object</li></ol></li><li>自定义泛型接口<ol><li>语法 <code>interface 接口名 &lt;T,R,M...&gt;&#123;&#125;</code></li><li>接口中，静态成员不能使用泛型</li><li>泛型接口的类型，在继承接口或者实现接口时确定</li><li>没有指定类型默认为Object<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUsb</span>&lt;U, R&gt; &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//U name; 不能这样使用</span><br><span class="hljs-comment">//普通方法中，可以使用接口泛型</span><br>R <span class="hljs-title function_">get</span><span class="hljs-params">(U u)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(R r)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(R r1, R r2, U u1, U u2)</span>;<br><span class="hljs-comment">//在 jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型</span><br><span class="hljs-keyword">default</span> R <span class="hljs-title function_">method</span><span class="hljs-params">(U u)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//在继承接口 指定泛型接口的类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IUsb</span>&lt;String, Double&gt; &#123;<br><br>&#125;<br><span class="hljs-comment">//当我们去实现 IA 接口时，因为 IA 在继承 IUsu 接口时，指定了 U 为 String R 为 Double</span><br><span class="hljs-comment">//，在实现 IUsu 接口的方法时，使用 String 替换 U, 是 Double 替换 R</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Double <span class="hljs-title function_">get</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(Double aDouble)</span> &#123;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Double r1, Double r2, String u1, String u2)</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>自定义泛型方法<ol><li>泛型方法可以定义在普通类中，也可以定义在泛型类中</li><li>当泛型方法被调用时，类型会确定</li><li><code>public void eat(E e)&#123;&#125;</code> 修饰符后没有&lt;T,R…&gt; eat，方法不是泛型方法而是使用了泛型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>&lt;T, R, M&gt; &#123;<span class="hljs-comment">//自定义泛型类</span><br><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">(E e)</span> &#123; <span class="hljs-comment">//泛型方法</span><br>System.out.println(e.getClass().getSimpleName());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(U u)</span> &#123;&#125;<span class="hljs-comment">//错误，因为 U 没有声明</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(M m)</span> &#123;<br>&#125; <span class="hljs-comment">//ok</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="15-7-泛型的继承和通配符"><a href="#15-7-泛型的继承和通配符" class="headerlink" title="15.7 泛型的继承和通配符"></a>15.7 泛型的继承和通配符</h2><ol><li>泛型不具备继承性<ol><li><code>List&lt;Object&gt; list = new ArrayList&lt;String&gt;()</code> 错</li></ol></li><li>&lt;?&gt;: 支持任意泛型类型</li><li>&lt;? extends A&gt; 支持A类及A的子类，规定了泛型的上限</li><li>&lt;? super A&gt; 支持A类及A的父类，不限于直接父类，规定了泛型的下限<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ? extends AA 表示 上限，可以接受 AA 或者 AA 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection2</span><span class="hljs-params">(List&lt;? extends AA&gt; c)</span> &#123;<br><span class="hljs-keyword">for</span> (Object object : c) &#123;<br>System.out.println(object);<br>&#125;<br>&#125;<br><span class="hljs-comment">//说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection1</span><span class="hljs-params">(List&lt;?&gt; c)</span> &#123;<br><span class="hljs-keyword">for</span> (Object object : c) &#123; <span class="hljs-comment">// 通配符，取出时，就是 Object</span><br>System.out.println(object);<br>&#125;<br>&#125;<br><span class="hljs-comment">// ? super 子类类名 AA:支持 AA 类以及 AA 类的父类，不限于直接父类，</span><br><span class="hljs-comment">//规定了泛型的下限</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection3</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> AA&gt; c)</span> &#123;<br><span class="hljs-keyword">for</span> (Object object : c) &#123;<br>System.out.println(object);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="15-9-JUnit"><a href="#15-9-JUnit" class="headerlink" title="15.9 JUnit"></a>15.9 JUnit</h2><ol><li>一个类有很多功能代码需要测试，为了测试就需要写入到main方法中</li><li>如果有多个功能代码测试，需要来回注销，切换麻烦</li><li>如果可以直接运行一个方法就方便很多，并且可以给出相关信息</li><li>JUnit是一个java的单元测试框架</li><li>@Test注解</li></ol><h1 id="17-多线程"><a href="#17-多线程" class="headerlink" title="17. 多线程"></a>17. 多线程</h1><h2 id="17-1-线程"><a href="#17-1-线程" class="headerlink" title="17.1 线程"></a>17.1 线程</h2><ol><li>进程是运行中的程序，比如QQ，操作系统会为该进程分配内存空间</li><li>进程是程序的一次执行过程，或是正在运行的一个程序，是动态过程：有自身的产生、存在和消亡的过程</li><li>什么是线程<ol><li>线程由进程创建，是进程的一个实体</li><li>一个进程可以拥有多个线程</li></ol></li><li>其他概念<ol><li>单线程：同一个时刻，只允许执行一个线程</li><li>多线程：同一个时刻，可以执行多个线程</li><li>并发：同一个时刻，多个任务交替执行，造成貌似同时的错觉，单核CPU实现多任务就是并发</li><li>并行：同一个时刻，多个任务同时执行，多核CPU可以实现并行</li></ol></li></ol><h2 id="17-2-线程基本使用"><a href="#17-2-线程基本使用" class="headerlink" title="17.2 线程基本使用"></a>17.2 线程基本使用</h2><ol><li>创建线程的两种方式<ol><li>继承Thread类，重写run方法</li><li>实现Runable接口，重写run方法</li></ol></li><li>start()方法调用start0后，该线程不一定会立马执行，只是将线程变成了可运行状态，具体什么时候执行，取决于CPU，由CPU统一调用</li><li>jconsole 监测线程</li></ol><h2 id="17-3-继承Thread和实现Runable的区别"><a href="#17-3-继承Thread和实现Runable的区别" class="headerlink" title="17.3 继承Thread和实现Runable的区别"></a>17.3 继承Thread和实现Runable的区别</h2><ol><li>继承Thread和实现Runable接口来创建线程本质上没有区别</li><li>实现Runable接口的方式更适合多个线程共享一个资源的情况，并且避免了单继承的限制</li></ol><h2 id="17-4-线程终止"><a href="#17-4-线程终止" class="headerlink" title="17.4 线程终止"></a>17.4 线程终止</h2><ol><li>当线程完成任务后，会自动退出</li><li>通过使用变量控制run方法退出的方式停止线程，即通知方式</li></ol><h2 id="17-5-线程常用方法"><a href="#17-5-线程常用方法" class="headerlink" title="17.5 线程常用方法"></a>17.5 线程常用方法</h2><ol><li>常用方法<ol><li>setName  设置线程名称</li><li>getName  返回该线程的名称</li><li>start  开始执行线程</li><li>run  调用线程对象的run方法</li><li>setPriority  更改线程的优先级</li><li>getPriority  获取线程的优先级</li><li>sleep  休眠</li><li>interrupt  中断线程</li></ol></li><li>注意事项和细节<ol><li>start 底层会创建新的线程，调用run </li><li>线程优先级的范围<ol><li>MAX_PRIORITY 10</li><li>NORMAL_PRIORITY 5</li><li>MIN_PRIORITY 1</li></ol></li><li>interrupt 中断线程，并没有真正的结束线程，一般用于中断正在休眠休眠线程</li><li>sleep  线程的静态方法</li></ol></li><li>常用方法2<ol><li>yield：线程的礼让，让出CPU，让其他线程执行，但是礼让的时间不确定，所以不一定礼让成功</li><li>join：线程的插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有任务</li></ol></li><li>用户线程和守护线程<ol><li>用户线程：也叫工作线程，当线程的任务执行完或通知方式结束</li><li>守护线程：一般为工作线程服务，当所有的用户线程结束，守护线程自动结束</li><li>常见的守护线程：垃圾回收机制</li></ol></li></ol><h2 id="17-6-线程的生命周期"><a href="#17-6-线程的生命周期" class="headerlink" title="17.6 线程的生命周期"></a>17.6 线程的生命周期</h2><ol><li>JDK中用Thread.State枚举表示线程的状态<ol><li>NEW  尚未启动的线程</li><li>RUNNABLE  在java虚拟机中执行的线程<ol><li>READY</li><li>RUNNING</li></ol></li><li>BLOCKED  被阻塞等待监视器锁定的线程</li><li>WAITING  正在等待另一个线程执行特定动作的线程</li><li>TIMED_WAITING  正在等待另一个线程执行动作达到特定等待时间的线程</li><li>TERMINATED  已退出的线程<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240414182952.png" alt="image.png"></li></ol></li></ol><h2 id="17-7-线程的同步"><a href="#17-7-线程的同步" class="headerlink" title="17.7 线程的同步"></a>17.7 线程的同步</h2><ol><li>Synchronized<ol><li>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻最多有一个线程访问，以保证数据的完整性</li><li>线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址机械能操作</li></ol></li><li>操作具体方法<ol><li>同步代码块  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<span class="hljs-comment">// 得到对象的锁，才能操作同步代码</span><br><span class="hljs-comment">// 需要被同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>synchronized 放在方法声明中，表示整个方法-为同步方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(String name)</span>&#123;<br><span class="hljs-comment">// 需要被同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="17-10-互斥锁"><a href="#17-10-互斥锁" class="headerlink" title="17.10 互斥锁"></a>17.10 互斥锁</h2><ol><li>java中，引入对象互斥锁来保证共享数据操作的完整性</li><li>每个对象都对应一个互斥锁的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</li><li>关键字synchronized来与对象的互斥锁联系，当某对象用synchronized修饰时，标明该对象在任一时刻只能由一个线程访问</li><li>同步的局限性：导致程序的执行效率降低</li><li>同步方法（非静态）的锁可以是this，也可以是其他对象</li><li>同步方法（静态）的锁为当前类本身 <code>synchronized (SellTicket03.class)</code></li><li>注意事项<ol><li>同步方法如果没有使用static修饰，默认锁对象为this</li><li>如果方法使用static修饰，默认锁对象为当前类.class</li><li>实现的落地步骤<ol><li>分析需要上锁的代码</li><li>选择同步代码块或同步方法</li><li>要求多个线程的锁对象为同一个即可</li></ol></li></ol></li></ol><h2 id="17-11-死锁"><a href="#17-11-死锁" class="headerlink" title="17.11 死锁"></a>17.11 死锁</h2><ol><li>多个线程都占用了对方的锁资源，但是不肯想让，导致了死锁</li></ol><h2 id="17-12-释放锁"><a href="#17-12-释放锁" class="headerlink" title="17.12 释放锁"></a>17.12 释放锁</h2><ol><li>释放锁的操作<ol><li>当前线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块、同步方法中遇到break、return</li><li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li><li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li></ol></li><li>不会释放锁的操作<ol><li>线程执行同步代码块或同步方法时，程序调用Thread.sleep() Thread.yeild()方法，暂停当前线程的执行，不会释放锁</li><li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁</li></ol></li></ol><h1 id="19-IO流"><a href="#19-IO流" class="headerlink" title="19.IO流"></a>19.IO流</h1><h2 id="19-1-文件"><a href="#19-1-文件" class="headerlink" title="19.1 文件"></a>19.1 文件</h2><ol><li>文件在程序中是以流的形式来操作的<ol><li>流：数据在数据源（文件）和程序（内存）之间经历的路径</li><li>输入流：数据从数据源到程序的路径</li><li>输出流：数据从程序到数据源的路径</li></ol></li><li>常见的文件操作<ol><li>创建文件对象相关构造器和方法<ol><li>new File(String pathName) 根据路径构建file对象</li><li>new File(File parent, String child) 根据父目录文件+子路径构建</li><li>new File(String parent, String child) 根据父目录+子路径构建</li></ol></li></ol></li><li>获取文件相关信息<ol><li>getName</li><li>getAbsolutePath</li><li>getParent</li><li>Length</li><li>exists</li><li>isFile 是文件还是目录</li><li>isDirectory</li></ol></li><li>目录的操作和文件的删除<ol><li>mkdir 创建一级目录</li><li>mkdirs 创建多级目录</li><li>delete 删除空目录或文件</li></ol></li></ol><h2 id="19-3-IO流原理及流的分类"><a href="#19-3-IO流原理及流的分类" class="headerlink" title="19.3 IO流原理及流的分类"></a>19.3 IO流原理及流的分类</h2><ol><li>Java IO流原理<ol><li>java程序中，对于数据的输入输出操作是以流的方式进行</li><li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据</li><li>输入input</li><li>输出output</li></ol></li><li>流的分类<ol><li>按操作数据单位不同<ol><li>字节流（8 bit）二进制文件，字符流（按字符）文本文件</li><li>字节流 InputStream  OutputStream</li><li>字符流 Reader  Writer</li><li>IO流都是从以上4个抽象基类派生的</li></ol></li><li>按数据流的流向不同<ol><li>输入流，输出流</li></ol></li><li>按流的角色不同<ol><li>节点流、处理流&#x2F;包装流</li></ol></li></ol></li></ol><h2 id="19-4-IO流体系图"><a href="#19-4-IO流体系图" class="headerlink" title="19.4 IO流体系图"></a>19.4 IO流体系图</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240414195601.png" alt="image.png"></p><h3 id="19-4-1-FileInputStream"><a href="#19-4-1-FileInputStream" class="headerlink" title="19.4.1 FileInputStream"></a>19.4.1 FileInputStream</h3><ol><li>单个字节的读取，效率比较低</li></ol><h3 id="19-4-5-FileOutputStream"><a href="#19-4-5-FileOutputStream" class="headerlink" title="19.4.5 FileOutputStream"></a>19.4.5 FileOutputStream</h3><ol><li>new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容</li><li>new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面</li><li>write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流</li></ol><h3 id="19-4-6-FileReader和FileWriter"><a href="#19-4-6-FileReader和FileWriter" class="headerlink" title="19.4.6 FileReader和FileWriter"></a>19.4.6 FileReader和FileWriter</h3><ol><li>FileReader相关方法<ol><li>new FileReader(File&#x2F;String)</li><li>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</li><li>read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li><li>相关API<ol><li>new String(char[])：将char[]转换为String</li><li>new String(char[], off, len)：将char[]的指定部分转换成String</li></ol></li></ol></li><li>FileWriter相关方法<ol><li>new FileWriter(File&#x2F;String) ：覆盖模式，相当于流的指针在首段</li><li>new FileWriter(File&#x2F;String, true)：追加模式，相当于流的指针在尾端</li><li>write(int)：写入单个字符</li><li>write(char[])：写入指定数组</li><li>write(char[], off, len)：写入指定数组的指定部分</li><li>write(String)：写入整个字符串</li><li>write(String, off, len)：写入指定字符串的指定部分</li><li>相关API<ol><li>toCharArray</li></ol></li><li>注意<ol><li>FileWriter使用后必须close或者flush，否则写入不到指定的文件</li></ol></li></ol></li></ol><h2 id="19-5-节点流和处理流"><a href="#19-5-节点流和处理流" class="headerlink" title="19.5 节点流和处理流"></a>19.5 节点流和处理流</h2><ol><li>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter</li><li>处理类也叫包装流，是连接在已经存在的流（节点流、处理流）之上，为程序提供更强大的读写功能，也更灵活，如BufferedReader、BufferedWriter</li><li><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415093850.png" alt="image.png"></li><li>节点流和处理流的区别和联系<ol><li>节点流是低层流&#x2F;低级流，直接跟数据源相接</li><li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li><li>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li></ol></li><li>处理流的功能<ol><li>性能的提高：主要以增加缓冲的方式提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷方法来一次输入输出大批量的数据，使用更加灵活方便</li></ol></li></ol><h3 id="19-5-5-BufferedReader、BufferedWriter"><a href="#19-5-5-BufferedReader、BufferedWriter" class="headerlink" title="19.5.5 BufferedReader、BufferedWriter"></a>19.5.5 BufferedReader、BufferedWriter</h3><ol><li>BufferedReader、BufferedWriter属于字符流，按照字符来读取数据</li><li>关闭时处理流只需要关闭外层流即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建 bufferedReader</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath));<br><span class="hljs-comment">//读取</span><br>String line; <span class="hljs-comment">//按行读取, 效率高</span><br><span class="hljs-comment">//说明</span><br><span class="hljs-comment">//1. bufferedReader.readLine() 是按行读取文件</span><br><span class="hljs-comment">//2. 当返回 null 时，表示文件读取完毕</span><br><span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>System.out.println(line);<br>&#125;<br><span class="hljs-comment">//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流</span><br>bufferedReader.close();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePath));<br>bufferedWriter.write(<span class="hljs-string">&quot;hello, 韩顺平教育!&quot;</span>);<br>bufferedWriter.newLine();<span class="hljs-comment">//插入一个和系统相关的换行</span><br>bufferedWriter.write(<span class="hljs-string">&quot;hello2, 韩顺平教育!&quot;</span>);<br>bufferedWriter.newLine();<br><span class="hljs-comment">//说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭</span><br>bufferedWriter.close();<br></code></pre></td></tr></table></figure></li><li>BufferedReader 和 BufferedWriter 是安装字符操作，不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏</li></ol><h3 id="19-5-6-处理流-BufferedInputStream-和-BufferedOutputStream"><a href="#19-5-6-处理流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="19.5.6 处理流-BufferedInputStream 和 BufferedOutputStream"></a>19.5.6 处理流-BufferedInputStream 和 BufferedOutputStream</h3><ol><li>BufferedOutputStream是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统，字节流可以操作二进制文件</li></ol><h3 id="19-5-8-对象流-ObjectInputStream-和-ObjectOutputStream"><a href="#19-5-8-对象流-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="19.5.8 对象流-ObjectInputStream 和 ObjectOutputStream"></a>19.5.8 对象流-ObjectInputStream 和 ObjectOutputStream</h3><ol><li>序列化：保存数据时，保存数据的值和数据类型，比如 int 100，Dog dog &#x3D; new Dog(“小黄”)</li><li>反序列化：恢复数据时，恢复数据的值和数据类型</li><li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现两个接口之一<ol><li>Serializable  标记接口，没有方法</li><li>Externalizable 该接口有方法需要实现，因此一般实现上面的 Serializable接口</li></ol></li><li>ObjectOutputStream 提供 序列化功能</li><li>ObjectInputStream 提供 反序列化功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\data.dat&quot;</span>;<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br><span class="hljs-comment">//序列化数据到 e:\data.dat</span><br>oos.writeInt(<span class="hljs-number">100</span>);<span class="hljs-comment">// int -&gt; Integer (实现了 Serializable)</span><br>oos.writeBoolean(<span class="hljs-literal">true</span>);<span class="hljs-comment">// boolean -&gt; Boolean (实现了 Serializable)</span><br>oos.writeChar(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">// char -&gt; Character (实现了 Serializable)</span><br>oos.writeDouble(<span class="hljs-number">9.5</span>);<span class="hljs-comment">// double -&gt; Double (实现了 Serializable)</span><br>oos.writeUTF(<span class="hljs-string">&quot;韩顺平教育&quot;</span>);<span class="hljs-comment">//String</span><br><span class="hljs-comment">//保存一个 dog 对象</span><br>oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;日本&quot;</span>, <span class="hljs-string">&quot;白色&quot;</span>));<br>oos.close();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建流对象</span><br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\data.dat&quot;</span>));<br><span class="hljs-comment">// 2.读取， 注意顺序</span><br>System.out.println(ois.readInt());<br>System.out.println(ois.readBoolean());<br>System.out.println(ois.readChar());<br>System.out.println(ois.readDouble());<br>System.out.println(ois.readUTF());<br>System.out.println(ois.readObject());<br><span class="hljs-comment">// 3.关闭</span><br>ois.close();<br></code></pre></td></tr></table></figure></li><li>注意事项<ol><li>读写顺序要一致</li><li>要求序列化或反序列化对象，需要实现Serializable</li><li>序列化的类中建议添加SerialVersionID，提高版本兼容性</li><li>序列化对象时，默认将里面所有属性都进行序列化，除了static或transient修饰的成员</li><li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li><li>序列化具有可继承性，如果某类已经实现了序列化，则它的子类也默认实现了序列化</li></ol></li></ol><h3 id="19-5-10-标准输入输出流"><a href="#19-5-10-标准输入输出流" class="headerlink" title="19.5.10 标准输入输出流"></a>19.5.10 标准输入输出流</h3><ol><li>System.in 标准输入</li><li>System.out 标准输出</li></ol><h3 id="19-5-11-转换流-InputStreamReader-和-OutputStreamWriter"><a href="#19-5-11-转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="19.5.11 转换流-InputStreamReader 和 OutputStreamWriter"></a>19.5.11 转换流-InputStreamReader 和 OutputStreamWriter</h3><ol><li>当处理纯文本数据时，使用字符流效率更高，并且可以有效解决中文问题，使用建议将字节流转换成字符流<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\a.txt&quot;</span>;<br><span class="hljs-comment">//1. 把 FileInputStream 转成 InputStreamReader</span><br><span class="hljs-comment">//2. 指定编码 gbk</span><br><span class="hljs-comment">//3. 把 InputStreamReader 传入 BufferedReader</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath), <span class="hljs-string">&quot;gbk&quot;</span>));<br><span class="hljs-comment">//4. 读取</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> br.readLine();<br>System.out.println(<span class="hljs-string">&quot;读取内容=&quot;</span> + s);<br><span class="hljs-comment">//5. 关闭外层流</span><br>br.close();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建流对象</span><br><span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;d:\\a.txt&quot;</span>), <span class="hljs-string">&quot;gbk&quot;</span>);<br><span class="hljs-comment">// 2.写入</span><br>osw.write(<span class="hljs-string">&quot;hello,韩顺平教育~&quot;</span>);<br><span class="hljs-comment">// 3.关闭</span><br>osw.close();<br></code></pre></td></tr></table></figure></li></ol><h2 id="19-6-打印流-PrintStream-和-PrintWriter"><a href="#19-6-打印流-PrintStream-和-PrintWriter" class="headerlink" title="19.6 打印流 PrintStream 和 PrintWriter"></a>19.6 打印流 PrintStream 和 PrintWriter</h2><h2 id="19-7-Properties-类"><a href="#19-7-Properties-类" class="headerlink" title="19.7 Properties 类"></a>19.7 Properties 类</h2><ol><li>专门用于读写配置文件的集合类<ol><li>配置文件的格式<ol><li>键&#x3D;值</li></ol></li></ol></li><li>键值对不需要有空格，值不需要用引号，默认类型就是String</li><li>常见方法<ol><li>load：加载配置文件的键值对到Properties对象</li><li>list：将数据显示到指定设备</li><li>getProperty(key)：根据键获取值</li><li>setProperty(key, value)：设置键值对到Properties对象</li><li>store：将Properties中的键值对存储到配置文件中，如果含有中文，会存储为Unicode码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用 Properties 类来读取 mysql.properties 文件</span><br><span class="hljs-comment">//1. 创建 Properties 对象</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><span class="hljs-comment">//2. 加载指定配置文件</span><br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;src\\mysql.properties&quot;</span>));<br><span class="hljs-comment">//3. 把 k-v 显示控制台</span><br>properties.list(System.out);<br><span class="hljs-comment">//4. 根据 key 获取对应的值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用 Properties 类来创建 配置文件, 修改配置文件内容</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><span class="hljs-comment">//1.如果该文件没有 key 就是创建</span><br><span class="hljs-comment">//2.如果该文件有 key ,就是修改</span><br>properties.setProperty(<span class="hljs-string">&quot;charset&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>);<br>properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;src\\mysql2.properties&quot;</span>), <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="21-网络编程"><a href="#21-网络编程" class="headerlink" title="21.网络编程"></a>21.网络编程</h1><h2 id="21-1-网络的相关概念"><a href="#21-1-网络的相关概念" class="headerlink" title="21.1 网络的相关概念"></a>21.1 网络的相关概念</h2><ol><li>网络通信：两台设备之间通过网络实现数据传输</li><li>java.net包下提供了一系列的类和接口，完成网络通信</li><li>ip地址：唯一标识网络中的每台计算机&#x2F;主机</li><li>查看ip地址：ipconfig</li><li>ip地址组成：网络地址+主机地址<ol><li>A:0-127</li><li>B:128-191</li><li>C:192-223</li><li>D:224-239</li><li>E:240-247</li><li>127.0.0.1表示本机地址</li></ol></li><li>端口号：用于标识计算机上某个特定的网络程序<ol><li>0-65535</li><li>0-1024已经被占用，ssh 22、ftp 21、smtp 25、HTTP 80</li><li>tomcat 8080、mysql 3306、oracle 1521、sqlserver 1433</li></ol></li></ol><h3 id="21-1-6-网络通信协议"><a href="#21-1-6-网络通信协议" class="headerlink" title="21.1.6 网络通信协议"></a>21.1.6 网络通信协议</h3><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415121042.png" alt="image.png"></p><ol><li>协议 tcp&#x2F;ip，网络通讯协议，是Internet的基础</li><li><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415121154.png" alt="image.png"></li><li>TCP和UDP<ol><li>TCP：传输控制协议<ol><li>使用tcp前，先建立tcp连接形成传输数据通道</li><li>传输前，三次握手，可靠的</li><li>连接中可进行大数据量的传输</li><li>传输完毕，需要释放已经建立的连接，效率低</li></ol></li><li>UDP：用户数据协议<ol><li>将数据、源、目的封装成数据包，不需要建立连接</li><li>每个数据报的大学限制在64k内，不适合传输大量数据</li><li>无需连接，故不可靠</li><li>发送数据结束时无需释放资源，因为不是面向连接的，速度快</li></ol></li></ol></li></ol><h2 id="21-2-InetAddress类"><a href="#21-2-InetAddress类" class="headerlink" title="21.2 InetAddress类"></a>21.2 InetAddress类</h2><ol><li>获取本机InetAddress对象 getlocalHost</li><li>根据指定主机名&#x2F;域名获取ip地址对象 getByName</li><li>获取InetAddress对象的主机名 getHostName</li><li>获取InetAddress对象的地址 getHostAddress</li></ol><h2 id="21-3-Socket"><a href="#21-3-Socket" class="headerlink" title="21.3 Socket"></a>21.3 Socket</h2><ol><li>套接字 Socket</li><li>通信的两端都要有Socket，是两台机器间通信的端点</li><li>网络通信其实就是Socket间的通信</li><li>Socket允许程序把网络连接当做一个流，数据在两个Socket间通过IO传输</li><li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li><li><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415152429.png" alt="image.png"></li></ol><h2 id="21-4-TCP"><a href="#21-4-TCP" class="headerlink" title="21.4 TCP"></a>21.4 TCP</h2><ol><li>基于客户端-服务端的网络通信</li><li>底层使用的是TCP&#x2F;IP协议</li><li>基于Socket的TCP编程</li><li>分为Server和Client端<ol><li>结束标记<ol><li>Socket.shutdown()</li><li>writer.newLine()<ol><li>需要使用readLine()来读取，否则没意义</li></ol></li></ol></li><li>输入输出</li></ol></li><li>案例4<ol><li>客户端<ol><li>将磁盘上的图片读取到字节数组中</li><li>通过socket拿到输出流</li></ol></li><li>服务端<ol><li>接收socket输入流</li><li>读取的文件数据转成某个目录下的图片</li><li>回复信息给客户端</li></ol></li></ol></li><li>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯，这个端口是TCP&#x2F;IP来分配的，是不确定的，随机的</li></ol><h3 id="21-4-6-netstat指令"><a href="#21-4-6-netstat指令" class="headerlink" title="21.4.6 netstat指令"></a>21.4.6 netstat指令</h3><ol><li>netstat -an 查看当前主机网络情况，包括端口监听情况和网络连接情况</li><li>netstat -an | more 分页显示</li><li>netstat -anb 查看哪个程序监听</li></ol><h2 id="21-5-UDP网络编程"><a href="#21-5-UDP网络编程" class="headerlink" title="21.5 UDP网络编程"></a>21.5 UDP网络编程</h2><ol><li>DatagramSocket和DatagramPacket类实现了基于UDP协议网络编程</li><li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能安全到目的地，也不确定什么时候可以抵达</li><li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</li><li>UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接</li><li>基本流程<ol><li>核心的两个类&#x2F;对象</li><li>建立发送端、接收端（没有服务端和客户端概念）</li><li>发送数据前，建立数据报 DatagramPacket对象</li><li>调用DatagramSocket的发送、接收方法</li><li>关闭DatagramSocket</li></ol></li></ol><h1 id="23-反射"><a href="#23-反射" class="headerlink" title="23.反射"></a>23.反射</h1><h2 id="23-1-引入反射"><a href="#23-1-引入反射" class="headerlink" title="23.1 引入反射"></a>23.1 引入反射</h2><ol><li>根据配置文件 re.properties 指定信息，创建Cat对象逼格调用方法hi<ol><li>传统方法：<ol><li>Cat cat &#x3D; new Cat();</li><li>cat.hi();</li></ol></li><li>通过外部文件配置，在不修改源码情况下控制程序，也符合设计模式的OCP原则（开闭原则：不修改源码，扩容功能）</li></ol></li></ol><h2 id="23-2-反射机制"><a href="#23-2-反射机制" class="headerlink" title="23.2 反射机制"></a>23.2 反射机制</h2><h3 id="23-2-1-Java-Reflection"><a href="#23-2-1-Java-Reflection" class="headerlink" title="23.2.1 Java Reflection"></a>23.2.1 Java Reflection</h3><ol><li>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，比如成员变量、构造器、成员方法等，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</li><li>加载完类之后，在堆中就产生了一个Class类型的对象，一个类志愿一个Class对象。这个对象包含了类的完整结构信息，通过这个对象得到类的结构。这个Class对象就像一面镜子，透过这个镜子可以看到类的结构。</li></ol><h3 id="23-2-2-Java反射机制原理图"><a href="#23-2-2-Java反射机制原理图" class="headerlink" title="23.2.2 Java反射机制原理图"></a>23.2.2 Java反射机制原理图</h3><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415201604.png" alt="image.png"></p><ol><li>反射机制可以完成<ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol></li><li>反射相关类<ol><li>java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象</li><li>java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法</li><li>java.lang.reflect.Field：代表类的成员变量<ol><li>getField 不能得到私有的属性</li><li>传统写法 对象.成员变量 , 反射 : 成员变量对象.get(对象)</li></ol></li><li>java.lang.reflect.Constructor：代表类的构造方法</li></ol></li><li>反射优缺点<ol><li>可以动态地创建和使用对象，使用灵活</li><li>缺点：使用反射基本是解释执行，对执行速度有影响</li></ol></li><li>反射调用优化-关闭访问检查<ol><li>Method和Field、Constructor对象都有setAccessible()方法</li><li>setAccessible作用是启动和禁用访问安全检查的开关</li><li>参数值为true表示反射的对象在使用时取消访问检查，提高反射效率，参数值为false则进行访问检查</li></ol></li></ol><h2 id="23-3-Class类"><a href="#23-3-Class类" class="headerlink" title="23.3 Class类"></a>23.3 Class类</h2><ol><li>Class也是类，因此继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class对象可以完整地得到一个类的完整结构，通过一系列API</li><li>Class对象是存放在堆里</li><li>类的字节码二进制数据是放在方法区里，有的地方称为类的元数据（包括方法代码、变量名、方法名、访问权限等）</li><li>Class类常用方法<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416094823.png" alt="image.png"></li></ol><h2 id="23-4-获取-Class-类对象"><a href="#23-4-获取-Class-类对象" class="headerlink" title="23.4 获取 Class 类对象"></a>23.4 获取 Class 类对象</h2><ol><li>在不同阶段有不同的获取方式<ol><li>代码阶段&#x2F;编译阶段：Class.forName</li><li>加载阶段：类.class</li><li>运行阶段：对象.getClass</li><li>直接通过类加载器获取对象<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416110456.png" alt="image.png"><br>   <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416110502.png" alt="image.png"><br>   <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416110508.png" alt="image.png"></li></ol></li></ol><h2 id="23-5-哪些类型有Class对象"><a href="#23-5-哪些类型有Class对象" class="headerlink" title="23.5 哪些类型有Class对象"></a>23.5 哪些类型有Class对象</h2><ol><li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;String&gt; cls1 = String.class;<span class="hljs-comment">//外部类</span><br>Class&lt;Serializable&gt; cls2 = Serializable.class;<span class="hljs-comment">//接口</span><br>Class&lt;Integer[]&gt; cls3 = Integer[].class;<span class="hljs-comment">//数组</span><br>Class&lt;<span class="hljs-type">float</span>[][]&gt; cls4 = <span class="hljs-type">float</span>[][].class;<span class="hljs-comment">//二维数组</span><br>Class&lt;Deprecated&gt; cls5 = Deprecated.class;<span class="hljs-comment">//注解</span><br><span class="hljs-comment">//枚举</span><br>Class&lt;Thread.State&gt; cls6 = Thread.State.class;<br>Class&lt;Long&gt; cls7 = <span class="hljs-type">long</span>.class;<span class="hljs-comment">//基本数据类型</span><br>Class&lt;Void&gt; cls8 = <span class="hljs-keyword">void</span>.class;<span class="hljs-comment">//void 数据类型</span><br>Class&lt;Class&gt; cls9 = Class.class;<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="23-6-类加载"><a href="#23-6-类加载" class="headerlink" title="23.6 类加载"></a>23.6 类加载</h2><ol><li>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载<ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，也不报错，降低依赖性</li></ol></li><li>类加载时机<ol><li>创建对象时（new）&#x2F;&#x2F; 静态加载</li><li>当子类被加载时，父类也被加载 &#x2F;&#x2F; 静态加载</li><li>调用类中的静态成员时 &#x2F;&#x2F; 静态加载</li><li>通过反射 &#x2F;&#x2F; 动态加载</li></ol></li><li>类加载过程图<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416112506.png" alt="image.png"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416112913.png" alt="image.png"></li><li>加载阶段<ol><li>JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件也可能是jar包甚至网络）转化成二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</li></ol></li><li>连接阶段-验证<ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全</li><li>包括<ol><li>文件格式验证：是否以魔数 oxcafebabe开头</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol></li><li>可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间</li></ol></li><li>连接阶段-准备<ol><li>JVM会在该阶段对<strong>静态变量</strong>分配内存并默认初始化，这些变量所使用的内存都将在方法区中进行分配<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span><br><span class="hljs-comment">//2. n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是 20</span><br><span class="hljs-comment">//3. n3 是 static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure></li></ol></li><li>连接阶段-解析<ol><li>JVM将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程</li></ol></li><li>Initialization（初始化）<ol><li>初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行&lt;clinit&gt;()方法的过程</li><li>&lt;clinit&gt;()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并</li><li>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕</li></ol></li></ol><h2 id="23-7-通过反射获取类的结构信息"><a href="#23-7-通过反射获取类的结构信息" class="headerlink" title="23.7 通过反射获取类的结构信息"></a>23.7 通过反射获取类的结构信息</h2><ol><li>java.lang.Class类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416120332.png" alt="image.png|500"></li><li>java.lang.reflect.Field 类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416120354.png" alt="image.png|500"></li><li>: java.lang.reflect.Method 类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416120411.png" alt="image.png|500"></li><li>java.lang.reflect.Constructor 类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416120427.png" alt="image.png|500"></li></ol><h2 id="23-8-通过反射创建对象"><a href="#23-8-通过反射创建对象" class="headerlink" title="23.8 通过反射创建对象"></a>23.8 通过反射创建对象</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416121348.png" alt="image.png|575"></p><h2 id="23-9-通过反射访问类中的成员"><a href="#23-9-通过反射访问类中的成员" class="headerlink" title="23.9 通过反射访问类中的成员"></a>23.9 通过反射访问类中的成员</h2><ol><li>访问属性<ol><li>根据属性名获取Field对象 Field f &#x3D; class对象.getDeclaredField(属性名);</li><li>爆破：f.setAccessible(true)</li><li>访问<ol><li>f.set(o, 值)  o表示对象</li><li>syso(f.get(o))  o表示对象</li></ol></li><li>注意：如果是静态属性，则set和get中的参数o可以写成null</li></ol></li><li>访问方法<ol><li>根据方法名和参数列表获取Method方法对象 Method m &#x3D; class.getDeclaredMethod(方法名，xx.classs) 得到本类所有方法</li><li>获取对象  Object o &#x3D; class.newInstance()</li><li>爆破  m.setAccessible(true)</li><li>访问 Object returnValue &#x3D; m.invoke(o, 实参列表)  </li><li>注意：如果是静态方法，则invoke的参数哦可以写成null</li></ol></li></ol><h1 id="24-MySQL"><a href="#24-MySQL" class="headerlink" title="24.MySQL"></a>24.MySQL</h1><h2 id="24-2-数据库"><a href="#24-2-数据库" class="headerlink" title="24.2 数据库"></a>24.2 数据库</h2><ol><li>命令行连接mysql数据库：<code>mysql -h 主机名 -P 端口号 -u 用户名 -p密码</code></li><li>启动数据库：<code>net start mysql 服务名</code></li><li>关闭数据库：<code>net stop mysql 服务名</code></li></ol><h2 id="24-6-数据在数据库中的存储方式"><a href="#24-6-数据在数据库中的存储方式" class="headerlink" title="24.6 数据在数据库中的存储方式"></a>24.6 数据在数据库中的存储方式</h2><ol><li>表的一行称为一条记录</li><li>java中，一行记录往往使用对象表示</li></ol><h2 id="24-7-SQL语句分类"><a href="#24-7-SQL语句分类" class="headerlink" title="24.7 SQL语句分类"></a>24.7 SQL语句分类</h2><ol><li>DDL：数据定义语句</li><li>DML：数据操作语句</li><li>DQL：数据查询语句</li><li>DCL：数据控制语句</li></ol><h2 id="24-8-创建数据库"><a href="#24-8-创建数据库" class="headerlink" title="24.8 创建数据库"></a>24.8 创建数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建数据库  <br><span class="hljs-keyword">create</span> database hsp01;  <br># 删除数据库  <br><span class="hljs-keyword">drop</span> database hsp01;  <br># 创建数据库并指定字符集  <br><span class="hljs-keyword">create</span> database hsp02 <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;  <br><span class="hljs-keyword">drop</span> database hsp02;  <br># 创建数据库并指定字符集和校对集  <br># utf8_general_ci: 不区分大小写  <br># utf8_bin: 区分大小写  <br><span class="hljs-keyword">create</span> database hsp03 <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8 <span class="hljs-keyword">collate</span> utf8_general_ci;  <br><span class="hljs-keyword">drop</span> database hsp03;<br></code></pre></td></tr></table></figure><h2 id="24-9-查看、删除数据库"><a href="#24-9-查看、删除数据库" class="headerlink" title="24.9 查看、删除数据库"></a>24.9 查看、删除数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看所有数据库  <br><span class="hljs-keyword">show</span> databases;  <br># 查看创建hsp数据库的定义信息  <br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> database hsp;<br></code></pre></td></tr></table></figure><h2 id="24-10-备份恢复数据库"><a href="#24-10-备份恢复数据库" class="headerlink" title="24.10 备份恢复数据库"></a>24.10 备份恢复数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#备份, 要在 Dos 下执行 mysqldump 指令其实在 mysql 安装目录\bin<br>#这个备份的文件，就是对应的 <span class="hljs-keyword">sql</span> 语句<br>mysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-operator">-</span>B hsp_db02 hsp_db03 <span class="hljs-operator">&gt;</span> d:\\bak.sql<br><span class="hljs-keyword">DROP</span> DATABASE ecshop;<br>#恢复数据库(注意：进入 Mysql 命令行再执行)<br>source d:\\bak.sql<br>#第二个恢复方法， 直接将 bak.sql 的内容放到查询编辑器中，执行<br></code></pre></td></tr></table></figure><h2 id="24-13-创建表"><a href="#24-13-创建表" class="headerlink" title="24.13 创建表"></a>24.13 创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(  <br>    id <span class="hljs-type">int</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),  <br>    password <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),  <br>    birthday <span class="hljs-type">date</span>  <br>)<span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8 <span class="hljs-keyword">collate</span> utf8_general_ci engine innodb;<br></code></pre></td></tr></table></figure><h2 id="24-14-常用数据类型"><a href="#24-14-常用数据类型" class="headerlink" title="24.14 常用数据类型"></a>24.14 常用数据类型</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416152223.png" alt="image.png"></p><h3 id="24-14-1-数值型-整数-的基本使用"><a href="#24-14-1-数值型-整数-的基本使用" class="headerlink" title="24.14.1 数值型(整数)的基本使用"></a>24.14.1 数值型(整数)的基本使用</h3><ol><li>在能够满足需求的情况下，尽量选择占用空间小的<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table1(  <br>    id tinyint  <br>);  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table2(  <br>    id tinyint unsigned  <br>); # unsigned 无符号  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1 <span class="hljs-keyword">values</span>(<span class="hljs-number">-1</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1;<br></code></pre></td></tr></table></figure></li></ol><h3 id="24-14-4-数值型-小数-的基本使用"><a href="#24-14-4-数值型-小数-的基本使用" class="headerlink" title="24.14.4 数值型(小数)的基本使用"></a>24.14.4 数值型(小数)的基本使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table03(  <br>    num1 <span class="hljs-type">float</span>,  <br>    num2 <span class="hljs-keyword">double</span>,  <br>    num3 <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)  <br>);  <br># <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)表示总共<span class="hljs-number">10</span>位，小数点后保留<span class="hljs-number">2</span>位<br></code></pre></td></tr></table></figure><h3 id="24-14-5-字符串的基本使用"><a href="#24-14-5-字符串的基本使用" class="headerlink" title="24.14.5 字符串的基本使用"></a>24.14.5 字符串的基本使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t04(  <br>    name <span class="hljs-type">char</span>(<span class="hljs-number">255</span>),  <br>    fakename <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)  <br>);  <br># <span class="hljs-type">char</span> 固定长度，不足的用空格填充  <br># <span class="hljs-type">varchar</span> 可变长度<br></code></pre></td></tr></table></figure><h3 id="24-14-6-字符串使用细节"><a href="#24-14-6-字符串使用细节" class="headerlink" title="24.14.6 字符串使用细节"></a>24.14.6 字符串使用细节</h3><ol><li>char(4)：4表示字符数，不是字节数，不管是中文还是字母都是放4个，按字符计算</li><li>varchar(4)：4表示字符数，按定义好的表的编码存放数据<ol><li>可变长度，本事还需要占用1-3个字节来存放内容长度，L（实际数据大小）+（1-3）字节</li></ol></li><li>存放文本也可以使用 text 数据类型，text没有默认值，大小为0-2^16字节，如果要存放更多字符可以选择mediumtext和longtext<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t05(  <br>    name <span class="hljs-type">char</span>(<span class="hljs-number">4</span>)  <br>);  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t05 <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;aaaa&#x27;</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t05;  <br>  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t06(  <br>    name text,  <br>    content mediumtext,  <br>    content2 longtext  <br>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="24-14-7-日期类型的基本使用"><a href="#24-14-7-日期类型的基本使用" class="headerlink" title="24.14.7 日期类型的基本使用"></a>24.14.7 日期类型的基本使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t06(  <br>    birthdate <span class="hljs-type">date</span>,  <br>    job_time datetime,  <br>    create_time <span class="hljs-type">timestamp</span>  <br>                <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">current_timestamp</span>  <br>                <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">current_timestamp</span>  <br>);  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t06(birthdate, job_time) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1990-01-01&#x27;</span>, <span class="hljs-string">&#x27;2010-01-01 00:00:00&#x27;</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t06;<br></code></pre></td></tr></table></figure><h2 id="24-16-修改表"><a href="#24-16-修改表" class="headerlink" title="24.16 修改表"></a>24.16 修改表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 在emp 上增加一个image 列  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> image <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;  <br># 查看emp表结构  <br><span class="hljs-keyword">desc</span> emp;  <br># 修改某列，改变长度  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp  <br>    modify sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;  <br># 删除某列  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp  <br>    <span class="hljs-keyword">drop</span> image;  <br># 修改表的字符集  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp  <br>    <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> charset utf8;  <br># 修改列名  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp  <br>    change name user_name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><h2 id="24-18数据库-C-create-R-read-U-update-D-delete-语句"><a href="#24-18数据库-C-create-R-read-U-update-D-delete-语句" class="headerlink" title="24.18数据库 C[create]R[read]U[update]D[delete]语句"></a>24.18数据库 C[create]R[read]U[update]D[delete]语句</h2><h2 id="24-19-Insert-语句"><a href="#24-19-Insert-语句" class="headerlink" title="24.19 Insert 语句"></a>24.19 Insert 语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp (id, user_name, salary, sex) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><ol><li>插入的数据应于字段的数据类型相同</li><li>数据的长度应在列的规定范围内</li><li>在 values 中列出的数据位置必须与被加入的列的排列位置相对应</li><li>字符和日期型数据应包含在单引号中</li><li>. 列可以插入空值[前提是该字段允许为空]</li><li>insert into tab_name (列名..) values (),(),() 形式添加多条记录</li><li>如果是给表中的所有字段添加数据，可以不写前面的字段名称</li></ol><h2 id="24-20-update-语句"><a href="#24-20-update-语句" class="headerlink" title="24.20 update 语句"></a>24.20 update 语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> emp  <br>    <span class="hljs-keyword">set</span> user_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Tom&#x27;</span>  <br>    <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol><li>如果修改多个字段，可以 set 字段1&#x3D;值1，字段2&#x3D;值2</li></ol><h2 id="24-21-delete-语句"><a href="#24-21-delete-语句" class="headerlink" title="24.21 delete 语句"></a>24.21 delete 语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> emp  <br>    <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;  <br># 删除所有数据  <br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><ol><li>delete不能删除某一列的值，可以使用update设置为null或者’’</li></ol><h2 id="24-22-select-语句"><a href="#24-22-select-语句" class="headerlink" title="24.22 select 语句"></a>24.22 select 语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">select</span> 基本语法  <br># <span class="hljs-keyword">select</span> [<span class="hljs-keyword">distinct</span>] <span class="hljs-operator">*</span><span class="hljs-operator">|</span>&#123;col1, col2,...&#125;  <br>#       <span class="hljs-keyword">from</span> table_name;  <br># 查询所有学生信息  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;  <br># 查询所有学生的姓名和应用成绩  <br><span class="hljs-keyword">select</span> name, english <span class="hljs-keyword">from</span> student;  <br># 成绩去重  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> english <span class="hljs-keyword">from</span> student;<br></code></pre></td></tr></table></figure><ol><li>重命名 <code>select col1 as 别名 from 表名</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 统计每个学生总分  <br><span class="hljs-keyword">select</span> name,(chinese<span class="hljs-operator">+</span>math<span class="hljs-operator">+</span>english) <span class="hljs-keyword">as</span> total <span class="hljs-keyword">from</span> student;  <br># 统计每个学生总分，按总分降序排列  <br><span class="hljs-keyword">select</span> name,(chinese<span class="hljs-operator">+</span>math<span class="hljs-operator">+</span>english) <span class="hljs-keyword">as</span> total <span class="hljs-keyword">from</span> student <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> total <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="24-22-7-在-where-子句中经常使用的运算符"><a href="#24-22-7-在-where-子句中经常使用的运算符" class="headerlink" title="24.22.7 在 where 子句中经常使用的运算符"></a>24.22.7 在 where 子句中经常使用的运算符</h3><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416160857.png" alt="image.png"></p><h3 id="24-22-10-使用-order-by-子句排序查询结果"><a href="#24-22-10-使用-order-by-子句排序查询结果" class="headerlink" title="24.22.10 使用 order by 子句排序查询结果"></a>24.22.10 使用 order by 子句排序查询结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1, col2,<br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> col1 <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><ol><li>asc 升序默认</li><li>desc 降序</li></ol><h2 id="24-23合计-统计函数"><a href="#24-23合计-统计函数" class="headerlink" title="24.23合计&#x2F;统计函数"></a>24.23合计&#x2F;统计函数</h2><h3 id="24-23-1-count"><a href="#24-23-1-count" class="headerlink" title="24.23.1 count"></a>24.23.1 count</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">|</span> <span class="hljs-built_in">count</span>(列名)<br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><ol><li>count(*) 返回满足条件的记录的行数</li><li>count(列): 统计满足条件的某列有多少个，但是会排除 为 null 的情况</li></ol><h3 id="24-23-2-sum"><a href="#24-23-2-sum" class="headerlink" title="24.23.2 sum"></a>24.23.2 sum</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(列名)<br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">where</span> ...;<br><br># 统计一个班级语文、英语、数学各科的总成绩<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(math) <span class="hljs-keyword">AS</span> math_total_score,<span class="hljs-built_in">SUM</span>(english),<span class="hljs-built_in">SUM</span>(chinese) <span class="hljs-keyword">FROM</span> student;<br># 统计一个班级语文成绩平均分<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(chinese)<span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student;<br></code></pre></td></tr></table></figure><h3 id="24-23-3-avg"><a href="#24-23-3-avg" class="headerlink" title="24.23.3 avg"></a>24.23.3 avg</h3><p>同sum</p><h3 id="24-23-4-max-min"><a href="#24-23-4-max-min" class="headerlink" title="24.23.4 max&#x2F;min"></a>24.23.4 max&#x2F;min</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">求出班级数学最高分和最低分<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(math) <span class="hljs-keyword">AS</span> math_high_socre, <span class="hljs-built_in">MIN</span>(math) <span class="hljs-keyword">AS</span> math_low_socre<br><span class="hljs-keyword">FROM</span> student;<br></code></pre></td></tr></table></figure><h3 id="24-23-5-使用-group-by-子句对列进行分组-先创建测试表"><a href="#24-23-5-使用-group-by-子句对列进行分组-先创建测试表" class="headerlink" title="24.23.5 使用 group by 子句对列进行分组 [先创建测试表]"></a>24.23.5 使用 group by 子句对列进行分组 [先创建测试表]</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1,col2,... <span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> col1<br></code></pre></td></tr></table></figure><h3 id="24-23-6-使用-having-子句对分组后的结果进行过滤"><a href="#24-23-6-使用-having-子句对分组后的结果进行过滤" class="headerlink" title="24.23.6 使用 having 子句对分组后的结果进行过滤"></a>24.23.6 使用 having 子句对分组后的结果进行过滤</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1, col2,... <br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> col1 <span class="hljs-keyword">having</span> ...<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 对查询的结果进行分组统计  <br># <span class="hljs-keyword">having</span> 对分组后的结果进行筛选  <br>  <br># 显示每个部门的平均工资和最高工资  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal), <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;  <br># 使用数学方法，对小数点进行处理  <br><span class="hljs-keyword">select</span> round(<span class="hljs-built_in">avg</span>(sal), <span class="hljs-number">2</span>), round(<span class="hljs-built_in">max</span>(sal), <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;  <br><span class="hljs-keyword">SELECT</span> FORMAT(<span class="hljs-built_in">AVG</span>(sal),<span class="hljs-number">2</span>), <span class="hljs-built_in">MAX</span>(sal) , deptno <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno;  <br># 显示每个部门的每种岗位的平均工资和最低工资  <br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(sal), <span class="hljs-built_in">MIN</span>(sal) , deptno, job <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno, job;  <br>  <br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(sal) <span class="hljs-keyword">AS</span> avg_sal, deptno  <br>    <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno  <br>    <span class="hljs-keyword">HAVING</span> avg_sal <span class="hljs-operator">&lt;</span> <span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><h2 id="24-24字符串相关函数"><a href="#24-24字符串相关函数" class="headerlink" title="24.24字符串相关函数"></a>24.24字符串相关函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"># CHARSET(str) 返回字符串字符集  <br><span class="hljs-keyword">select</span> charset(ename) <span class="hljs-keyword">from</span> emp;  <br># CONCAT (string2 [,... ]) 连接字符串，拼接成一列  <br><span class="hljs-keyword">select</span> concat(ename,<span class="hljs-string">&#x27;工作是&#x27;</span>,job) <span class="hljs-keyword">from</span> emp;  <br># INSTR (string ,substring ) 返回 substring 在 string 中出现的位置,没有返回 <span class="hljs-number">0</span># dual 亚元表，用于测试函数  <br><span class="hljs-keyword">SELECT</span> INSTR(<span class="hljs-string">&#x27;hanshunping&#x27;</span>, <span class="hljs-string">&#x27;ping&#x27;</span>) <span class="hljs-keyword">FROM</span> DUAL;  <br># UCASE (string) 返回字符串的大写形式  <br><span class="hljs-keyword">select</span> ucase(ename) <span class="hljs-keyword">from</span> emp;  <br># LCASE (string) 返回字符串的小写形式  <br><span class="hljs-keyword">select</span> lcase(ename) <span class="hljs-keyword">from</span> emp;  <br># <span class="hljs-keyword">LEFT</span> (string, length) 返回字符串左边的 length 个字符  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">left</span>(ename,<span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> emp;  <br># <span class="hljs-keyword">RIGHT</span> (string, length) 返回字符串右边的 length 个字符  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">right</span>(ename,<span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> emp;  <br># LENGTH (string) 返回字符串的长度  <br><span class="hljs-keyword">select</span> length(ename) <span class="hljs-keyword">from</span> emp;  <br># REPLACE (string, <span class="hljs-keyword">from</span>, <span class="hljs-keyword">to</span>) 将字符串中的 <span class="hljs-keyword">from</span> 替换为 toselect replace(job,<span class="hljs-string">&#x27;MANAGER&#x27;</span>,<span class="hljs-string">&#x27;经理&#x27;</span>) <span class="hljs-keyword">from</span> emp;  <br># STRCMP (string1, string2) 比较两个字符串  <br><span class="hljs-keyword">select</span> strcmp(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">SUBSTRING</span> (string, <span class="hljs-keyword">start</span>, length) 返回字符串的子串  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">substring</span>(ename,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-keyword">from</span> emp;  <br># <span class="hljs-built_in">TRIM</span> (string) 删除字符串两端的空格  <br># LTRIM (string) 删除字符串左端的空格  <br># RTRIM (string) 删除字符串右端的空格  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(ename) <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h2 id="24-25数学相关函数"><a href="#24-25数学相关函数" class="headerlink" title="24.25数学相关函数"></a>24.25数学相关函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-built_in">ABS</span>(num) 绝对值  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">abs</span>(<span class="hljs-number">-10</span>) <span class="hljs-keyword">from</span> dual;  <br># BIN(num) 二进制  <br><span class="hljs-keyword">select</span> bin(<span class="hljs-number">10</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">CEIL</span>(num) 向上取整  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">10.1</span>) <span class="hljs-keyword">from</span> dual;  <br># CONV(num, from_base, to_base) 进制转换  <br><span class="hljs-keyword">select</span> conv(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> dual; # <span class="hljs-number">10</span>进制的<span class="hljs-number">9</span>转换为<span class="hljs-number">2</span>进制  <br># <span class="hljs-built_in">FLOOR</span>(num) 向下取整  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">10.9</span>) <span class="hljs-keyword">from</span> dual;  <br># FORMAT(num, <span class="hljs-type">decimal</span>) 格式化  <br><span class="hljs-keyword">select</span> format(<span class="hljs-number">1234567.892323</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> dual;  <br># HEX(num) 十六进制  <br><span class="hljs-keyword">select</span> hex(<span class="hljs-number">10</span>) <span class="hljs-keyword">from</span> dual;  <br># LEAST(num1, num2, ...) 返回最小值  <br><span class="hljs-keyword">select</span> least(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">MOD</span>(num1, num2) 取模  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">from</span> dual;  <br># POW(num1, num2) 幂运算  <br><span class="hljs-keyword">select</span> pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">from</span> dual;  <br># ROUND(num, <span class="hljs-type">decimal</span>) 四舍五入  <br><span class="hljs-keyword">select</span> round(<span class="hljs-number">10.123456</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> dual;  <br># RAND() 随机数  <br><span class="hljs-keyword">select</span> rand() <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h2 id="24-26时间日期相关函数"><a href="#24-26时间日期相关函数" class="headerlink" title="24.26时间日期相关函数"></a>24.26时间日期相关函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-built_in">CURRENT_DATE</span>() 当前日期 <span class="hljs-number">2024</span><span class="hljs-number">-04</span><span class="hljs-number">-16</span><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_date</span>() <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">CURRENT_TIME</span>() 当前时间 <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_time</span>() <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">CURRENT_TIMESTAMP</span>() 当前时间 <span class="hljs-number">2024</span><span class="hljs-number">-04</span><span class="hljs-number">-16</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_timestamp</span>() <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-type">DATE</span>(datetime) 返回日期部分  <br><span class="hljs-keyword">select</span> <span class="hljs-type">date</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-type">TIME</span>(datetime) 返回时间部分  <br><span class="hljs-keyword">select</span> <span class="hljs-type">time</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># DATE_ADD(<span class="hljs-type">date</span>, <span class="hljs-type">INTERVAL</span> expr type) 日期加法  <br><span class="hljs-keyword">select</span> date_add(<span class="hljs-string">&#x27;2024-04-16&#x27;</span>, <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">month</span> ) <span class="hljs-keyword">from</span> dual;  <br># DATE_SUB(<span class="hljs-type">date</span>, <span class="hljs-type">INTERVAL</span> expr type) 日期减法  <br><span class="hljs-keyword">select</span> date_sub(<span class="hljs-string">&#x27;2024-04-16&#x27;</span>, <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">year</span> ) <span class="hljs-keyword">from</span> dual;  <br># DATEDIFF(date1, date2) 日期差  <br><span class="hljs-keyword">select</span> datediff(<span class="hljs-string">&#x27;2024-04-16&#x27;</span>, <span class="hljs-string">&#x27;2024-04-15&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># TIMEDIFF(time1, time2) 时间差  <br><span class="hljs-keyword">select</span> timediff(<span class="hljs-string">&#x27;16:00:00&#x27;</span>, <span class="hljs-string">&#x27;15:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># NOW() 当前日期时间 <span class="hljs-number">2024</span><span class="hljs-number">-04</span><span class="hljs-number">-16</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-keyword">select</span> now() <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-keyword">YEAR</span><span class="hljs-operator">|</span><span class="hljs-keyword">MONTH</span><span class="hljs-operator">|</span><span class="hljs-keyword">DAY</span><span class="hljs-operator">|</span><span class="hljs-keyword">HOUR</span><span class="hljs-operator">|</span><span class="hljs-keyword">MINUTE</span><span class="hljs-operator">|</span><span class="hljs-keyword">SECOND</span>(datetime) 提取日期时间的年月日时分秒  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">month</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">day</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">hour</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">minute</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">second</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># unix_timestamp(datetime) 返回时间戳  <br><span class="hljs-keyword">select</span> unix_timestamp() <span class="hljs-keyword">from</span> dual; # 返回<span class="hljs-number">1970</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>到当前时间的秒数  <br># FROM_UNIXTIME(unix_timestamp) 时间戳转日期时间  <br><span class="hljs-keyword">select</span> from_unixtime(<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> dual; # <span class="hljs-number">1970</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h2 id="24-27加密和系统函数"><a href="#24-27加密和系统函数" class="headerlink" title="24.27加密和系统函数"></a>24.27加密和系统函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">USER</span>() 查询用户，查看可以登录mysql的用户及IP  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">USER</span>() <span class="hljs-keyword">from</span> dual;  <br># DATABASE() 查询当前数据库  <br><span class="hljs-keyword">select</span> DATABASE() <span class="hljs-keyword">from</span> dual;  <br># MD5() 加密  <br><span class="hljs-keyword">select</span> MD5(<span class="hljs-string">&#x27;123456&#x27;</span>) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h2 id="24-28流程控制函数"><a href="#24-28流程控制函数" class="headerlink" title="24.28流程控制函数"></a>24.28流程控制函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"># IF(expr1, expr2, expr3) 如果expr1为真，则返回expr2，否则返回expr3  <br><span class="hljs-keyword">select</span> if(<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;true&#x27;</span>, <span class="hljs-string">&#x27;false&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># IFNULL(expr1, expr2) 如果expr1为<span class="hljs-keyword">NULL</span>，则返回expr2，否则返回expr1  <br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;null&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> expr1 <span class="hljs-keyword">THEN</span> expr2 <span class="hljs-keyword">WHEN</span> expr3 <span class="hljs-keyword">THEN</span> expr4 <span class="hljs-keyword">ELSE</span> expr5 <span class="hljs-keyword">END</span>  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">case</span>  <br>    <span class="hljs-keyword">when</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;jack&#x27;</span>  <br>    <span class="hljs-keyword">when</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;rose&#x27;</span>  <br>    <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;lily&#x27;</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h2 id="24-29mysql-表查询–加强"><a href="#24-29mysql-表查询–加强" class="headerlink" title="24.29mysql 表查询–加强"></a>24.29mysql 表查询–加强</h2><ol><li>like操作符<ol><li>%表示0到多个字符</li><li>_表示单个字符</li></ol></li></ol><h3 id="24-29-2-分页查询"><a href="#24-29-2-分页查询" class="headerlink" title="24.29.2 分页查询"></a>24.29.2 分页查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">select</span> ... limit <span class="hljs-keyword">start</span>, <span class="hljs-keyword">rows</span>  <br># 表示从第<span class="hljs-keyword">start</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>行开始，取<span class="hljs-keyword">rows</span>行数据  <br># <span class="hljs-keyword">start</span>从<span class="hljs-number">0</span>开始  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> empno  <br>    limit <span class="hljs-number">0</span>, <span class="hljs-number">3</span>;  <br># <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <br>#     <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> empno  <br>#     limit 每页显示的条数 <span class="hljs-operator">*</span> (当前页码 <span class="hljs-operator">-</span> <span class="hljs-number">1</span>), 每页显示的条数;  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> empno  <br>    limit <span class="hljs-number">3</span>, <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="24-29-3-使用分组函数和分组子句"><a href="#24-29-3-使用分组函数和分组子句" class="headerlink" title="24.29.3 使用分组函数和分组子句"></a>24.29.3 使用分组函数和分组子句</h3><ol><li>select执行顺序<ol><li>group by</li><li>having</li><li>order by</li><li>limit</li></ol></li></ol><h2 id="24-30mysql-多表查询"><a href="#24-30mysql-多表查询" class="headerlink" title="24.30mysql 多表查询"></a>24.30mysql 多表查询</h2><h3 id="24-30-4-自连接"><a href="#24-30-4-自连接" class="headerlink" title="24.30.4 自连接"></a>24.30.4 自连接</h3><ol><li>自连接是在同一张表的连接查询<ol><li>将同一张表看做两张</li><li>需要给表取别名</li><li>列名不明确，可以指定列的别名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> worker.ename <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;职员名&#x27;</span> , boss.ename <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;上级名&#x27;</span><br><span class="hljs-keyword">FROM</span> emp worker, emp boss<br><span class="hljs-keyword">WHERE</span> worker.mgr <span class="hljs-operator">=</span> boss.empno;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="24-31mysql-表子查询"><a href="#24-31mysql-表子查询" class="headerlink" title="24.31mysql 表子查询"></a>24.31mysql 表子查询</h2><ol><li>子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询</li><li>单行子查询：指只返回一行数据的子查询语句</li><li>多行子查询：返回多行数据的子查询，使用关键字in  all  any<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <br>    <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> (  <br>        <span class="hljs-keyword">select</span> deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SMITH&#x27;</span>  <br>        );<br></code></pre></td></tr></table></figure></li><li>多列子查询：指查询返回多个列数据的子查询语句</li></ol><h2 id="24-32-表复制"><a href="#24-32-表复制" class="headerlink" title="24.32 表复制"></a>24.32 表复制</h2><h3 id="24-32-1-自我复制数据-蠕虫复制"><a href="#24-32-1-自我复制数据-蠕虫复制" class="headerlink" title="24.32.1 自我复制数据(蠕虫复制)"></a>24.32.1 自我复制数据(蠕虫复制)</h3><ol><li>为了对某个sql语句进行效率测试， 需要海量数据时，可以使用此法为表创建海量数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> my_tab01  <br>( id <span class="hljs-type">INT</span>, `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>), sal <span class="hljs-keyword">DOUBLE</span>, job <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>), deptno <span class="hljs-type">INT</span>);  <br>  <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_tab01  <br>(id, `name`, sal, job,deptno)  <br><span class="hljs-keyword">SELECT</span> empno, ename, sal, job, deptno <span class="hljs-keyword">FROM</span> emp;  <br>  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tab01;  <br>  <br># 自我复制  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_tab01  <br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tab01;  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> my_tab01;  <br>  <br># 如何删除一张表重复记录  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_tab02 <span class="hljs-keyword">like</span> my_tab01;  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_tab02  <br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tab01;  <br># 创建一张临时表，my_tmp，结构和my_tab02一样  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_tmp <span class="hljs-keyword">like</span> my_tab02;  <br># 将my_tab02中的数据导入到my_tmp中  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_tmp  <br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tab02;  <br># 删除my_tab02记录  <br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> my_tab02;  <br># 将my_tmp中的数据导入到my_tab02中  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_tab02  <br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tmp;  <br># 删除临时表  <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> my_tmp;<br></code></pre></td></tr></table></figure></li></ol><h2 id="24-33-合并查询"><a href="#24-33-合并查询" class="headerlink" title="24.33 合并查询"></a>24.33 合并查询</h2><ol><li>为了合并多个select语句的结果，可以使用集合操作 union、union all<ol><li>union all：获取两个结果集的并集，不会取消重复行</li><li>union：自动去除结果集中的重复行</li></ol></li></ol><h2 id="24-34mysql-表外连接"><a href="#24-34mysql-表外连接" class="headerlink" title="24.34mysql 表外连接"></a>24.34mysql 表外连接</h2><ol><li>左外连接：左侧的表完全显示 left join</li><li>右外连接：右侧的表完全显示  right join<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `name`, stu.id, grade  <br><span class="hljs-keyword">FROM</span> stu, exam  <br><span class="hljs-keyword">WHERE</span> stu.id <span class="hljs-operator">=</span> exam.id;  <br>  <br># 左外连接  <br><span class="hljs-keyword">SELECT</span> `name`, stu.id, grade  <br><span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> exam  <br><span class="hljs-keyword">ON</span> stu.id <span class="hljs-operator">=</span> exam.id;<br></code></pre></td></tr></table></figure></li></ol><h2 id="24-35mysql-约束"><a href="#24-35mysql-约束" class="headerlink" title="24.35mysql 约束"></a>24.35mysql 约束</h2><ol><li>约束用于确保数据库中数据满足特定的商业规则：not null、unique、primary key、foreign key、check<ol><li>primary key：主键，唯一标识数据，该列不能重复<ol><li>不能重复也不能为null</li><li>一张表最多只能有一个主键，但是可以是复合主键 primay key(id, name)</li><li>指定方式<ol><li>字段名 primary key</li><li>表定义最后 primay key(列名)</li></ol></li><li>desc 表名，可以查看primary key的情况</li></ol></li><li>not null：插入数据时，该列必须提供数据</li><li>unique：该列值不能重复<ol><li>一张表可以有多个unique字段</li><li>如果没有指定not null，unique字段可以有多个null</li></ol></li><li>foregin key<ol><li>用于定义主表和从表之间的关系，外键约束定义在从表上，主表必须具有主键约束或者unique约束</li><li>当定义外键约束后，要求外键列数据必须在主表的主键存在或是null</li><li>语法：<code>foregin key(本表字段名) references 主表名(主键名或unique字段名)</code></li><li>表的类型是innodb才支持外键</li><li>外键字段的类型要和主键字段类型一致，长度可以不同</li><li>外键字段的值，必须在主键字段中出现过，或者为null，前提是外键字段允许位null</li><li>一旦建立主外键的关节，数据就不能随意删除了</li></ol></li><li>check<ol><li>强制行数据必须满足的条件</li></ol></li></ol></li></ol><h2 id="24-36-自增长"><a href="#24-36-自增长" class="headerlink" title="24.36 自增长"></a>24.36 自增长</h2><ol><li>语法：<code>字段名 类型 primary key auto_increment</code></li><li>自增长一般配合primary key使用</li><li>自增长也可以单独使用，但是需要配合一个unique</li><li>自增长修饰的字段为整数型</li><li>自增长默认从1 开始，可以通过修改 alter table 表名 auto_increment &#x3D; 新的开始值</li><li>如果添加数据时，给自增长字段指定了值，那就按指定的值为准</li></ol><h2 id="24-37-mysql-索引"><a href="#24-37-mysql-索引" class="headerlink" title="24.37 mysql 索引"></a>24.37 mysql 索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建索引<br><span class="hljs-keyword">create</span> index empno_index <span class="hljs-keyword">on</span> emp(empno) # 在emp表的empno列创建索引<br></code></pre></td></tr></table></figure><ol><li>没有索引为什么慢：全表扫描</li><li>使用索引为什么快：形成一个索引的数据结构</li><li>索引的代价<ol><li>磁盘占用</li><li>对dml(update、delete、insert)语句的效率有影响</li></ol></li><li>索引的类型<ol><li>主键索引，primary key</li><li>唯一索引，unique</li><li>普通索引，index</li><li>全文索引，fulltext，一般开发不使用mysql自带的全文索引，而是全文搜索Solr和ElasticSearch</li></ol></li></ol><h3 id="24-37-4-索引使用"><a href="#24-37-4-索引使用" class="headerlink" title="24.37.4 索引使用"></a>24.37.4 索引使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建索引  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t25(  <br>    id <span class="hljs-type">int</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)  <br>);  <br># 查看是否有索引  <br><span class="hljs-keyword">show</span> indexes <span class="hljs-keyword">from</span> t25;  <br># 添加唯一索引，如果某列的值不会重复，优先考虑<span class="hljs-keyword">unique</span>索引，否则考虑普通索引  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index id_index <span class="hljs-keyword">on</span> t25(id);  <br># 添加普通索引  <br><span class="hljs-keyword">create</span> index name_index <span class="hljs-keyword">on</span> t25(name);  <br># 添加普通索引方式<span class="hljs-number">2</span>  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t25 <span class="hljs-keyword">add</span> index name_index2(name);  <br># 添加主键索引  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t26(  <br>    id <span class="hljs-type">int</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)  <br>);  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t26 <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(id);  <br># 删除索引  <br><span class="hljs-keyword">drop</span> index id_index <span class="hljs-keyword">on</span> t25;  <br># 删除主键索引  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t26 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;  <br># 修改索引，先删除再添加  <br>  <br># 查看索引  <br><span class="hljs-keyword">show</span> indexes <span class="hljs-keyword">from</span> t25;  <br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> t25;  <br><span class="hljs-keyword">show</span> keys <span class="hljs-keyword">from</span> t25;<br><span class="hljs-keyword">desc</span> t25<br></code></pre></td></tr></table></figure><ol><li>小结：哪些列上适合使用索引<ol><li>较频繁的作为查询条件字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁被查询</li><li>更新非常频繁的字段不适合创建索引</li><li>不会出现在where子句中的字段不该创建索引</li></ol></li></ol><h2 id="24-38-mysql-事务"><a href="#24-38-mysql-事务" class="headerlink" title="24.38 mysql 事务"></a>24.38 mysql 事务</h2><ol><li>事务用于保证数据的一致性，由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败</li><li>当执行事务操作时，mysql会在表上加锁，防止其他用户改表</li><li>mysql数据库控制事务的操作<ol><li>start transaction：开始一个事务</li><li>savepoint：保存点名–设置保存点</li><li>rollback to：保存点名–回退事务</li><li>rollback：回退全部事务</li><li>commit：提交事务，所有的操作生效，不能回退<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建一张表  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1(  <br>    id <span class="hljs-type">int</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)  <br>);  <br># 开始事务  <br><span class="hljs-keyword">start</span> transaction;  <br># 设置保存点  <br><span class="hljs-keyword">savepoint</span> s1;  <br># dml操作  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1;  <br># 保存点  <br><span class="hljs-keyword">savepoint</span> s2;  <br># dml操作  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>);  <br># 回退到s2  <br><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> s2;  <br># 直接回退到事务开始状态  <br><span class="hljs-keyword">rollback</span>;  <br><span class="hljs-keyword">commit</span> ;<br></code></pre></td></tr></table></figure></li></ol></li><li>回退事务<ol><li>保存点是事务中的点，用于取消部分事务，当结束事务时(commit)会自动删除事务所定义的所有保存点</li><li>执行回退事务时，通过指定保存点可以回退到指定的点</li></ol></li><li>提交事务<ol><li>commit会确认事务的变化、结束事务、删除保存点、释放锁、数据生效</li><li>使用commit结束事务后，其他会话将可以查看到事务变化后的新数据</li></ol></li><li>事务细节<ol><li>如果不开始事务，默认情况下，dml操作是自动提交，不能回滚</li><li>如果开始一个事务，没有创建保存点，可以执行rollback，默认回退到事务开始状态</li><li>事务机制需要innodb存储引擎才可以使用</li></ol></li></ol><h2 id="24-39-事务隔离级别"><a href="#24-39-事务隔离级别" class="headerlink" title="24.39 事务隔离级别"></a>24.39 事务隔离级别</h2><ol><li>多个连接开启各自事务操作数据库的操作时，数据库要负责隔离操作，以保证各个连接在获取数据时的准确性</li><li>如果没有隔离，可能会导致：脏读、不可重复读、幻读<ol><li>脏读 dirty read：当一个事务读取到另一个事务尚未提交的改变</li><li>不可重复读 nonrepeatable read：同一个查询在同一个事务中多次进行，由于其他提交事务所作的修改或删除，导致每次返回不同的结果集</li><li>幻读 phantom read：同一查询在同一事务中多次进行，由于其他提交事务所作的插入操作，每次返回不同的结果集</li></ol></li><li>隔离级别<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240417165754.png" alt="image.png|500"></li><li>设置事务隔离级别<ol><li>查看当前会话隔离级别 select @@tx_isolation;</li><li>查看系统当前隔离级别 select @@global.tx_isolation;</li><li>设置当前会话隔离级别 set session transaction isolation level repeatable read;</li><li>设置系统当前隔离级别 set global transaction isolation level repeatable read;</li><li>默认情况下，mysql事务隔离级别是repeatable read，满足大部分项目需求</li><li>全局修改，修改 my.ini配置文件，在最后加上 transaction-isolation &#x3D; ?</li></ol></li></ol><h2 id="24-40-mysql-事务-ACID"><a href="#24-40-mysql-事务-ACID" class="headerlink" title="24.40 mysql 事务 ACID"></a>24.40 mysql 事务 ACID</h2><ol><li>ACID<ol><li>Atomicity：原子性，事务是不可分割的单位，要么全都发生，要么都不发生</li><li>Consistency：一致性，事务必须使数据库从一个一致性状态变换成另一个一致性状态</li><li>Isolation：隔离性</li><li>Durability：持久性，一旦提交，数据改变就是永久的，即使数据库发生故障也不会有影响</li></ol></li></ol><h2 id="24-41-mysql-表类型和存储引擎"><a href="#24-41-mysql-表类型和存储引擎" class="headerlink" title="24.41 mysql 表类型和存储引擎"></a>24.41 mysql 表类型和存储引擎</h2><ol><li>mysql的表类型由存储引擎决定，包括MyISAM、innodb、memory</li><li>mysql数据表主要支持六种类型：csv、memory、archive、mrg_myisam、myisam、innobdb</li><li>这六种又分两类：事务安全型（innobdb），其他都是非事务安全型</li><li><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240417171022.png" alt="image.png|500"></li><li>MyISAM：不支持事务，也不支持外键，访问速度快，对事务完整性没有要求</li><li>InnoDB提供了具有提交、回滚、奔溃恢复能力的事务安全，写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引</li><li>MEMORY使用内存中的内容创建表，每个memory表实际对应一个磁盘文件，访问非常快，默认使用hash索引，但是一旦mysql服务关闭，表中的数据就会丢失，表的结构还在</li><li>存储引擎的选择<ol><li>如果不需要事务，处理的是基本的CRUD操作，那么选择MyISAM</li><li>如果需要支持事务，选择InnoDB</li></ol></li><li>修改存储引擎：alter table table_name engine &#x3D; ‘存储引擎’</li></ol><h2 id="24-42-视图-view"><a href="#24-42-视图-view" class="headerlink" title="24.42 视图(view)"></a>24.42 视图(view)</h2><ol><li>视图是一个虚拟表，内容由查询定义，同真实的表一样，视图包含列，其数据来自对应的真实表（基表）<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建视图  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> emp_view01  <br>    <span class="hljs-keyword">as</span>  <br>    <span class="hljs-keyword">select</span> empno, ename, job, deptno <span class="hljs-keyword">from</span> emp;  <br># 查看视图  <br><span class="hljs-keyword">desc</span> emp_view01;  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp_view01;  <br># 查看创建视图的<span class="hljs-keyword">SQL</span>语句  <br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> emp_view01;  <br># 删除视图  <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> emp_view01;  <br># 修改视图，会影响到基表  <br><span class="hljs-keyword">update</span> emp_view01 <span class="hljs-keyword">set</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span> <span class="hljs-keyword">where</span> empno <span class="hljs-operator">=</span> <span class="hljs-number">7369</span>;  <br># 视图中可以再使用视图  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> emp_view02  <br>    <span class="hljs-keyword">as</span>  <br>    <span class="hljs-keyword">select</span> empno, ename, job, deptno <span class="hljs-keyword">from</span> emp_view01;<br></code></pre></td></tr></table></figure></li><li>视图最佳实践<ol><li>安全，报名</li><li>性能</li><li>灵活</li></ol></li></ol><h2 id="24-43-Mysql-管理"><a href="#24-43-Mysql-管理" class="headerlink" title="24.43 Mysql 管理"></a>24.43 Mysql 管理</h2><h3 id="24-43-1-Mysql-用户"><a href="#24-43-1-Mysql-用户" class="headerlink" title="24.43.1 Mysql 用户"></a>24.43.1 Mysql 用户</h3><ol><li>mysql中的用户都存储在系统数据库mysql中的user表中<ol><li>host：允许登录的位置，localhost表示该用户只允许本机登录，也可以指定ip地址</li><li>user：用户名</li><li>authentication_string：密码，通过mysql的password()函数加密之后的密码</li></ol></li><li>创建用户<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;用户名&#x27;</span> @ <span class="hljs-string">&#x27;允许登录位置&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span><br></code></pre></td></tr></table></figure></li><li>删除用户<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;用户名&#x27;</span> @ <span class="hljs-string">&#x27;允许登录位置&#x27;</span><br></code></pre></td></tr></table></figure></li><li>用户修改密码<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">修改自己的密码<br><span class="hljs-keyword">set</span> password <span class="hljs-operator">=</span> password(<span class="hljs-string">&#x27;密码&#x27;</span>)<br>修改他人密码<br><span class="hljs-keyword">set</span> password <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;用户名&#x27;</span> @ <span class="hljs-string">&#x27;登录位置&#x27;</span> <span class="hljs-operator">=</span> password(<span class="hljs-string">&#x27;密码&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>给用户授权<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">基本语法<br><span class="hljs-keyword">grant</span> 权限列表 <span class="hljs-keyword">on</span> 库.对象名 <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;用户名&#x27;</span> @ <span class="hljs-string">&#x27;登录位置&#x27;</span> [identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span>]<br>说明<br><span class="hljs-number">1.</span>权限列表，多个权限用逗号分开<br><span class="hljs-number">2.</span><span class="hljs-operator">*</span>.<span class="hljs-operator">*</span>表示所有数据库的所有对象<br><span class="hljs-number">3.</span>库.<span class="hljs-operator">*</span>表示某数据库的所有数据对象<br></code></pre></td></tr></table></figure></li><li>回收用户权限 revoke 权限列表 on 库.对象名 from ‘用户名’ @ ‘登录位置’</li><li>权限生效指令：flush privileges</li></ol><h1 id="25-JDBC和数据库连接池"><a href="#25-JDBC和数据库连接池" class="headerlink" title="25.JDBC和数据库连接池"></a>25.JDBC和数据库连接池</h1><h2 id="25-1-JDBC"><a href="#25-1-JDBC" class="headerlink" title="25.1 JDBC"></a>25.1 JDBC</h2><ol><li>jdbc为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题</li><li>java程序员只需要面向这套接口编程即可</li><li>JDBC API</li></ol><h2 id="25-2-JDBC-快速入门"><a href="#25-2-JDBC-快速入门" class="headerlink" title="25.2 JDBC 快速入门"></a>25.2 JDBC 快速入门</h2><ol><li>JDBC 程序编写步骤<ol><li>注册驱动 - 加载Driver类</li><li>获取连接 - 得到Connection</li><li>执行增删改查 - 发送SQL给mysql执行</li><li>释放资源 - 关闭相关连接</li></ol></li></ol><h2 id="25-3-获取数据库连接-5-种方式"><a href="#25-3-获取数据库连接-5-种方式" class="headerlink" title="25.3 获取数据库连接 5 种方式"></a>25.3 获取数据库连接 5 种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;  <br>    <span class="hljs-comment">// 静态加载，灵活性差  </span><br>    <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>;  <br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);  <br>    properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>);  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> driver.connect(url, properties);  <br>&#125;  <br><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException &#123;  <br>    <span class="hljs-comment">// 反射加载Driver，灵活性高，减少代码耦合  </span><br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <br>    <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver) clazz.newInstance();  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>;  <br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);  <br>    properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>);  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> driver.connect(url, properties);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException &#123;  <br>    <span class="hljs-comment">// DriverManager替换Driver 统一管理，推荐方式  </span><br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <br>    <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver) clazz.newInstance();  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;  <br>    DriverManager.registerDriver(driver);  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password); <span class="hljs-comment">// 也可以使用Properties  </span><br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;  <br>    <span class="hljs-comment">// 使用Class.forName自动完成驱动注册，简化代码  </span><br>    Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect05</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, IOException, ClassNotFoundException &#123;  <br>    <span class="hljs-comment">// 使用配置文件  </span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/main/resources/jdbc.properties&quot;</span>));  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);  <br>    <span class="hljs-comment">// 加载驱动  </span><br>    Class.forName(properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>));  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-4-ResultSet-结果集"><a href="#25-4-ResultSet-结果集" class="headerlink" title="25.4 ResultSet[结果集]"></a>25.4 ResultSet[结果集]</h2><ol><li>表示数据库结果集的数据表，通常通过执行查询数据库的语句生成</li><li>ResultSet对象保持一个光标指向当前的数据行，最初，光标位于第一行</li><li>next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环遍历结果集</li></ol><h2 id="25-5-Statement"><a href="#25-5-Statement" class="headerlink" title="25.5 Statement"></a>25.5 Statement</h2><ol><li>Statement对象用于执行静态SQL语句，并返回其生成的结果的对象</li><li>在建立连接后，需要对数据库进行访问，执行命令或者sql语句，可以通过<ol><li>statement，存在sql注入</li><li>preparedStatement 预处理</li><li>CallableStatement 存储过程</li></ol></li><li>Statement对象执行sql语句，存在sql注入风险</li><li>sql注入是利用某些系统没有对用户输入的数据进行充分检查，而在用户输入数据中注入非法的sql语句段或命令，恶意攻击数据库</li><li>要防范sql注入，只要用preparedStatement取代就可以了</li></ol><h2 id="25-6-PreparedStatement"><a href="#25-6-PreparedStatement" class="headerlink" title="25.6 PreparedStatement"></a>25.6 PreparedStatement</h2><ol><li>PreparedStatement 执行的sql语句中的参数用 (?) 表示，调用PreparedStatement对象的 setXxx()方法来设置这些参数，有两个参数，第一个参数是要设置的sql语句中的参数的索引（从1开始），第二个是设置的sql语句中的参数的值</li><li>调用 excuteQuery() 返回 ResultSet 对象</li><li>调用 excuteUpdate() 执行更新，包括增删改</li><li>预处理好处<ol><li>不再使用 + 拼接 sql 语句，减少语法错误</li><li>有效解决sql注入问题</li><li>减少了编译次数，效率较高<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//3. 得到 PreparedStatement</span><br><span class="hljs-comment">//3.1 组织 SqL , Sql 语句的 ? 就相当于占位符</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select name , pwd from admin where name =? and pwd = ?&quot;</span>;<br><span class="hljs-comment">//String sql = &quot;insert into admin values(?, ?)&quot;;</span><br><span class="hljs-comment">//String sql = &quot;update admin set pwd = ? where name = ?&quot;;</span><br><span class="hljs-comment">//String sql = &quot;delete from admin where name = ?&quot;;</span><br><span class="hljs-comment">//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><span class="hljs-comment">//3.3 给 ? 赋值</span><br>preparedStatement.setString(<span class="hljs-number">1</span>, admin_name);<br>preparedStatement.setString(<span class="hljs-number">2</span>, admin_pwd);<br><span class="hljs-comment">//4. 执行 select 语句使用 executeQuery</span><br><span class="hljs-comment">//</span><br>如果执行的是 dml(update, insert ,delete) executeUpdate()<br><span class="hljs-comment">//</span><br>这里执行 executeQuery ,不要在写 sql<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery(sql);<br><span class="hljs-keyword">if</span> (resultSet.next()) &#123; <span class="hljs-comment">//如果查询到一条记录，则说明该管理存在</span><br>System.out.println(<span class="hljs-string">&quot;恭喜， 登录成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;对不起，登录失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="25-7-JDBC-的相关-API-小结"><a href="#25-7-JDBC-的相关-API-小结" class="headerlink" title="25.7 JDBC 的相关 API 小结"></a>25.7 JDBC 的相关 API 小结</h2><ol><li>DriverManager 驱动管理类<ol><li>getConnection(url, user, pwd) 获取连接</li></ol></li><li>Connection 接口<ol><li>createStatement </li><li>preparedStatement(sql) 生成预处理对象</li></ol></li><li>Statement 接口<ol><li>excuteUpdate(sql)  dml语句，返回影响的行数</li><li>excuteQuery(sql)  执行查询，返回ResultSet对象</li><li>excute(sql) 执行任意sql，返回布尔值</li></ol></li><li>PreparedStatemnet<ol><li>excuteUpdate(sql)</li><li>excuteQuery()</li><li>excute(sql)</li><li>setXxx(占位符索引，占位符的值)  解决sql注入</li><li>setObject(占位符索引，占位符的值)</li></ol></li><li>ResultSet<ol><li>next() 向下移动一行，如果没有下一行，返回false</li><li>previous() 向上移动一行，如果没有上一行，返回false</li><li>getXxx(列的索引|列名) 返回对应列的值，接收类型是Xxx</li><li>getObject(列的索引|列名) 返回对应列的值，接收类型是Object</li></ol></li></ol><h2 id="25-8-封装-JDBCUtils-【关闭连接-得到连接】"><a href="#25-8-封装-JDBCUtils-【关闭连接-得到连接】" class="headerlink" title="25.8 封装 JDBCUtils 【关闭连接, 得到连接】"></a>25.8 封装 JDBCUtils 【关闭连接, 得到连接】</h2><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1151</span><br></code></pre></td></tr></table></figure><h2 id="25-9-事务"><a href="#25-9-事务" class="headerlink" title="25.9 事务"></a>25.9 事务</h2><ol><li>jdbc中当有一个connection对象创建时，默认情况下是自动提交事务，每次执行一个sql语句时，如果执行成功，会向数据库自动提交，不能回滚</li><li>jdbc为了让多个sql语句作为一个整体执行，需要使用事务</li><li>调用connection的setAutoCommit(false) 可以取消自动提交事务</li><li>在所有的sql语句都成功执行成功后，调用Connection的commit()提交事务</li><li>Connection的rollback()回滚事务</li></ol><h2 id="25-10-批处理"><a href="#25-10-批处理" class="headerlink" title="25.10 批处理"></a>25.10 批处理</h2><ol><li>当需要成批插入或者更新记录时，可以采用批处理</li><li>该操作可以一次性提交给数据批量处理，通常比单独提交处理更有效率</li><li>jdbc的批量处理语句包括以下方法<ol><li>addBatch() 添加需要批量处理的sql语句或参数</li><li>excuteBatch() 执行批量处理语句</li><li>clearBatch() 清空批处理语句</li></ol></li><li>jdbc连接mysql时，如果要批处理操作，需要在url参加参数?rewriteBatchedStatement&#x3D;true</li><li>批处理往往和PreparedStatement一起使用</li></ol><h2 id="25-11数据库连接池"><a href="#25-11数据库连接池" class="headerlink" title="25.11数据库连接池"></a>25.11数据库连接池</h2><ol><li>传统的jdbc数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将Connection加载到内存中，再验证ip地址、用户名、密码。需要数据库连接的时候，就要向数据库要求一个，频繁得进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃</li><li>每一次数据库连接，使用完都要断开，如果程序出现异常无法关闭，将导致数据库内存泄露，最终导致重启数据库</li><li>传统获取连接的方式，不能控制创建的连接数量，如果连接过多，导致内存泄露，mysql崩溃</li><li>解决开发中的数据库连接问题，可以采用数据库连接池技术 connection pool</li><li>基本介绍<ol><li>预先在缓冲池放入一定数量的连接，当需要建立数据库连接时，只需从缓冲池中取出一个，使用完毕后再放回去</li><li>数据库连接池负责分配、管理和释放数据库连接，允许应用程序重复使用一个现有数据库连接，而不是重新建立一个</li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中</li></ol></li><li>数据库连接池分类<ol><li>C3P0 速度相对较慢，稳定性不错</li><li>DBCP 速度相对于C3P0较快但不稳定</li><li>Proxool 有监控连接池状态的功能，稳定性较c3p0差一点</li><li>BoneCP 速度快</li><li>Druid 集DBCP、C3P0、Proxool优点于一身</li></ol></li></ol><h3 id="25-11-4-C3P0-应用实例"><a href="#25-11-4-C3P0-应用实例" class="headerlink" title="25.11.4 C3P0 应用实例"></a>25.11.4 C3P0 应用实例</h3><p>&#x2F;&#x2F;方式 1： 相关参数，在程序中指定 user, url , password 等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 创建一个数据源对象</span><br><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br><span class="hljs-comment">//2. 通过配置文件 mysql.properties 获取相关连接的信息</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\mysql.properties&quot;</span>));<br><span class="hljs-comment">//读取相关的属性值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>....<br><span class="hljs-comment">//给数据源 comboPooledDataSource 设置相关的参数</span><br><span class="hljs-comment">//注意：连接管理是由 comboPooledDataSource 来管理</span><br>comboPooledDataSource.setDriverClass(driver);<br>comboPooledDataSource.setJdbcUrl(url);<br>comboPooledDataSource.setUser(user);<br>comboPooledDataSource.setPassword(password);<br><span class="hljs-comment">//设置初始化连接数</span><br>comboPooledDataSource.setInitialPoolSize(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//最大连接数</span><br>comboPooledDataSource.setMaxPoolSize(<span class="hljs-number">50</span>);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection(); <span class="hljs-comment">//这个方法就是从 DataSource 接口实现的</span><br>connection.close();<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;第二种方式 使用配置文件模板来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 将 c3p0 提供的 c3p0.config.xml 拷贝到 src 目录下</span><br><span class="hljs-comment">//2. 该文件指定了连接数据库和连接池的相关参数</span><br><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>(<span class="hljs-string">&quot;hsp_edu&quot;</span>);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection();<br>connection.close();<br></code></pre></td></tr></table></figure><h3 id="25-11-5-Druid-德鲁伊-应用实例"><a href="#25-11-5-Druid-德鲁伊-应用实例" class="headerlink" title="25.11.5 Druid(德鲁伊)应用实例"></a>25.11.5 Druid(德鲁伊)应用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 加入 Druid jar 包</span><br><span class="hljs-comment">//2. 加入 配置文件 druid.properties , 将该文件拷贝项目的 src 目录</span><br><span class="hljs-comment">//3. 创建 Properties 对象, 读取配置文件</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));<br><span class="hljs-comment">//4. 创建一个指定参数的数据库连接池, Druid 连接池</span><br><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>connection.close();<br></code></pre></td></tr></table></figure><h3 id="25-11-6-将-JDBCUtils-工具类改成-Druid-德鲁伊-实现"><a href="#25-11-6-将-JDBCUtils-工具类改成-Druid-德鲁伊-实现" class="headerlink" title="25.11.6 将 JDBCUtils 工具类改成 Druid(德鲁伊)实现"></a>25.11.6 将 JDBCUtils 工具类改成 Druid(德鲁伊)实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds;<br><span class="hljs-comment">//在静态代码块完成 ds 初始化</span><br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><span class="hljs-keyword">try</span> &#123;<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));<br>ds = DruidDataSourceFactory.createDataSource(properties);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">//编写 getConnection 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-keyword">return</span> ds.getConnection();<br>&#125;<br><span class="hljs-comment">//关闭连接, 老师再次强调： 在数据库连接池技术中，close 不是真的断掉连接</span><br><span class="hljs-comment">//而是把使用的 Connection 对象放回连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ResultSet resultSet, Statement statement, Connection connection)</span> &#123;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (resultSet != <span class="hljs-literal">null</span>) &#123;<br>resultSet.close();<br>&#125;<br><span class="hljs-keyword">if</span> (statement != <span class="hljs-literal">null</span>) &#123;<br>statement.close();<br>&#125;<br><span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>connection.close();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 得到连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//2. 组织一个 sql</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from actor where id &gt;= ?&quot;</span>;<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//3. 创建 PreparedStatement 对象</span><br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br>System.out.println(connection.getClass());<span class="hljs-comment">//运行类型 com.alibaba.druid.pool.DruidPooledConnection</span><br>preparedStatement = connection.prepareStatement(sql);<br>preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//给?号赋值</span><br><span class="hljs-comment">//执行, 得到结果集</span><br>set = preparedStatement.executeQuery();<br><span class="hljs-comment">//遍历该结果集</span><br><span class="hljs-keyword">while</span> (set.next()) &#123;...&#125;<br>&#125;<span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//关闭资源</span><br>JDBCUtilsByDruid.close(set, preparedStatement, connection);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-12-Apache—DBUtils"><a href="#25-12-Apache—DBUtils" class="headerlink" title="25.12 Apache—DBUtils"></a>25.12 Apache—DBUtils</h2><ol><li>问题<ol><li>关闭connection后，resultSet结果集无法继续使用</li><li>resultSet不利于数据管理</li></ol></li><li>commons-dbutils是一个开源JDBC工具类库，是对JDBC的封装，极大简化jdbc编码的工作量</li><li>QueryRunner类：封装了SQL的执行，线程安全，可以实现增删改查批处理</li><li>ResultSetHandler接口：将数据按要求转换成另一种形式<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240418145652.png" alt="image.png"></li><li>返回结果是多行的情况<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用 apache-DBUtils 工具类 + druid 完成对表的 crud 操作</span><br><span class="hljs-comment">//1. 得到 连接 (druid)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-comment">//2. 使用 DBUtils 类和接口 , 先引入 DBUtils 相关的 jar , 加入到本 Project</span><br><span class="hljs-comment">//3. 创建 QueryRunner</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//4. 就可以执行相关的方法，返回 ArrayList 结果集</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select id, name from actor where id &gt;= ?&quot;</span>;<br><span class="hljs-comment">//(1) query 方法就是执行 sql 语句，得到 resultset ---封装到 --&gt; ArrayList 集合中</span><br><span class="hljs-comment">//(2) 返回集合</span><br><span class="hljs-comment">//(3) connection: 连接</span><br><span class="hljs-comment">//(4) sql : 执行的 sql 语句</span><br><span class="hljs-comment">//(5) new BeanListHandler&lt;&gt;(Actor.class): 在将 resultset -&gt; Actor 对象 -&gt; 封装到 ArrayList</span><br><span class="hljs-comment">// 底层使用反射机制 去获取 Actor 类的属性，然后进行封装</span><br><span class="hljs-comment">//(6) 1 就是给 sql 语句中的? 赋值，可以有多个值，因为是可变参数 Object... params</span><br><span class="hljs-comment">//(7) 底层得到的 resultset ,会在 query 关闭, 关闭 PreparedStatment</span><br>List&lt;Actor&gt; list = queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(Actor.class), <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (Actor actor : list) &#123;<br>System.out.print(actor);<br>&#125;<br><span class="hljs-comment">//释放资源</span><br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br></code></pre></td></tr></table></figure></li><li>返回的结果是单行记录(单个对象)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 得到 连接 (druid)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-comment">//3. 创建 QueryRunner</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//4. 就可以执行相关的方法，返回单个对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from actor where id = ?&quot;</span>;<br><span class="hljs-comment">// 因为我们返回的单行记录&lt;---&gt;单个对象 , 使用的 Hander 是 BeanHandler</span><br><span class="hljs-type">Actor</span> <span class="hljs-variable">actor</span> <span class="hljs-operator">=</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanHandler</span>&lt;&gt;(Actor.class), <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 释放资源</span><br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br></code></pre></td></tr></table></figure></li><li>查询结果是单行单列-返回的就是 object<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 得到 连接 (druid)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-comment">//3. 创建 QueryRunner</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//4. 就可以执行相关的方法，返回单行单列 , 返回的就是 Object</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select name from actor where id = ?&quot;</span>;<br><span class="hljs-comment">//老师解读： 因为返回的是一个对象, 使用的 handler 就是 ScalarHandler</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScalarHandler</span>(), <span class="hljs-number">4</span>);<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br></code></pre></td></tr></table></figure></li><li>完成 dml (update, insert ,delete)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 得到 连接 (druid)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-comment">//3. 创建 QueryRunner</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//4. 这里组织 sql 完成 update, insert delete</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update actor set name = ? where id = ?&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into actor values(null, ?, ?, ?, ?)&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delete from actor where id = ?&quot;</span>;<br><span class="hljs-comment">//(1) 执行 dml 操作是 queryRunner.update()</span><br><span class="hljs-comment">//(2) 返回的值是受影响的行数 (affected: 受影响)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">affectedRow</span> <span class="hljs-operator">=</span> queryRunner.update(connection, sql, <span class="hljs-string">&quot;林青霞&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;1966-10-10&quot;</span>, <span class="hljs-string">&quot;116&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">affectedRow</span> <span class="hljs-operator">=</span> queryRunner.update(connection, sql, <span class="hljs-number">1000</span> );<br>System.out.println(affectedRow &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;执行成功&quot;</span> : <span class="hljs-string">&quot;执行没有影响到表&quot;</span>);<br><span class="hljs-comment">// 释放资源</span><br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br></code></pre></td></tr></table></figure></li></ol><h2 id="25-13DAO-和增删改查通用方法-BasicDao"><a href="#25-13DAO-和增删改查通用方法-BasicDao" class="headerlink" title="25.13DAO 和增删改查通用方法-BasicDao"></a>25.13DAO 和增删改查通用方法-BasicDao</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240418151438.png" alt="image.png"></p><ol><li>问题<ol><li>sql语句是固定的，不能通过参数传入，通用性不好，需要改进更方便增删改查</li><li>对于select操作，如果有返回值，返回类型不能固定，需要使用泛型</li><li>将来的表很多，业务需求复杂，不能只靠一个java类完成</li></ol></li><li>基本说明<ol><li>DAO：data access object 数据访问对象</li><li>这样的通用类称为BasicDao，是专门和数据库交互的，即完成对数据库的crud操作<ol><li>BasicDao将各个DAO共同操作部分抽象出来</li></ol></li><li>在BasicDao的基础上，实现一张表对应一个DAO，比如Customer表 - Cunstomer.java(javabean) - CustomerDao.java</li></ol></li></ol><h3 id="25-13-3-BasicDAO-应用实例"><a href="#25-13-3-BasicDAO-应用实例" class="headerlink" title="25.13.3 BasicDAO 应用实例"></a>25.13.3 BasicDAO 应用实例</h3><ol><li>utils 工具类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">如上<br></code></pre></td></tr></table></figure></li><li>domain  &#x2F;&#x2F; javabean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Actor对象<br></code></pre></td></tr></table></figure></li><li>dao  &#x2F;&#x2F; 存放XxxDAO和BasicDAO<ol><li>开发 BasicDAO , 是其他 DAO 的父类, 使用到 apache-dbutils<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicDAO</span>&lt;T&gt; &#123; <span class="hljs-comment">//泛型指定具体类型</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">QueryRunner</span> <span class="hljs-variable">qr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//开发通用的 dml 方法, 针对任意的表，int表示受影响的行数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String sql, Object... parameters)</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br><span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> qr.update(connection, sql, parameters);<br><span class="hljs-keyword">return</span> update;<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); <span class="hljs-comment">//将编译异常-&gt;运行异常 ,抛出</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br>&#125;<br><br><span class="hljs-comment">//返回多个对象(即查询的结果是多行), 针对任意表</span><br><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title function_">queryMulti</span><span class="hljs-params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br><span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;T&gt;(clazz), parameters);<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); <span class="hljs-comment">//将编译异常-&gt;运行异常 ,抛出</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//查询单行结果 的通用方法</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">querySingle</span><span class="hljs-params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br><span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanHandler</span>&lt;T&gt;(clazz), parameters);<br>&#125;<span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); <span class="hljs-comment">//将编译异常-&gt;运行异常 ,抛出</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查询单行单列的方法,即返回单值的方法</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryScalar</span><span class="hljs-params">(String sql, Object... parameters)</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br><span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScalarHandler</span>(), parameters);<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); <span class="hljs-comment">//将编译异常-&gt;运行异常 ,抛出</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>ActorDAO<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActorDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicDAO</span>&lt;Actor&gt; &#123;<br><span class="hljs-comment">//1. 就有 BasicDAO 的方法</span><br><span class="hljs-comment">//2. 根据业务需求，可以编写特有的方法.</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>test &#x2F;&#x2F; 测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDAO</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testActorDAO</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ActorDAO</span> <span class="hljs-variable">actorDAO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActorDAO</span>();<br><span class="hljs-comment">//1. 查询</span><br>List&lt;Actor&gt; actors = actorDAO.queryMulti(<span class="hljs-string">&quot;select * from actor where id &gt;= ?&quot;</span>, Actor.class, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//2. 查询单行记录</span><br><span class="hljs-type">Actor</span> <span class="hljs-variable">actor</span> <span class="hljs-operator">=</span> actorDAO.querySingle(<span class="hljs-string">&quot;select * from actor where id = ?&quot;</span>, Actor.class, <span class="hljs-number">6</span>);<br><span class="hljs-comment">//3. 查询单行单列</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> actorDAO.queryScalar(<span class="hljs-string">&quot;select name from actor where id = ?&quot;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-comment">//4. dml 操作 insert ,update, delete</span><br><span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> actorDAO.update(<span class="hljs-string">&quot;insert into actor values(null, ?, ?, ?, ?)&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;2000-11-11&quot;</span>, <span class="hljs-string">&quot;999&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="27-正则表达式"><a href="#27-正则表达式" class="headerlink" title="27.正则表达式"></a>27.正则表达式</h1><h2 id="27-6-正则表达式语法"><a href="#27-6-正则表达式语法" class="headerlink" title="27.6 正则表达式语法"></a>27.6 正则表达式语法</h2><ol><li>元字符<ol><li>限定符</li><li>选择匹配符</li><li>分组组合和反向引用符</li><li>特殊字符</li><li>字符匹配符</li><li>定位符<br> <a href="https://www.bilibili.com/video/BV1fh411y7R8/?p=880&spm_id_from=pageDriver&vd_source=bca558bb7d969805c4b5b82a858ad6aa">0879_韩顺平Java_正则底层实现1_哔哩哔哩_bilibili</a><br> 1206</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【胡思01】Ctrl+F的最大搜索范围是多少</title>
    <link href="/2022/03/26/%E3%80%90%E8%83%A1%E6%80%9D01%E3%80%91Ctrl+F%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91/"/>
    <url>/2022/03/26/%E3%80%90%E8%83%A1%E6%80%9D01%E3%80%91Ctrl+F%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91/</url>
    
    <content type="html"><![CDATA[<p>今天在一个有上百万字符的txt文件中使用<code>Ctrl+F</code>可以正常搜索出需要的内容，不禁就想<code>Ctrl+F</code>的最大搜索范围是多大，难道是无穷大吗？</p><p>Ctrl+F（以及其他文本搜索功能）常用的字符串匹配算法有多种，不同的应用程序会选择不同的算法来平衡性能和准确性。以下是几种常见的字符串匹配算法，它们被用于类似 Ctrl+F 这样的搜索功能中。</p><h3 id="1-朴素字符串匹配算法（Naive-String-Matching-Algorithm）"><a href="#1-朴素字符串匹配算法（Naive-String-Matching-Algorithm）" class="headerlink" title="1. 朴素字符串匹配算法（Naive String Matching Algorithm）"></a>1. <strong>朴素字符串匹配算法（Naive String Matching Algorithm）</strong></h3><p>这是最简单的字符串匹配算法，其工作原理非常直观：从目标文本的每个字符开始，逐一对比目标子串，直到找到完全匹配的子串位置。具体流程如下：</p><ul><li>将搜索词（模式串）与文本中的子串进行逐字符比较。</li><li>若不匹配，移动一个字符，继续下一次比较。<br><strong>优点</strong>：实现简单，易于理解。<br><strong>缺点</strong>：对于长文本和大规模匹配，效率较低，时间复杂度为 (O(n \times m))，其中 (n) 是文本长度，(m) 是模式串长度。</li></ul><h3 id="2-KMP-算法（Knuth-Morris-Pratt-Algorithm）"><a href="#2-KMP-算法（Knuth-Morris-Pratt-Algorithm）" class="headerlink" title="2. KMP 算法（Knuth-Morris-Pratt Algorithm）"></a>2. <strong>KMP 算法（Knuth-Morris-Pratt Algorithm）</strong></h3><p>KMP 算法通过预处理模式串，创建一个“部分匹配表”（Partial Match Table），以避免不必要的字符比较。在匹配过程中，当遇到不匹配时，KMP 算法不必回溯到原先的文本位置，而是利用部分匹配表，跳过一些字符。<br><strong>流程</strong>：</p><ul><li>预处理模式串，创建部分匹配表，记录每个位置之前的前缀与后缀的匹配情况。</li><li>在实际搜索时，遇到不匹配字符时，跳过不可能匹配的位置，避免重复比较。<br><strong>优点</strong>：大大减少了重复的字符比较，时间复杂度为 (O(n + m))。<br><strong>缺点</strong>：实现相对复杂，尤其是部分匹配表的构建。</li></ul><h3 id="3-Boyer-Moore-算法（Boyer-Moore-Algorithm）"><a href="#3-Boyer-Moore-算法（Boyer-Moore-Algorithm）" class="headerlink" title="3. Boyer-Moore 算法（Boyer-Moore Algorithm）"></a>3. <strong>Boyer-Moore 算法（Boyer-Moore Algorithm）</strong></h3><p>Boyer-Moore 是另一个高效的字符串匹配算法，它从模式串的最后一个字符开始比较，如果不匹配，则利用两种规则来跳过尽可能多的字符：</p><ul><li><strong>坏字符规则（Bad Character Rule）</strong>：在发生不匹配时，模式串直接跳过不匹配的字符，移动到与文本匹配的字符位置。</li><li><strong>好后缀规则（Good Suffix Rule）</strong>：如果匹配到一部分模式串，且接下来发生不匹配，则根据已匹配的部分向前移动模式串。<br><strong>优点</strong>：在实际操作中非常高效，尤其在模式串较长时，能够跳过大量字符，时间复杂度在最优情况下接近 (O(n&#x2F;m))。<br><strong>缺点</strong>：最坏情况下复杂度为 (O(n \times m))，且实现复杂。</li></ul><h3 id="4-Rabin-Karp-算法"><a href="#4-Rabin-Karp-算法" class="headerlink" title="4. Rabin-Karp 算法"></a>4. <strong>Rabin-Karp 算法</strong></h3><p>Rabin-Karp 算法利用哈希函数进行字符串匹配。它首先计算模式串的哈希值，然后在文本的每个子串上滑动，计算当前子串的哈希值。如果两个哈希值相同，再逐字符比较确认。<br><strong>流程</strong>：</p><ul><li>计算模式串的哈希值。</li><li>从文本中逐个提取长度等于模式串的子串，并计算其哈希值。</li><li>如果哈希值相等，再进行逐字符比较。<br><strong>优点</strong>：当需要搜索多个模式串时效率较高，哈希计算的时间复杂度为 (O(n))。<br><strong>缺点</strong>：哈希冲突可能导致需要进行更多比较，最坏情况时间复杂度为 (O(n \times m))。</li></ul><h3 id="5-Aho-Corasick-算法"><a href="#5-Aho-Corasick-算法" class="headerlink" title="5. Aho-Corasick 算法"></a>5. <strong>Aho-Corasick 算法</strong></h3><p>Aho-Corasick 是一种基于有限自动机的字符串匹配算法，特别适用于多模式匹配。该算法首先通过构建一个状态机，将多个模式串组织在一起，然后一次性在文本中匹配所有模式。<br><strong>优点</strong>：非常适合在文本中同时搜索多个模式串，时间复杂度为 (O(n + m + z))，其中 (z) 是找到的匹配数量。<br><strong>缺点</strong>：构建状态机需要额外的空间和时间。</p><h3 id="底层实现的选择"><a href="#底层实现的选择" class="headerlink" title="底层实现的选择"></a>底层实现的选择</h3><p>Ctrl+F 这样的功能，常根据具体情况选择不同的算法。比如，浏览器中 Ctrl+F 的实现可能选择简单的朴素算法，因为网页通常不长，算法的简易性可以满足需求。而在大型文档处理工具中，如 PDF 阅读器、IDE 等，则更可能使用 KMP 或 Boyer-Moore 这样的高效算法，以提高搜索性能。<br>总的来说，Ctrl+F 的底层实现通常会根据具体应用的需求选择合适的字符串匹配算法，既能满足高效搜索，又能适应不同的文件规模和环境。</p><p>Ctrl+F 搜索的范围并不是完全“无限大”的。它的实际搜索范围取决于搜索所在的文本大小和应用的技术限制。具体底层实现方式可以从以下几个方面理解：</p><h3 id="1-搜索范围与数据读取"><a href="#1-搜索范围与数据读取" class="headerlink" title="1. 搜索范围与数据读取"></a>1. <strong>搜索范围与数据读取</strong></h3><p>Ctrl+F 在执行时，首先会加载当前显示的页面或文档内容。如果文档很大，程序会分段加载这些内容，逐步进行搜索。浏览器或文本编辑器通常会在后台动态加载剩余内容，从而允许搜索在未完全显示的文本中继续进行，但这种操作受限于计算机内存和性能。对于在线文档或网页，搜索范围通常是整个已经加载的页面【7†source】【9†source】。</p><h3 id="2-全文索引和搜索算法"><a href="#2-全文索引和搜索算法" class="headerlink" title="2. 全文索引和搜索算法"></a>2. <strong>全文索引和搜索算法</strong></h3><p>在底层，Ctrl+F 通过匹配算法（如简单的字符串匹配算法）进行工作。它会通过遍历整个文档的字符，查找用户输入的关键词。对于大文件或数据库系统，通常会先建立“全文索引”，这是一种优化手段，使得搜索效率更高。在这种情况下，程序可以直接通过索引找到匹配的词，而不是逐字符搜索【9†source】。</p><h3 id="3-软件的限制与优化"><a href="#3-软件的限制与优化" class="headerlink" title="3. 软件的限制与优化"></a>3. <strong>软件的限制与优化</strong></h3><p>不同软件对 Ctrl+F 功能的限制不同。例如，像 IntelliJ IDEA 等开发工具默认会显示最多 100 个搜索结果，但可以通过设置增加上限【8†source】。此外，一些文本编辑器可能会限制每次搜索的文本块大小，以减少系统资源消耗。浏览器中，如果一个网页的文本量非常大，Ctrl+F 的搜索效率可能会降低，甚至导致浏览器崩溃。这是因为浏览器需要将整个文档加载到内存中进行匹配。</p><h3 id="4-内存和性能的影响"><a href="#4-内存和性能的影响" class="headerlink" title="4. 内存和性能的影响"></a>4. <strong>内存和性能的影响</strong></h3><p>搜索范围的大小受到设备的内存和性能影响。如果内存较小或文档非常大（如几十万行的代码文件或几百页的PDF），搜索的响应速度会变慢，甚至可能因为内存不足导致搜索失败。因此，虽然理论上搜索的范围可以非常大，但实际操作中，受硬件条件的限制。</p><p>总结来说，Ctrl+F 的底层实现依赖于字符串匹配算法，搜索范围依赖于所搜索文本的加载方式、应用的优化手段以及设备的硬件条件。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
