<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【学习】大Key问题</title>
    <link href="/2024/09/24/0924-%E5%A4%A7Key%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/24/0924-%E5%A4%A7Key%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.svg" alt="Redis集群模式.svg"><br><strong>大Key</strong>指的是在键值对数据库（如 Redis 等)中，某个键对应的数据量非常大，通常包括：</p><ul><li><strong>字符串大Key</strong>：单个字符串键的长度非常大。</li><li><strong>集合大Key</strong>：某个键对应的集合（如 list、set、hash）包含了大量的元素。</li></ul><p>大Key会带来以下几个问题：</p><ol><li><strong>操作耗时</strong>：对大Key的读写操作（如<code>GET</code>、<code>SET</code>、<code>HGETALL</code>等）需要大量的网络带宽，导致操作耗时较长。特别是在主从同步时，大Key的复制可能耗费大量时间和资源，甚至阻塞其他命令。</li><li><strong>阻塞问题</strong>：Redis 是单线程的，如果某个大Key需要进行处理（如删除、遍历、复制等），可能导致Redis的整体服务阻塞，影响其他请求。</li><li><strong>内存分配问题</strong>：存储大Key时，Redis 需要一次性分配大量内存，如果没有合理的内存分配策略，可能会导致内存碎片化，影响性能。</li><li><strong>内存限制</strong>：大Key容易占用大量内存，特别是在高并发场景下，如果多个客户端同时访问和操作大Key，可能会导致 Redis 的内存爆满，从而触发 OOM。</li></ol><h3 id="分片处理策略"><a href="#分片处理策略" class="headerlink" title="分片处理策略"></a>分片处理策略</h3><p><strong>分片（Sharding）</strong> 是处理大Key的一种常用策略，特别是在分布式数据库或缓存中，分片可以将数据按一定规则分布到多个节点上，减少单个节点的负担，提升系统的可扩展性和性能。</p><h4 id="1-如何知道有多少片？"><a href="#1-如何知道有多少片？" class="headerlink" title="1. 如何知道有多少片？"></a>1. 如何知道有多少片？</h4><p>分片的数量和划分策略通常取决于具体的实现和设计目标，分片数量可以根据以下方式确定：</p><ul><li><strong>静态分片</strong>：事先根据集群规模和数据量<font color="#974806">设置固定数量的分片</font>。例如，Redis Cluster 使用<strong>哈希槽</strong>机制，共有16384个哈希槽，数据按哈希槽分布到不同的节点上。<ul><li><strong>动态分片</strong>：根据数据的实际增长情况，<font color="#974806">自动调整分片数量</font>。这通常适用于可扩展的系统，可以随着数据规模和负载的增加进行动态扩展。比如一些 NoSQL 数据库会根据节点负载情况进行自动分片和重分配。</li></ul></li><li><strong>一致性哈希（Consistent Hashing）</strong>：使用一致性哈希算法将数据分布到不同的节点上。一致性哈希可以很好地支持动态扩展，当增加或减少节点时，只需要对少量数据进行重新分片。Kafka、Cassandra 等使用一致性哈希进行分片管理。<br>分片数量的决定可以通过分析系统的负载、内存占用和节点的容量来进行。如果系统允许动态扩展，分片数量可以随着数据规模增加而增长。</li></ul><h4 id="2-如何保证数据写入所有分片成功？"><a href="#2-如何保证数据写入所有分片成功？" class="headerlink" title="2. 如何保证数据写入所有分片成功？"></a>2. 如何保证数据写入所有分片成功？</h4><p>要确保分片后的数据写入成功，通常可以采取以下策略：</p><h5 id="（1）多副本（Replication）"><a href="#（1）多副本（Replication）" class="headerlink" title="（1）多副本（Replication）"></a>（1）多副本（Replication）</h5><p>大多数分布式系统会<font color="#974806">使用数据副本来增加写入的可靠性</font>，即每个分片会有多个副本，写入操作需要在多个副本上成功后才能确认数据写入完成。例如：</p><ul><li><strong>Redis Sentinel</strong>：Redis 的高可用方案，通过配置主从复制（Replication）来保证数据的持久性。如果主节点故障，可以自动将从节点提升为主节点。<ul><li><strong>Redis Cluster</strong>：通过分片管理，每个分片（Slot）可以有多个副本。写入时，通常要求在主节点写入成功，并且将数据复制到从节点。</li></ul></li><li><strong>Kafka 的 ISR（In-Sync Replicas）机制</strong>：写入消息到 Kafka 时，只有当所有同步副本（ISR）都成功接收到消息后，才会返回确认，保证数据写入可靠。</li></ul><h5 id="（2）分布式事务或两阶段提交（2PC）"><a href="#（2）分布式事务或两阶段提交（2PC）" class="headerlink" title="（2）分布式事务或两阶段提交（2PC）"></a>（2）分布式事务或两阶段提交（2PC）</h5><p>为了保证数据写入多个分片的原子性，可以使用分布式事务或两阶段提交协议（2PC，Two-Phase Commit）：</p><ul><li><strong>准备阶段（Prepare Phase）</strong>：在所有分片上预写入数据，记录下准备状态，但还未提交。</li><li><strong>提交阶段（Commit Phase）</strong>：如果所有分片都准备完毕，则提交数据；否则，执行回滚操作。<br>这种方式能确保数据一致性，但性能会有所影响，尤其是在跨多个分片写入时。</li></ul><h5 id="（3）强一致性机制（强一致写入）"><a href="#（3）强一致性机制（强一致写入）" class="headerlink" title="（3）强一致性机制（强一致写入）"></a>（3）强一致性机制（强一致写入）</h5><p>一些分布式系统会提供强一致性写入机制，如：</p><ul><li><strong>Quorum写入</strong>：确保写操作至少在大多数副本上写入成功。例如在Cassandra、HBase等系统中，使用<code>W = Quorum</code>的策略，即大多数节点确认写入后，认为操作成功。</li><li><strong>事务性操作</strong>：在 Redis 中，虽然分片后不直接支持分布式事务，但可以通过 Lua 脚本确保同一事务内操作的原子性。对于分布式系统，系统级的事务性操作可以确保多个分片写入成功。</li></ul><h5 id="（4）回调检查与补偿机制"><a href="#（4）回调检查与补偿机制" class="headerlink" title="（4）回调检查与补偿机制"></a>（4）回调检查与补偿机制</h5><p>可以在写入后使用异步回调或日志补偿机制进行确认：</p><ul><li><strong>回调机制</strong>：写入分片后，通过回调机制检查每个分片的写入状态。如果有某个分片写入失败，可以通过回调机制重试写入操作。<ul><li><strong>补偿机制</strong>：通过定时检查写入日志（或使用WAL日志）来检查分片数据的写入状态。如果发现某些分片的数据不一致，可以重新同步或补偿数据。</li></ul></li></ul><h3 id="三、示例：Redis-Cluster的写入与分片"><a href="#三、示例：Redis-Cluster的写入与分片" class="headerlink" title="三、示例：Redis Cluster的写入与分片"></a>三、示例：Redis Cluster的写入与分片</h3><p>以 Redis Cluster 为例，它使用<strong>哈希槽（hash slot）</strong>进行数据分片：</p><ol><li>Redis Cluster 会将数据分成 16384 个哈希槽，每个 key 的哈希值根据<code>CRC16</code>算法计算，并取模 16384 来确定数据属于哪个哈希槽。</li><li>集群中的每个节点负责一定数量的哈希槽。当需要扩展集群时，可以增加节点，并将哈希槽重新分配到新的节点上。</li><li>在写入时，数据首先写入到主节点，并同步复制到从节点。如果主节点故障，从节点可以自动接管。</li><li><font color="#974806">Redis Cluster 的写入操作默认只确认主节点写入成功即可</font>，但为了提高可靠性，可以通过配置<code>wait</code>命令，确保数据<font color="#974806">被写入指定数量的副本后才返回确认</font>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】Redis的集群模式</title>
    <link href="/2024/09/24/0924-redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/09/24/0924-redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.svg" alt="Redis集群模式.svg"></p><h2 id="哨兵模式的启用"><a href="#哨兵模式的启用" class="headerlink" title="哨兵模式的启用"></a>哨兵模式的启用</h2><p>哨兵模式需要配置Redis的主从复制（master-slave）架构，并通过哨兵（Sentinel）进行故障监控和自动主从切换。</p><h4 id="1-配置主从节点"><a href="#1-配置主从节点" class="headerlink" title="1. 配置主从节点"></a>1. <strong>配置主从节点</strong></h4><p>首先，配置Redis主从复制架构。</p><ul><li>在主节点的<code>redis.conf</code>中，保持默认配置，主节点不需要额外的配置。</li><li>在从节点的<code>redis.conf</code>文件中，添加以下内容来指定它从哪个主节点复制数据：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">replicaof &lt;master-ip&gt; &lt;master-port&gt;<br></code></pre></td></tr></table></figure>重启Redis从节点来生效配置。</li></ul><h4 id="2-配置哨兵（Sentinel）"><a href="#2-配置哨兵（Sentinel）" class="headerlink" title="2. 配置哨兵（Sentinel）"></a>2. <strong>配置哨兵（Sentinel）</strong></h4><p>哨兵是一个独立的进程，可以监控Redis实例。每个哨兵实例都需要一个配置文件，例如<code>sentinel.conf</code>。</p><ul><li>创建并编辑<code>sentinel.conf</code>文件，主要配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">port 26379  <span class="hljs-comment"># 哨兵运行的端口</span><br>sentinel monitor mymaster 192.168.1.100 6379 2<br>sentinel down-after-milliseconds mymaster 5000<br>sentinel failover-timeout mymaster 10000<br>sentinel parallel-syncs mymaster 1<br></code></pre></td></tr></table></figure>其中：<ul><li><code>mymaster</code> 是对主节点的逻辑名称，可以自定义。</li><li><code>192.168.1.100 6379</code> 是主节点的IP和端口。</li><li><code>2</code> 是投票同意将主节点标记为失效（fail）的最小哨兵数量。</li><li><code>down-after-milliseconds</code> 是多长时间后判定主节点为不可用。</li><li><code>failover-timeout</code> 是故障切换超时。</li><li><code>parallel-syncs</code> 是在故障转移期间允许同时与新的主节点同步的从节点数量。</li></ul></li><li>启动哨兵：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-sentinel /path/to/sentinel.conf<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-添加多个哨兵节点"><a href="#3-添加多个哨兵节点" class="headerlink" title="3. 添加多个哨兵节点"></a>3. <strong>添加多个哨兵节点</strong></h4><p>为了提高可靠性，通常会运行多个哨兵实例。每个哨兵监控相同的主节点和从节点，它们之间通过Gossip协议交换信息，以达成共识并进行主从切换。<br>你只需要复制<code>sentinel.conf</code>并修改<code>port</code>，然后启动多个哨兵。</p><h4 id="4-哨兵监控和自动故障转移"><a href="#4-哨兵监控和自动故障转移" class="headerlink" title="4. 哨兵监控和自动故障转移"></a>4. <strong>哨兵监控和自动故障转移</strong></h4><p>哨兵会不断监控主从节点的状态。当主节点不可用时，哨兵会通过<font color="#974806">选举机制</font>选择一个新的主节点（从现有的从节点中挑选），并通知其他从节点去复制新的主节点。此过程是自动的，客户端也可以通过哨兵获取新的主节点地址。</p><h2 id="哨兵模式的选举机制"><a href="#哨兵模式的选举机制" class="headerlink" title="哨兵模式的选举机制"></a>哨兵模式的选举机制</h2><p>在Redis哨兵（Sentinel）模式中，当主节点（master）发生故障时，哨兵通过选举机制将某个从节点（slave）提升为新的主节点。这个过程被称为<strong>故障转移（failover）</strong>，具体来说，哨兵按照一系列标准来确定哪个从节点应当被提升为主节点。</p><p>以下是哨兵如何选择从节点来提升为主节点的步骤和规则：</p><h3 id="哨兵选举从节点为新主节点的标准"><a href="#哨兵选举从节点为新主节点的标准" class="headerlink" title="哨兵选举从节点为新主节点的标准"></a>哨兵选举从节点为新主节点的标准</h3><ol><li><strong>可用性检查</strong><ul><li>哨兵首先确保某个从节点是<font color="#974806">在线并且可以正常通信的</font>。只有那些能够与哨兵正常交互的从节点才会被考虑作为新的主节点。</li></ul></li><li><strong>优先级（priority）</strong><ul><li>每个从节点有一个<code>replica-priority</code>参数，<font color="#974806">数值越小优先级越高</font>。在故障转移过程中，优先级高的从节点会优先被提升为主节点。</li><li>你可以在Redis从节点的配置文件中通过<code>replica-priority</code>参数配置其优先级。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">replica-priority 100<br></code></pre></td></tr></table></figure>一个优先级为<code>0</code>的从节点永远不会被提升为主节点。</li></ul></li><li><strong>复制偏移量（replication offset）</strong><ul><li><font color="#974806">如果多个从节点的优先级相同，哨兵会选择数据最完整的从节点，即复制偏移量最大的那个节点</font>。</li><li>复制偏移量是从节点成功复制主节点数据的进度，复制偏移量越大，说明该从节点的同步数据越接近最新状态。因此哨兵会优先选择数据同步最新的从节点。</li></ul></li><li><strong>从节点的“断开时间”</strong><ul><li>如果从节点的优先级和复制偏移量相同，哨兵会选择<font color="#974806">离主节点断开时间最短</font>的从节点进行提升。也就是说，哨兵会选择最近还保持着良好连接的从节点。</li></ul></li><li><strong>哨兵的随机选择</strong><ul><li>如果所有上述条件都相同，哨兵将会在满足条件的从节点中随机挑选一个作为新的主节点。</li></ul></li></ol><h2 id="故障转移的流程"><a href="#故障转移的流程" class="headerlink" title="故障转移的流程"></a>故障转移的流程</h2><ol><li><strong>主节点失效（Failover）检测</strong><ul><li>哨兵通过Gossip协议与其他哨兵进行通信，并监控主节点的健康状态。如果哨兵检测到主节点宕机，它会将该主节点标记为“<font color="#974806">主观失效</font>（Subjectively Down，简称SDOWN）”。</li><li>哨兵继续和其他哨兵进行信息交换，如果超过配置的哨兵数量（如<code>sentinel monitor mymaster &lt;IP&gt; &lt;port&gt; &lt;quorum&gt;</code>中的<code>quorum</code>值）达成一致，那么哨兵会将主节点标记为“<font color="#974806">客观失效</font>（Objectively Down，简称ODOWN）”，进入故障转移流程。</li></ul></li><li><strong>选择从节点</strong><ul><li>在主节点被标记为ODOWN后，哨兵会开始选举新的主节点，按照选举机制依次筛选合适的从节点。</li></ul></li><li><strong>提升从节点为主节点</strong><ul><li>哨兵一旦选定某个从节点作为新的主节点，它会发送命令将该从节点提升为新的主节点。这个从节点将开始接受客户端的读写请求。</li></ul></li><li><strong>通知其他从节点</strong><ul><li>哨兵会通知剩下的从节点更新它们的复制目标，从原来的主节点转而复制新的主节点。</li></ul></li><li><strong>通知客户端</strong><ul><li>故障转移完成后，哨兵会通知客户端新的主节点地址，客户端可以根据此信息更新连接目标。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】算法-堆</title>
    <link href="/2024/09/15/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E5%A0%86/"/>
    <url>/2024/09/15/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="堆-数据结构"><a href="#堆-数据结构" class="headerlink" title="堆 数据结构"></a>堆 数据结构</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/%E5%A0%86.svg" alt="堆.svg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapExp</span> &#123;  <br>    <span class="hljs-comment">// 比较器  </span><br>    <span class="hljs-keyword">static</span> Comparator&lt;Integer&gt; cmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;  <br>            <span class="hljs-keyword">return</span> o2 - o1;  <br>        &#125;  <br>    &#125;;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        Queue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();  <br>        minHeap.add(<span class="hljs-number">3</span>);  <br>        minHeap.add(<span class="hljs-number">1</span>);  <br>        minHeap.add(<span class="hljs-number">2</span>);  <br>        <span class="hljs-keyword">while</span> (!minHeap.isEmpty()) &#123;  <br>            System.out.println(minHeap.poll());  <br>        &#125;  <br>  <br>        Queue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);  <br>        maxHeap.add(<span class="hljs-number">3</span>);  <br>        maxHeap.add(<span class="hljs-number">1</span>);  <br>        maxHeap.add(<span class="hljs-number">2</span>);  <br>        <span class="hljs-keyword">while</span> (!maxHeap.isEmpty()) &#123;  <br>            System.out.println(maxHeap.poll());  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>自定义类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.width = width;  <br>        <span class="hljs-built_in">this</span>.height = height;  <br>    &#125;  <br>    <span class="hljs-type">int</span> width;  <br>    <span class="hljs-type">int</span> height;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">exp</span> &#123;  <br>    <span class="hljs-comment">// 自定义比较类，先比较长，再比较短  </span><br>    <span class="hljs-keyword">static</span> Comparator&lt;Node&gt; cmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Node&gt;() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Node o1, Node o2)</span> &#123;  <br>            <span class="hljs-keyword">if</span>(o1.width != o2.width)&#123;  <br>                <span class="hljs-keyword">return</span> o1.width - o2.width; <span class="hljs-comment">// 升序  </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                <span class="hljs-keyword">return</span> o2.height - o1.height; <span class="hljs-comment">// 降序  </span><br>            &#125;  <br>        &#125;  <br>    &#125;;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        Queue&lt;Node&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);  <br>        heap.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <br>        heap.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));  <br>        heap.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <br>        <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;  <br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> heap.poll();  <br>            System.out.println(node.width + <span class="hljs-string">&quot; &quot;</span> + node.height);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240915165752.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-comment">// 维持一个k大小的小顶堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k ;i++)&#123;<br>            q.add(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">// 如果要加入的数比堆顶小就不管，只加入比堆顶大的数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; q.peek())&#123;<br>                q.poll();<br>                q.add(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240915165822.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> Comparator&lt;<span class="hljs-type">int</span>[]&gt; cmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            count.put(num, count.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> entry.getValue();<br>            <span class="hljs-keyword">if</span>(q.size() &lt; k)&#123;<br>                q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, cnt&#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(cnt &gt; q.peek()[<span class="hljs-number">1</span>])&#123;<br>                    q.poll();<br>                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, cnt&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; k; i++)&#123;<br>            res[i] = q.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240915182349.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 两个堆，左边大顶堆存小于中位数的值，右边小顶堆存大于中位数的值</span><br><span class="hljs-comment">     * 当总数为奇数，则小顶堆的堆头就是中位数</span><br><span class="hljs-comment">     * 偶数时，两个堆的堆头平均数就是中位数</span><br><span class="hljs-comment">     */</span><br>    PriorityQueue&lt;Integer&gt; rq; <span class="hljs-comment">// 存右边大数</span><br>    PriorityQueue&lt;Integer&gt; lq; <span class="hljs-comment">// 存左边小数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        lq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(b-a)); <span class="hljs-comment">// 大顶堆</span><br>        rq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span>(lq.isEmpty() || num &lt;= lq.peek())&#123;<br>            lq.add(num);<br>            <span class="hljs-comment">// 如果左边元素大于右边元素个数+2，就需要调整</span><br>            <span class="hljs-keyword">if</span>(lq.size() &gt;= rq.size()+<span class="hljs-number">2</span>)&#123;<br>                rq.add(lq.poll());<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            rq.add(num);<br>            <span class="hljs-comment">// 右边元素数大于左边元素数需要调整</span><br>            <span class="hljs-keyword">if</span>(rq.size() &gt; lq.size())&#123;<br>                lq.add(rq.poll());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(lq.size() &gt; rq.size())&#123;<br>            <span class="hljs-keyword">return</span> lq.peek();<br>        &#125;<br>        <span class="hljs-keyword">return</span> (lq.peek()+rq.peek())/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】算法-图论</title>
    <link href="/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"/>
    <url>/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】算法-动态规划</title>
    <link href="/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】算法-字符串</title>
    <link href="/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】算法-树</title>
    <link href="/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E6%A0%91/"/>
    <url>/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】算法-链表</title>
    <link href="/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】消息重复消费问题解决方案</title>
    <link href="/2024/09/08/0924-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/08/0924-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>消息被重复消费是分布式消息系统中的常见问题，特别是在某些场景下消息的<strong>幂等性</strong>和<strong>准确性</strong>非常关键。常见的消息队列系统（如 Kafka、RabbitMQ、RocketMQ）都可能遇到消息重复消费的情况，通常是由于<font color="#974806">网络问题、消费者故障或者消息处理失败</font>等原因引起的。</p><p>防止消息被重复消费的策略主要有：</p><ol><li><strong>设计幂等的业务逻辑</strong>，确保重复操作不会产生副作用。</li><li><strong>手动ACK确认机制</strong>，在消费成功后显式确认消息。</li><li><strong>使用分布式锁或唯一消费标志</strong>，避免多消费者同时处理相同消息。</li><li><strong>消息去重机制</strong>，通过检查消息ID是否已经被处理过。</li><li><strong>分布式事务或本地事务消息</strong>，确保消息处理的原子性。</li><li><strong>使用幂等性表</strong>记录已处理的消息ID。</li><li><strong>利用消息队列的偏移量机制</strong>，确保消费进度的精确控制。</li></ol><h3 id="1-确保消息处理的幂等性"><a href="#1-确保消息处理的幂等性" class="headerlink" title="1. 确保消息处理的幂等性"></a>1. <strong>确保消息处理的幂等性</strong></h3><ul><li><strong>幂等性</strong>指的是无论某个操作执行多少次，结果都是相同的。在消息系统中，幂等性意味着同一条消息即使被重复消费多次，也不会造成副作用。</li></ul><pre><code class="hljs">**如何实现幂等性：**</code></pre><ul><li><strong>唯一标识</strong>：给每条消息分配一个唯一的ID（通常是由消息<font color="#974806">生产者生成</font>的，比如订单号、交易号等）。消费者在处理消息时，首先检查该消息的ID是否已经被处理过。</li><li><strong>去重记录</strong>：使用数据库、缓存或本地文件等存储已经处理过的消息ID，如果重复消费同一条消息，直接跳过处理。</li><li><strong>事务性操作</strong>：在对外部系统（如数据库、第三方服务）进行操作时，设计幂等的业务逻辑。例如，对于更新操作，可以使用<code>INSERT ... ON DUPLICATE KEY UPDATE</code>这样的SQL语句，确保重复操作不会影响业务结果。</li></ul><h3 id="2-消息消费确认机制"><a href="#2-消息消费确认机制" class="headerlink" title="2. 消息消费确认机制"></a>2. <strong>消息消费确认机制</strong></h3><p>   消息队列系统通常会提供消息确认机制，确保消息被可靠消费。<br>   <strong>常见的确认机制有以下几种：</strong><br>       <strong>ACK机制（手动确认）</strong>：消费者在成功处理完消息后，向消息队列发送确认（ACK），表示消息已成功消费。如果没有发送ACK，消息队列会将该消息认为未处理并重新投递给消费者。<br>       <strong>自动重试机制</strong>：如果消息消费失败（消费者异常或消费失败），消息队列系统会重新将该消息放回队列中，等待消费者重试。为了防止重复消费，可以结合幂等机制使用。</p><h3 id="3-使用分布式锁或唯一消费标志"><a href="#3-使用分布式锁或唯一消费标志" class="headerlink" title="3. 使用分布式锁或唯一消费标志"></a>3. <strong>使用分布式锁或唯一消费标志</strong></h3><p>   当消息的消费过程涉及多个步骤，或有多个消费者同时尝试处理同一条消息时，可以使用分布式锁来控制消息的唯一消费过程。</p><ul><li><strong>分布式锁</strong>：例如使用 Redis 或 Zookeeper 来实现分布式锁，<font color="#974806">在处理消息之前先获得锁，处理完消息后再释放锁</font>。这样可以确保同一条消息不会被多个消费者同时处理。</li><li><strong>唯一消费标志</strong>：在某些场景下，可以通过设置标志位（flag）或使用某种特定状态，确保同一条消息只被处理一次。这个标志可以存在数据库或者缓存中，每次消费前先检查该标志是否已被设置。</li></ul><h3 id="4-消息重复检测（去重机制）"><a href="#4-消息重复检测（去重机制）" class="headerlink" title="4. 消息重复检测（去重机制）"></a>4. <strong>消息重复检测（去重机制）</strong></h3><ul><li>在消费消息之前，检查该消息是否已经被处理过。可以使用<strong>Redis</strong>或<strong>数据库</strong>来存储已经消费的消息的唯一标识。如果发现消息的唯一ID已经存在，则跳过该消息，防止重复处理。<br> <strong>具体做法：</strong></li><li>每次处理消息时，将消息ID存入Redis或数据库，设定一个合理的过期时间。如果该ID已经存在，则认为消息已被处理，跳过当前处理过程。</li></ul><h3 id="5-利用分布式事务（两阶段提交-本地事务消息）"><a href="#5-利用分布式事务（两阶段提交-本地事务消息）" class="headerlink" title="5. 利用分布式事务（两阶段提交&#x2F;本地事务消息）"></a>5. <strong>利用分布式事务（两阶段提交&#x2F;本地事务消息）</strong></h3><p>   分布式系统中使用分布式事务来确保消息和操作的一致性，也可以防止重复消费。</p><ul><li><strong>两阶段提交</strong>：在事务性系统中，通过两阶段提交协议，保证消费者在处理完消息后，消息的消费和业务逻辑的执行在一个原子操作内完成。</li><li><strong>本地事务消息</strong>：一些消息队列系统提供本地事务消息支持（如 RocketMQ），消费者在处理消息的同时，会记录一个消费状态。如果消费过程失败，事务会回滚，消息也会被重新消费。这样可以确保消息处理和消息确认是原子性操作，避免了重复消费。</li></ul><h3 id="6-消息幂等性表"><a href="#6-消息幂等性表" class="headerlink" title="6. 消息幂等性表"></a>6. <strong>消息幂等性表</strong></h3><ul><li>使用一个<strong>幂等性表</strong>来记录每条消息的处理状态。每次消费消息时，先在数据库中查询该消息是否已经处理过，如果处理过就直接返回，否则执行消息的业务逻辑，并在成功处理后将该消息的ID插入到幂等性表中。</li><li>可以结合消息的唯一ID作为主键，确保每条消息只被处理一次。</li></ul><h3 id="7-消息有序性和消息偏移量"><a href="#7-消息有序性和消息偏移量" class="headerlink" title="7. 消息有序性和消息偏移量"></a>7. <strong>消息有序性和消息偏移量</strong></h3><p>   某些消息队列系统（如 Kafka）通过消息的<strong>偏移量（offset）</strong>来控制消费进度。通过在消费者端维护消费偏移量，可以确保每条消息只被消费一次，即使出现消费失败的情况，也可以通过重新设置偏移量来重新消费未处理的消息。<br>   <strong>具体做法：</strong></p><ul><li>消费者在消费每条消息后更新消费偏移量到外部存储中（如 Zookeeper、数据库）。如果消费者重启或者出错时，可以恢复到上一次处理的偏移量，从而避免消息丢失或重复消费。</li><li>同时，确保每个消费者在同一个分区上消费，以保证消息有序性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【读书】前方高能：硬核青年“开挂”手册</title>
    <link href="/2024/09/02/%E5%89%8D%E6%96%B9%E9%AB%98%E8%83%BD%EF%BC%9A%E7%A1%AC%E6%A0%B8%E9%9D%92%E5%B9%B4%E2%80%9C%E5%BC%80%E6%8C%82%E2%80%9D%E6%89%8B%E5%86%8C/"/>
    <url>/2024/09/02/%E5%89%8D%E6%96%B9%E9%AB%98%E8%83%BD%EF%BC%9A%E7%A1%AC%E6%A0%B8%E9%9D%92%E5%B9%B4%E2%80%9C%E5%BC%80%E6%8C%82%E2%80%9D%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 前方高能：硬核青年“开挂”手册</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/32/cpplatform_vzzodakttfkwbqgdyhxqw3/t7_cpplatform_vzzodakttfkwbqgdyhxqw31721717066.jpg" alt=" 前方高能：硬核青年“开挂”手册|200"></li><li>书名： 前方高能：硬核青年“开挂”手册</li><li>作者： 硬核的HeyMatt</li><li>简介： 为什么只有你苦哈哈地工作却得不到晋升，人生像是卡了壳？<br>为什么一遇到问题你就一筹莫展，仿佛被碾压的永远是自己？<br>为什么别人可以自由又发展，而你却永远在劳作，还一直很贫穷？<br>……<br>因为你还抱着固有的思维方式，人生像是老旧的系统，既没有更新也没有升级，就只能等着被换代……<br>本书围绕着提升个人影响力的认知，打破事业瓶颈，设计和监理自己的产品、事业模型等方面全方位打造硬核青年，助燃高效人生，创建属于你自己的高手模式！<br>书中提供了四种核心认知，突破和建立人生和事业版图，6大认知力，助燃高效思维模式。让每一个人都能快速地辨别出自己的人生系统BUG，并有效地找到升级的手段和方法。更配合了详细的案例解析，手把手地教你解决自己的问题。<br>拥有80多万粉丝的知识博主“硬核的 HeyMatt”，将自己所有的知识精髓，更有体系和逻辑地展现在本书中，助你成为新时代硬核青年！</li><li>出版时间 2024-07-23 00:00:00</li><li>ISBN： </li><li>分类： 个人成长-励志成长</li><li>出版社：</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="第一节-有效专注力"><a href="#第一节-有效专注力" class="headerlink" title="第一节 有效专注力"></a>第一节 有效专注力</h2><ul><li><p>📌 尊重他人与我在时间和空间中的不同命运，他人坠落或升起都不能影响我，他人与我是两条平行线，并行不悖，无须相交。 ^3300107527-5-3706-3760</p><ul><li>⏱ 2024-08-03 10:52:44</li></ul></li><li><p>📌 我为什么要了解A和B之间的事呢？我现在正在学习，难道我要因为A和B打起来了，就放下书、放下笔，走出学习的状态，转而去观察他们打架吗？我在观察他们争执的过程中并不能获得任何实质性的好处，即使在他们争吵结束后也是如此。 ^3300107527-5-4260-4367</p><ul><li>⏱ 2024-08-03 10:53:26</li></ul></li><li><p>📌 学习，其实就像做生意、学本领一样，有两个阶段。第一个阶段，叫作突破；第二个阶段，叫作优化。你现在要做的是有所突破，而不是优化。” ^3300107527-5-6937-7027</p><ul><li>⏱ 2024-08-03 18:18:40</li></ul></li></ul><h2 id="第二节-强大的心态"><a href="#第二节-强大的心态" class="headerlink" title="第二节 强大的心态"></a>第二节 强大的心态</h2><ul><li><p>📌 我会把不顺心当成A点，把我的反应当成B点，将A点和B点的距离拉长。我会对自己说：“A点与B点不必立刻碰撞，在它们相撞之前，我可以做一次深呼吸，进行一次合理的操作，从而拥有一个从容不迫的心境。” ^3300107527-6-1288-1384</p><ul><li>⏱ 2024-08-04 18:31:40</li></ul></li><li><p>📌 我经常问自己，我为什么要盯着黑暗之处？我为什么要把自己和那些消极的情绪捆绑在一起？我为什么要与烂人烂事拉扯，消磨自己的精力和时间？这都没必要。 ^3300107527-6-4848-4919</p><ul><li>⏱ 2024-08-05 18:04:30</li></ul></li><li><p>📌 我要吃饭、吃肉、吃菜，我不吃垃圾。我要向积极的人学习，看让自己受益的书，做有价值的事，将自己的专注力投射在明亮之处、积极之人、坦荡之事上。<br>我们只有把专注力投放到能实现的、有价值的事情上，才能成为自己的“贵人”。这时，其他所谓的“贵人”才会被我们吸引，观察我们，考验我们，帮助我们，投资我们。 ^3300107527-6-4948-5122</p><ul><li>⏱ 2024-08-05 18:04:43</li></ul></li><li><p>📌 这世上10个人遇到难事，9个都会慌乱，而真正的将才即使在心里没底的时候，仍能淡定自如、从容行事。 ^3300107527-6-6308-6356</p><ul><li>⏱ 2024-08-05 18:06:09</li></ul></li><li><p>📌 对于你很平静时都解决不了的问题，若你手忙脚乱，那更解决不了。 ^3300107527-6-6671-6701</p><ul><li>⏱ 2024-08-05 18:06:33</li></ul></li><li><p>📌 这世上很多人的痛苦源于总是期盼一个不合理的结果。他们明明能力不足，却不实事求是，不愿意接受合理的结果，所以经常会很痛苦 ^3300107527-6-7030-7089</p><ul><li>⏱ 2024-08-05 18:07:11</li></ul></li><li><p>📌 一旦选择了做某件事，从那一瞬间起，你就要承担做这件事的代价。不可能既占了便宜还无须付出代价。 ^3300107527-6-7961-8007</p><ul><li>⏱ 2024-08-05 18:08:25</li></ul></li><li><p>📌 为什么人类很容易产生负面情绪？很大的原因是就算好运气和坏运气的量一样，但是坏运气带给我们的负面情绪会多于好运气带来的正面情绪，并且坏运气叠加所产生的破坏力远远强于好运气叠加带来的愉悦感。 ^3300107527-6-9120-9213</p><ul><li>⏱ 2024-08-05 18:13:03</li></ul></li></ul><h2 id="第三节-清晰的思维"><a href="#第三节-清晰的思维" class="headerlink" title="第三节 清晰的思维"></a>第三节 清晰的思维</h2><ul><li><p>📌 我决定要做一件事，就能够把这件事做成”的执行力。在做这件事的过程中，我们会形成掌控感和平和的心境，凭借这种掌控感和平和的心境，我们有动力、有能力做得更多、更好。 ^3300107527-7-1208-1295</p><ul><li>⏱ 2024-08-05 18:15:01</li></ul></li><li><p>📌 我的畏难心态，让我主动回避了多数有价值的问题，所以我无法获得有效经验以增强我对人生规律的感知能力。也就是说，若把人生比作一场游戏，我一直在追求一种过于轻松的游玩方式：一直在游逛，无论大怪还是小怪都不打。 ^3300107527-7-1759-1860</p><ul><li>⏱ 2024-08-05 18:15:46</li></ul></li><li><p>📌 你会很耐心地观察社会规律，体察人性。你会思考：这个人为什么轻视别人，这种轻视的心理从何而来？这个人为什么心甘情愿地浪费大量时间和精力去做无效之事？这个人为什么情绪暴躁，总让身边的人远离他？ ^3300107527-7-3253-3347</p><ul><li>⏱ 2024-08-05 18:17:10</li></ul></li><li><p>📌 当你把自己当作一个外星人的时候，你就会更愿意去探索，去冷静观察。你会更有主观意愿去搜集信息，去增加自己对人类的认知，以一种更冷静、客观的角度，理解某个或某群人呈现出来的优点和缺点。 ^3300107527-7-3376-3466</p><ul><li>⏱ 2024-08-05 18:17:16</li></ul></li></ul><h2 id="第四节-高效社交"><a href="#第四节-高效社交" class="headerlink" title="第四节 高效社交"></a>第四节 高效社交</h2><ul><li><p>📌 我的游戏中，我是主角，其他人都是NPC。别人有别人固定的反应和台词，而我要做的，就是触发他们，通过他们的反应和台词来决定要不要深入交流。这样一来，整个过程就变得非常简单。 ^3300107527-8-2174-2259</p><ul><li>⏱ 2024-08-05 18:24:16</li></ul></li><li><p>📌 要对“正在经历匮乏的人”报以理解和谨慎的态度。 ^3300107527-8-3070-3093</p><ul><li>⏱ 2024-08-05 18:25:20</li></ul></li><li><p>📌 他们把自己定位为“情绪侦探”，多疑且焦虑——总纠结于别人表现出的情绪，从中推断是与非，并试图做出更多努力安抚别人的不良情绪。 ^3300107527-8-5225-5287</p><ul><li>⏱ 2024-08-05 18:32:32</li></ul></li><li><p>📌 第一，说话从容。说话的时候，要确保对方听到核心信息，不要因为紧张而给对方造成信息接收上的困扰。你如果紧张，语速很快，说得含糊不清，就会给对方造成压力，很容易让对方失去耐性。 ^3300107527-8-6299-6385</p><ul><li>⏱ 2024-08-05 18:34:33</li></ul></li></ul><h2 id="第一节-打碎思维枷锁"><a href="#第一节-打碎思维枷锁" class="headerlink" title="第一节 打碎思维枷锁"></a>第一节 打碎思维枷锁</h2><ul><li>📌 因为他会变得非常特别、非常稀缺，100个人中可能找不到1个跟他一样会思考如何服务大众并提供价值的人。 ^3300107527-10-1019-1069<ul><li>⏱ 2024-08-05 18:37:40</li></ul></li></ul><h2 id="第四节-事业心"><a href="#第四节-事业心" class="headerlink" title="第四节 事业心"></a>第四节 事业心</h2><ul><li><p>📌 学生思维，本质上是一种“我等待别人给我评判”的思维。 ^3300107527-13-994-1020</p><ul><li>⏱ 2024-08-05 18:59:44</li></ul></li><li><p>📌 拥有学生思维的人，总是在思考别人认为他怎么样。 ^3300107527-13-1111-1134</p><ul><li>⏱ 2024-08-05 19:00:06</li></ul></li><li><p>📌 就是典型的学生思维：受不了任何人对他的冷遇、嘲讽或意料之外的评价。 ^3300107527-13-1264-1297</p><ul><li>⏱ 2024-08-05 19:00:21</li></ul></li><li><p>📌 这就是求是思维：我不管你对我的评价如何，我也没法控制你的语言和思维，所以，我不会应激，而是会根据实际情况冷静地思考，让事情朝于我有利的方向发展。 ^3300107527-13-1560-1632</p><ul><li>⏱ 2024-08-05 19:00:58</li></ul></li><li><p>📌 拥有学生思维的人会对自己的能力和处境进行想象，一旦实际情况不符合这个想象，他就会应激，产生负面情绪，如沮丧、悲伤或愤怒。<br>拥有学生思维的人，情绪和状态起伏大，能决定他们情绪和状态的是别人的话、别人的反馈、别人的评价。有些时候，别人轻飘飘的一句话就能把他们的主观能动性降到最低，让他们再也提不起斗志。 ^3300107527-13-1668-1845</p><ul><li>⏱ 2024-08-05 19:01:15</li></ul></li><li><p>📌 拥有求是思维的人往往会思考：在现阶段，我到底要得到什么结果？围绕这个结果，我需要制定怎样的战略、战术、或进行怎样的资源配置？<br>所有决策都应尽量顺应我们想营造的阶段性终局，而不是与之相违背。 ^3300107527-13-1941-2063</p><ul><li>⏱ 2024-08-05 19:01:34</li></ul></li><li><p>📌 很多时候，他们更像含羞草，柔弱且非常容易应激。他们的心智带宽几乎被激动、兴奋、失落和伤心等情绪占满。更关键的是，他们的积极情绪、主观能动性都源于异性的滋养，即异性给他们投射的注意力。这些注意力就是他们的全部动力。 ^3300107527-13-2786-2892</p><ul><li>⏱ 2024-08-05 19:02:56</li></ul></li><li><p>📌 我就像躺在地面上的一张钞票。别人捡起我这张“钞票”，是正常行为；别人对我这张“钞票”不屑一顾，也无损我的价值。 ^3300107527-13-4180-4235</p><ul><li>⏱ 2024-08-05 21:52:21</li></ul></li></ul><h2 id="第六节-深度思考"><a href="#第六节-深度思考" class="headerlink" title="第六节 深度思考"></a>第六节 深度思考</h2><ul><li><p>📌 思考的痛感大体上分为两种：第一种是大脑运转带来的疲倦和不适，第二种是多次思考无果带来的习得性无助。 ^3300107527-21-718-767</p><ul><li>⏱ 2024-08-06 01:14:12</li></ul></li><li><p>📌 阅读，也能跟人际关系结合起来。两个用心读过同一本书的人，相当于跨越时间和空间做了一次认知上的深度交流。两个陌生人都深深喜欢同一本书，从本质上看，就是一种对彼此的认同。 ^3300107527-21-4468-4551</p><ul><li>⏱ 2024-08-06 01:18:57</li></ul></li><li><p>📌 我走进高考考场的那一刻就知道，自己要考好必须超常发挥，而考不好是非常合理的。对着一个合理的结果生闷气，是一种不理智的行为。 ^3300107527-21-6375-6436</p><ul><li>⏱ 2024-08-06 01:21:10</li></ul></li><li><p>📌 非常坦诚地说一句，所谓的高考失败，对多数人，包括我自己，都是一个合理的结果。它反映了我们对考试这个“游戏”的不专注、不擅长或不重视，仅此而已。它既不能代表我们笨，也不能代表我们弱，更不能代表我们“完蛋”了。它只是一个合理的结果。 ^3300107527-21-6561-6675</p><ul><li>⏱ 2024-08-06 01:21:24</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】垃圾回收</title>
    <link href="/2024/08/29/0924-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2024/08/29/0924-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.svg" alt="垃圾回收算法.svg"></p><h3 id="1-引用计数法-Reference-Counting"><a href="#1-引用计数法-Reference-Counting" class="headerlink" title="1. 引用计数法 (Reference Counting)"></a>1. <strong>引用计数法 (Reference Counting)</strong></h3><p>引用计数法是通过维护对象的引用计数来决定对象是否可以被回收的简单算法。<br>每个对象都会有一个计数器，记录它被引用的次数：</p><ul><li>当有一个新的引用指向该对象时，计数器加1；</li><li>当引用失效（比如引用被置为<code>null</code>）时，计数器减1；</li><li>当计数器为0时，说明该对象没有引用了，可以被回收。<br><strong>优点</strong>：</li><li>实现简单；</li><li>回收时间比较确定，可以即时回收。<br><strong>缺点</strong>：</li><li>无法处理<strong>循环引用</strong>的问题。如果两个对象互相引用，即使它们都不再被其他对象引用，计数器也不会变为0，从而不能被回收。</li></ul><h3 id="2-标记-清除算法-Mark-Sweep"><a href="#2-标记-清除算法-Mark-Sweep" class="headerlink" title="2. 标记-清除算法 (Mark-Sweep)"></a>2. <strong>标记-清除算法 (Mark-Sweep)</strong></h3><p>标记-清除算法是现代垃圾回收的基础，它分为<strong>标记</strong>和<strong>清除</strong>两个阶段：</p><ul><li><strong>标记阶段</strong>：从GC Roots（通常包括栈上的局部变量、静态变量等）出发，遍历所有可达的对象并打上标记；</li><li><strong>清除阶段</strong>：遍历整个堆，回收所有没有被标记的对象。<br><strong>优点</strong>：</li><li>可以有效处理循环引用；</li><li>实现相对简单。<br><strong>缺点</strong>：</li><li>由于堆中对象分布不均，清除后会产生<strong>内存碎片</strong>，可能导致后续的内存分配不连续，从而降低内存分配效率。</li></ul><h3 id="3-复制算法-Copying"><a href="#3-复制算法-Copying" class="headerlink" title="3. 复制算法 (Copying)"></a>3. <strong>复制算法 (Copying)</strong></h3><p>复制算法是将内存划分为两个相等的区域，每次只使用其中一个区域。当一个区域的内存使用完毕时，将存活的对象<strong>复制</strong>到另一个空的区域，然后清空当前使用的区域。<br><strong>优点</strong>：</p><ul><li>没有内存碎片问题；</li><li>回收过程中的内存分配非常高效，直接通过移动指针来分配新对象。<br><strong>缺点</strong>：</li><li>空间浪费严重，因为需要两块等大的内存区域，但实际存活的对象通常只占用较少的空间；</li><li>如果存活对象较多，复制操作的成本会很高。</li></ul><h3 id="4-标记-整理算法-Mark-Compact"><a href="#4-标记-整理算法-Mark-Compact" class="headerlink" title="4. 标记-整理算法 (Mark-Compact)"></a>4. <strong>标记-整理算法 (Mark-Compact)</strong></h3><p>标记-整理算法是<strong>标记-清除算法</strong>的改进版本，它也分为标记和清除两个阶段，但与标记-清除不同，<strong>标记-整理</strong>在标记完存活对象后，不直接清除内存，而是将存活的对象向一端<strong>压缩</strong>，使得所有存活的对象都紧挨在一起，最后再清理不再使用的对象。<br><strong>优点</strong>：</p><ul><li>同样没有内存碎片问题，内存分配效率较高。<br><strong>缺点</strong>：</li><li>需要额外的开销来移动对象（对象的引用也需要更新），回收速度较慢。</li></ul><h3 id="5-分代回收算法-Generational-Collection"><a href="#5-分代回收算法-Generational-Collection" class="headerlink" title="5. 分代回收算法 (Generational Collection)"></a>5. <strong>分代回收算法 (Generational Collection)</strong></h3><p>分代回收是基于对象生命周期特点的一种垃圾回收优化策略，Java堆通常被分为<strong>新生代</strong>和<strong>老年代</strong>：</p><ul><li><strong>新生代</strong>：大部分对象创建后很快变为垃圾，回收频繁使用<strong>复制算法</strong>。</li><li><strong>老年代</strong>：对象存活较长时间，垃圾回收使用<strong>标记-清除</strong>或<strong>标记-整理算法</strong>。<br>新生代的回收叫<strong>Minor GC</strong>，老年代的回收叫<strong>Major GC</strong>或<strong>Full GC</strong>。分代回收算法结合了复制算法和标记-整理算法的优点，根据不同代的对象存活率，选择合适的回收策略，从而提高效率。</li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.svg" alt="垃圾回收器.svg"><br>垃圾回收器是 Java 虚拟机用来自动管理内存的一部分。垃圾回收器通过自动识别和清理不再使用的对象，避免了手动释放内存的复杂性。Java 中有多种垃圾回收器，它们在不同的应用场景下各有优劣。</p><h3 id="1-Serial-Garbage-Collector（串行垃圾回收器）"><a href="#1-Serial-Garbage-Collector（串行垃圾回收器）" class="headerlink" title="1. Serial Garbage Collector（串行垃圾回收器）"></a>1. <strong>Serial Garbage Collector（串行垃圾回收器）</strong></h3><ul><li><strong>特性</strong>：单线程的垃圾回收器，在垃圾回收过程中会暂停所有应用线程（<strong>Stop The World</strong>）。</li><li><strong>适用场景</strong>：适用于单核 CPU 或小型应用，因其实现简单，性能在小内存或单核环境下表现良好。</li><li><strong>JVM参数</strong>：<code>-XX:+UseSerialGC</code></li><li><strong>工作方式</strong>：串行 GC 在新生代使用复制算法，在老年代使用标记-整理算法。</li></ul><h3 id="2-Parallel-Garbage-Collector（并行垃圾回收器）"><a href="#2-Parallel-Garbage-Collector（并行垃圾回收器）" class="headerlink" title="2. Parallel Garbage Collector（并行垃圾回收器）"></a>2. <strong>Parallel Garbage Collector（并行垃圾回收器）</strong></h3><ul><li><strong>特性</strong>：多线程的垃圾回收器，可以并行回收垃圾。仍然存在 Stop The World 事件，但多个垃圾回收线程可以同时工作，提升垃圾回收的吞吐量。</li><li><strong>适用场景</strong>：适用于多核 CPU 和对吞吐量要求高的应用，垃圾回收的暂停时间不是关键问题的场合。</li><li><strong>JVM参数</strong>：<code>-XX:+UseParallelGC</code> 或 <code>-XX:+UseParallelOldGC</code></li><li><strong>工作方式</strong>：新生代使用多线程的复制算法，老年代使用多线程的标记-整理算法。</li></ul><h3 id="3-CMS-Garbage-Collector（并发标记清除垃圾回收器）"><a href="#3-CMS-Garbage-Collector（并发标记清除垃圾回收器）" class="headerlink" title="3. CMS Garbage Collector（并发标记清除垃圾回收器）"></a>3. <strong>CMS Garbage Collector（并发标记清除垃圾回收器）</strong></h3><ul><li><strong>特性</strong>：以并发方式执行老年代垃圾回收，旨在减少老年代垃圾回收的暂停时间（<strong>低延迟</strong>），不完全停止应用线程的执行。</li><li><strong>适用场景</strong>：适用于响应时间要求高的应用，如 Web 服务器和需要快速响应的在线系统。</li><li><strong>JVM参数</strong>：<code>-XX:+UseConcMarkSweepGC</code></li><li><strong>工作方式</strong>：<ul><li><strong>初始标记阶段</strong>：短暂停止所有应用线程，标记根对象。</li><li><strong>并发标记阶段</strong>：不暂停应用线程，遍历所有可达对象。</li><li><strong>重新标记阶段</strong>：再次暂停应用线程，标记在并发标记阶段新产生的可达对象。</li><li><strong>并发清除阶段</strong>：不暂停应用线程，清除不可达对象。</li></ul></li><li><strong>缺点</strong>：由于不压缩堆空间，会造成内存碎片；回收不彻底，可能引发“Concurrent Mode Failure”，导致 Full GC。</li></ul><h3 id="4-G1-Garbage-Collector（Garbage-First-垃圾回收器）"><a href="#4-G1-Garbage-Collector（Garbage-First-垃圾回收器）" class="headerlink" title="4. G1 Garbage Collector（Garbage First 垃圾回收器）"></a>4. <strong>G1 Garbage Collector（Garbage First 垃圾回收器）</strong></h3><ul><li><strong>特性</strong>：适用于大堆内存应用，旨在提供<strong>可预测的暂停时间</strong>，通过分区管理内存并优先回收收益高的区域。</li><li><strong>适用场景</strong>：适用于多核 CPU 和大内存环境，特别适合需要低暂停时间的应用。</li><li><strong>JVM参数</strong>：<code>-XX:+UseG1GC</code></li><li><strong>工作方式</strong>：<ul><li>将堆划分为多个相同大小的区域（Region），新生代和老年代不再是物理上的连续空间，而是分散在不同的 Region 中。</li><li>G1采用了一种<strong>增量式回收</strong>方式，它并不总是进行全堆垃圾回收，而是根据当前内存占用和系统负载，优先选择“垃圾最多”的区域进行回收。这种优先回收垃圾最多区域的策略，就是<strong>Garbage First</strong>名称的由来。通过将回收过程切分为多个小的回收步骤，每次仅处理部分区域，G1能避免一次性回收整个堆所带来的长时间暂停。</li><li>除了常规的<strong>新生代GC</strong>（Minor GC），G1还引入了混合回收（Mixed GC）的概念。混合回收不仅回收新生代，还同时回收部分老年代的区域。它通过对堆中区域进行定期的整理和回收，防止老年代的堆内存持续增长，从而避免频繁的Full GC。</li></ul></li><li><strong>优点</strong>：适合大内存应用，能够更好地控制 GC 停顿时间。</li><li><strong>缺点</strong>：相比其他垃圾回收器，复杂性较高，且在一些极端情况下性能可能不稳定。</li><li>G1的设计目标是<strong>可预测的低延迟</strong>，并通过以下方式来实现对暂停时间的预测和控制：<br>- <strong>暂停时间目标</strong>：G1允许用户通过设置<code>-XX:MaxGCPauseMillis</code>来指定希望的最大垃圾回收暂停时间。这个参数告诉G1每次回收时应在多大程度上限制暂停时间。<br>- <strong>收集成本估算</strong>：G1垃圾回收器会在垃圾回收过程中根据历史数据估算每个区域的回收成本（即回收一个区域需要多长时间）。它通过实时监控系统性能，计算每次回收区域的时间，并以此来预测在给定的暂停时间目标内可以回收多少区域。<br>- <strong>区域选择策略</strong>：基于暂停时间目标，G1会选择那些<strong>回收成本较低</strong>且<strong>垃圾最多</strong>的区域进行回收。它通过将堆划分为多个小区域并对每个区域进行垃圾占比分析，优先回收那些预估可以在目标时间内处理完的区域。<br>- <strong>回收决策动态调整</strong>：G1动态调整其回收策略，使其能在垃圾回收过程中保持高效性和低延迟。具体来说，如果在一次垃圾回收中发现暂停时间接近或超出了目标暂停时间，G1将减少下次回收的区域数量，反之亦然。</li></ul><h3 id="5-ZGC（Z-Garbage-Collector）"><a href="#5-ZGC（Z-Garbage-Collector）" class="headerlink" title="5. ZGC（Z Garbage Collector）"></a>5. <strong>ZGC（Z Garbage Collector）</strong></h3><ul><li><strong>特性</strong>：传统垃圾回收器，如G1，在处理大型堆时，回收过程可能会带来较长的停顿时间。而ZGC的主要目标是通过<strong>并发回收</strong>和<strong>区域化管理</strong>实现低于10毫秒的暂停时间，甚至在堆内存非常大的情况下也能达到这个目标。</li><li><strong>适用场景</strong>：适用于对延迟敏感、需要大内存的应用，例如大数据处理、实时应用等。</li><li><strong>JVM参数</strong>：<code>-XX:+UseZGC</code></li><li><strong>工作方式</strong>：<ul><li><strong>区域化内存管理</strong>，与G1类似，ZGC也将堆内存划分为多个独立的内存区域（regions），这些区域的大小可以动态调整。每个区域可能包含活跃对象、垃圾对象或者空闲空间，ZGC可以根据需要选择回收这些区域，而不是全堆回收。</li><li>ZGC大部分垃圾回收工作都与应用线程<strong>并发执行</strong>，仅有少量工作会导致应用线程短暂暂停。具体来说，ZGC垃圾回收过程主要分为以下几个阶段：</li></ul><ol><li><strong>并发标记阶段</strong>：ZGC从GC Roots开始，并发标记存活对象，找到所有可达的对象。这部分操作不会暂停应用程序，大多数回收工作都是在应用程序继续运行的同时进行的。</li><li><strong>并发重定位（并发压缩）</strong>：ZGC在回收过程中会对存活对象进行<strong>并发重定位</strong>，即在应用程序运行期间，移动对象并更新指针引用。由于对象的移动和引用更新是并发的，ZGC不需要长时间暂停应用程序。<br>-  ZGC使用了一项名为<strong>读屏障</strong>（Load Barriers）的技术，这是一种轻量级的机制，允许在并发回收过程中安全地移动对象并更新其引用。当应用线程尝试读取一个对象的引用时，ZGC会通过读屏障来判断该引用是否已经被更新，如果对象已被移动，ZGC会自动修正指针指向新地址。这样可以在不影响应用程序正常运行的情况下进行对象的移动和压缩。<br>- ZGC采用了<strong>着色指针</strong>（Colored Pointers）技术，将GC状态信息嵌入对象引用的高位地址中。这样做的好处是避免了额外的数据结构（如传统的位图标记），从而加快了对象的标记、更新和回收。指针被“着色”后，ZGC可以通过分析对象引用的高位来确定该对象是否需要被移动、标记或处理。</li></ol></li><li><strong>优点</strong>：几乎能将暂停时间限制在非常小的范围（通常小于 10ms），即使在非常大的堆内存中也是如此。</li><li><strong>缺点</strong>：由于较为新颖，支持的 Java 版本较少，并且在一些场景下性能未必能优于 G1 或其他传统 GC。</li></ul><h3 id="6-Shenandoah-GC"><a href="#6-Shenandoah-GC" class="headerlink" title="6. Shenandoah GC"></a>6. <strong>Shenandoah GC</strong></h3><ul><li><strong>特性</strong>：和 ZGC 类似，也是一个低延迟的垃圾回收器，目标是实现堆的大小与 GC 停顿时间无关，停顿时间保持在短时间内（通常在 10ms 左右）。</li><li><strong>适用场景</strong>：适用于大堆内存和低延迟应用，与 ZGC 类似。</li><li><strong>JVM参数</strong>：<code>-XX:+UseShenandoahGC</code></li><li><strong>工作方式</strong>：Shenandoah GC 通过并发压缩内存来减少 Stop The World 的时间，它的核心技术是并发压缩堆空间，在并发清理和回收过程中，不会造成长时间的暂停。</li><li><strong>优点</strong>：可以在大内存应用中保持较低的暂停时间。</li><li><strong>缺点</strong>：和 ZGC 一样，由于其新颖性，目前支持的 JVM 版本相对较少。</li></ul><h3 id="7-Epsilon-Garbage-Collector（No-Op-GC）"><a href="#7-Epsilon-Garbage-Collector（No-Op-GC）" class="headerlink" title="7. Epsilon Garbage Collector（No-Op GC）"></a>7. <strong>Epsilon Garbage Collector（No-Op GC）</strong></h3><ul><li><strong>特性</strong>：一个“空”垃圾回收器，即不执行任何垃圾回收操作，主要用于性能测试或特殊用途的应用。</li><li><strong>适用场景</strong>：适用于需要进行 GC 性能测试或者一些内存使用受限的应用。</li><li><strong>JVM参数</strong>：<code>-XX:+UseEpsilonGC</code></li><li><strong>工作方式</strong>：不进行任何垃圾回收，只允许程序运行到内存耗尽为止。</li></ul><h3 id="垃圾回收器选择策略"><a href="#垃圾回收器选择策略" class="headerlink" title="垃圾回收器选择策略"></a>垃圾回收器选择策略</h3><ul><li><strong>单线程小型应用</strong>：可以使用 <code>Serial GC</code>，因为它的实现简单且在小型环境中表现良好。</li><li><strong>吞吐量优先</strong>：对于 CPU 密集型、大量批处理任务的应用，<code>Parallel GC</code> 是不错的选择，它的多线程垃圾回收可以最大化吞吐量。</li><li><strong>低延迟要求</strong>：如果应用对延迟非常敏感，比如在线服务、金融系统等，<code>CMS</code> 或 <code>G1 GC</code> 可以提供较低的暂停时间。对于更高的延迟敏感性，<code>ZGC</code> 或 <code>Shenandoah</code> 是更好的选择。</li><li><strong>大内存和超低延迟</strong>：对于需要 TB 级别内存且对暂停时间有极高要求的场景，<code>ZGC</code> 和 <code>Shenandoah</code> 是首选。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【教程】开机内存高怎么办</title>
    <link href="/2024/05/14/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91%E5%86%85%E5%AD%98%E9%AB%98/"/>
    <url>/2024/05/14/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91%E5%86%85%E5%AD%98%E9%AB%98/</url>
    
    <content type="html"><![CDATA[<p>刚开电脑就发现内存使用率很高，真是能到40%-50%，这是32G内存啊，查了一下找到一个方案是可行的：<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240915121816.png" alt="image.png"></p><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240915121924.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【胡思】抖音带货抢购系统</title>
    <link href="/2024/05/01/0924-%E8%83%A1%E6%80%9D%20%E7%9B%B4%E6%92%AD%E9%97%B4%E5%B0%8F%E9%BB%84%E8%BD%A6%E6%8A%A2%E8%B4%AD%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/05/01/0924-%E8%83%A1%E6%80%9D%20%E7%9B%B4%E6%92%AD%E9%97%B4%E5%B0%8F%E9%BB%84%E8%BD%A6%E6%8A%A2%E8%B4%AD%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>抖音带货能在几分钟之内甚至几秒之内卖出上万单，这是如何做到的，羡慕主播赚大钱的同时也在想这背后的系统是怎么设计的。虽然并发没有特别大，但是设计到短时间内大量付费，对安全性和稳定性要求很高的。</p><h3 id="一、系统整体架构设计"><a href="#一、系统整体架构设计" class="headerlink" title="一、系统整体架构设计"></a>一、系统整体架构设计</h3><ol><li><strong>CDN 边缘节点缓存</strong>：<ul><li><strong>直播流媒体分发</strong>：使用 CDN（内容分发网络）缓存直播内容，确保直播视频流的低延迟、高可用。通过将视频流分发到全球的 CDN 节点，可以有效降低中心服务器的压力，确保大量用户同时观看时系统不会崩溃。</li><li><strong>静态资源缓存</strong>：小黄车页面的静态资源（如图片、JS、CSS等）也可以预先缓存在 CDN 节点上，以减少对源服务器的访问压力。</li></ul></li><li><strong>前端限流与页面优化</strong>：<ul><li><strong>静态页面预渲染</strong>：直播间的小黄车页面可以通过静态化处理，在活动开始前提前生成静态页面，并尽可能减少页面上的动态请求。用户进入直播间时，直接访问CDN加速的静态页面，降低对后端的压力。</li><li><strong>活动倒计时本地化</strong>：用户进入小黄车页面时，将小黄车的开始时间直接推送给用户的前端，通过本地计算倒计时，避免大量用户频繁请求服务器。</li><li><strong>按钮灰度控制</strong>：小黄车按钮在活动未开始前可以设置为不可点击状态，避免小黄车开始前的无效请求。</li></ul></li><li><strong>网关层限流与防刷</strong><ul><li><strong>网关限流</strong>：通过 API 网关层对用户的请求进行限流和防刷，比如每秒钟只允许某个 IP 发送有限的请求，防止恶意请求和DDOS攻击。</li><li><strong>Token 验证机制</strong>：在小黄车活动开始前，可以通过预分发小黄车 Token 来对请求进行限流。用户需要先获取一个限量的小黄车 Token，只有持有 Token 的用户才能参与小黄车，有效地将大部分用户拦截在外。</li></ul></li><li><strong>缓存系统加速与减压</strong>：<ul><li><strong>Redis 缓存</strong>：小黄车核心逻辑的数据（如商品库存、用户资格）可以通过 Redis 缓存来加速读取，减少对数据库的压力。</li><li><strong>令牌桶限流</strong>：在小黄车商品抢购时，利用 Redis 的 Lua 脚本实现分布式锁和原子操作。可以将商品的库存数据缓存在 Redis 中，并通过 Redis 的原子操作来保证并发安全性，防止超卖。</li><li><strong>队列化处理</strong>：使用消息队列（如 Kafka、RabbitMQ）将用户请求异步化处理。所有的小黄车请求可以被写入一个队列中，然后按照顺序异步处理，削峰填谷，减少瞬时的高并发请求对系统的冲击。</li></ul></li><li><strong>应用层水平扩展</strong>：<ul><li><strong>负载均衡</strong>：在网关层和应用服务器层使用负载均衡（如 Nginx、HAProxy）进行流量分发，将用户请求合理分散到多台应用服务器上进行处理，确保系统的高可用性。</li><li><strong>多实例部署</strong>：通过 Kubernetes 等容器编排工具，使用水平扩展方式动态增加应用实例，扩展应用服务器的处理能力。</li></ul></li><li><strong>数据库层优化</strong>：<ul><li><strong>读写分离</strong>：通过主从数据库架构，将写操作集中在主库，而读操作分发到从库上进行，减轻数据库的压力。</li><li><strong>数据分片与分库分表</strong>：对小黄车业务中的核心数据（如订单、商品、用户）进行分库分表处理，避免单库单表在高并发下成为瓶颈。可以根据用户ID、商品ID等进行分片处理，将数据分散存储在多个数据库节点上。</li><li><strong>去中心化的库存扣减</strong>：在大规模小黄车场景下，避免频繁更新数据库库存。可以在 Redis 中设置分布式锁或者使用队列，先在缓存中进行库存扣减，然后再异步更新数据库。</li></ul></li><li><strong>消息队列与异步任务处理</strong>：<ul><li><strong>消息队列（Kafka、RabbitMQ）</strong>：用户的小黄车请求在被接收后，通过消息队列异步处理，确保后端能够以较为平稳的速度处理请求，防止瞬时并发量过大导致系统崩溃。</li><li><strong>异步处理订单</strong>：小黄车过程中，用户下单后可以立即给用户一个响应，但实际的订单处理和库存确认可以通过异步任务去执行。</li></ul></li></ol><h3 id="二、关键技术点分析"><a href="#二、关键技术点分析" class="headerlink" title="二、关键技术点分析"></a>二、关键技术点分析</h3><ol><li><strong>小黄车资格预热与Token机制</strong>：<ul><li>在小黄车开始之前，系统可以提前生成一定数量的小黄车Token，并将这些Token分配给参与小黄车的用户。当小黄车开始时，只有持有Token的用户才允许提交小黄车请求。这样可以大幅减少小黄车开始时的流量高峰，限制无效请求进入系统。</li></ul></li><li><strong>库存扣减的并发控制</strong>：<ul><li><strong>Redis 分布式锁与 Lua 脚本</strong>：可以使用 Redis 实现原子性的库存扣减操作，通过 Lua 脚本确保库存扣减和库存校验操作是一个原子操作，避免多用户并发抢购时导致库存超卖。</li><li><strong>最终一致性</strong>：小黄车中可能会出现订单未支付的情况，导致实际库存与数据库不一致。可以通过异步任务定期检查未支付的订单，进行库存回补，确保最终的一致性。</li></ul></li><li><strong>订单的幂等性控制</strong>：<ul><li>在高并发场景下，用户可能重复发起小黄车请求或重复提交订单。为了防止重复创建订单，可以为每个用户生成唯一的小黄车订单ID，并在用户提交订单时，进行幂等性检查，确保每个用户只能创建一个有效订单。</li></ul></li><li><strong>小黄车结果异步通知</strong>：<ul><li>在小黄车操作中，用户提交小黄车请求后，可以立即返回一个“排队中”或“处理中”的状态，避免用户等待的超时问题。最终的小黄车结果可以通过异步通知（如 WebSocket、消息推送、短信通知等）告知用户。</li></ul></li><li><strong>商品限购与用户验证</strong>：<ul><li>为了防止恶意用户或机器人大量下单，可以对小黄车商品进行限购（每个用户只能抢购一个商品），并结合用户的身份验证机制（如手机验证码、图形验证码）来确保小黄车的公平性。</li></ul></li><li><strong>流量削峰填谷</strong>：<ul><li>小黄车活动开始时，瞬时并发量巨大，可以使用<strong>流量削峰</strong>技术，将用户请求写入队列中按序处理，防止瞬时流量过高压垮后端系统。通过限流、排队等手段，确保请求进入系统的速度可控。</li></ul></li><li><strong>监控与报警</strong>：<ul><li>实时监控系统的各个组件（如数据库、缓存、应用服务器）的运行情况，及时发现性能瓶颈或故障。可以使用 Prometheus + Grafana 这样的监控工具，配合日志分析（如 ELK 堆栈）进行实时报警。</li></ul></li></ol><h3 id="三、具体流程示例"><a href="#三、具体流程示例" class="headerlink" title="三、具体流程示例"></a>三、具体流程示例</h3><p>假设我们要设计一个包含<strong>大量用户并发</strong>的小黄车流程，具体流程如下：</p><ol><li><strong>用户准备阶段</strong>：<ul><li>用户在直播间看到小黄车活动，系统通过 CDN 分发小黄车页面，前端倒计时。</li><li>小黄车活动前预生成小黄车 Token，只有持有 Token 的用户才可以参与小黄车，Token 可以通过提前活动发放或抽奖获得。</li></ul></li><li><strong>小黄车请求处理</strong>：<ul><li>小黄车开始后，用户的请求首先经过 API 网关层进行限流，确保每秒进入系统的请求量在可控范围内。</li><li>用户提交小黄车请求时，首先校验小黄车 Token，合格的请求进入 Redis 缓存进行库存扣减。</li><li>Redis 使用 Lua 脚本确保库存扣减的原子性，只有库存充足的用户才会进入下一步订单生成流程。</li></ul></li><li><strong>订单生成与异步处理</strong>：<ul><li>库存扣减成功的用户进入消息队列，系统以异步方式创建订单，确保高并发下系统不会被过多订单请求压垮。</li><li>用户提交订单后立即返回“排队中”的状态，订单的生成与支付通过异步任务完成。</li></ul></li><li><strong>支付与库存回补</strong>：<ul><li>用户成功提交订单后，需要在一定时间内完成支付。如果用户未能在规定时间内支付，订单自动取消，库存回补。</li></ul></li><li><strong>小黄车结果通知</strong>：<ul><li>小黄车成功或失败的结果可以通过 WebSocket 或消息推送实时通知用户，确保用户及时得到小黄车结果。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>胡思</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】MVCC</title>
    <link href="/2024/02/14/0919-MVCC/"/>
    <url>/2024/02/14/0919-MVCC/</url>
    
    <content type="html"><![CDATA[<p><strong>MVCC</strong>（Multi-Version Concurrency Control，多版本并发控制）是一种数据库并发控制机制，它允许多个事务同时读取数据库中的数据，而不会因为写操作而阻塞读操作。这种机制通过为每个事务提供数据的不同版本，来避免并发事务之间的冲突，提供更高的并发性能。MVCC 在很多现代数据库系统中都有应用，比如 MySQL 的 InnoDB 存储引擎、PostgreSQL 等。</p><h3 id="MVCC-的基本概念"><a href="#MVCC-的基本概念" class="headerlink" title="MVCC 的基本概念"></a>MVCC 的基本概念</h3><p>MVCC 的核心思想是通过<font color="#f79646">维护数据的多个版本，实现事务的隔离性</font>。每当一个事务修改数据时，数据库不会直接覆盖原始数据，而是创建该数据的新版本，并将其与当前的事务隔离级别关联。读操作则会根据事务的开始时间或其他标识符，读取合适版本的数据。</p><h3 id="1-快照读（Snapshot-Read）和当前读（Current-Read）"><a href="#1-快照读（Snapshot-Read）和当前读（Current-Read）" class="headerlink" title="1. 快照读（Snapshot Read）和当前读（Current Read）"></a>1. <strong>快照读（Snapshot Read）和当前读（Current Read）</strong></h3><ul><li><strong>快照读</strong>：读取数据的旧版本。这意味着在读操作时，事务会看到<font color="#f79646">在其开始时刻存在的版本</font>，而不会看到其他事务在其开始之后的更改。这样，快照读不会因为并发写操作而被阻塞，能够提供一致性的读视图。</li><li><strong>当前读</strong>：读取数据的<font color="#f79646">最新版本</font>。这种读操作通常与更新操作一起使用，事务会读取最新的版本，并可能对其进行修改。</li></ul><h3 id="2-版本链"><a href="#2-版本链" class="headerlink" title="2. 版本链"></a>2. <strong>版本链</strong></h3><p>数据库中的每条记录在 MVCC 下可能会有多个版本，这些版本会通过一个链表连接起来。每个版本都包含以下两个主要字段：</p><ul><li><strong>事务 ID</strong>：记录哪个事务创建了这个版本，或者哪个事务删除了这个版本。</li><li><strong>指向下一个版本的指针</strong>：指向前一个版本（或后一个版本），形成一个版本链。<br>当读操作发生时，数据库系统会遍历版本链，找到与当前事务最匹配的那个版本（即在事务开始时可见的版本）。</li></ul><h3 id="3-事务的可见性规则"><a href="#3-事务的可见性规则" class="headerlink" title="3. 事务的可见性规则"></a>3. <strong>事务的可见性规则</strong></h3><p>为了决定事务在读取数据时应该看到哪个版本的记录，MVCC 机制会根据事务的隔离级别和事务 ID 进行判断。一般来说：</p><ul><li><strong>读未提交（Read Uncommitted）</strong>：事务<font color="#f79646">可以看到其他未提交事务的修改</font>，不常与 MVCC 配合使用。</li><li><strong>读已提交（Read Committed）</strong>：事务<font color="#f79646">只能看到已经提交的事务的修改</font>。每次查询都会看到最新提交的数据版本。</li><li><strong>可重复读（Repeatable Read）</strong>：事务在其整个生命周期内<font color="#f79646">只能看到事务开始时存在的版本</font>。其他事务的提交对其不可见，因此相同的查询在同一个事务中会返回相同的数据。</li><li><strong>序列化（Serializable）</strong>：最高的隔离级别，事务<font color="#f79646">不仅看到自己的快照，而且禁止其他事务在其结束前对相关数据进行写操作</font>，避免了幻读现象。</li></ul><h3 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4. 垃圾回收"></a>4. <strong>垃圾回收</strong></h3><p>随着时间推移，数据库中的版本链会越来越长，因此需要机制来清理不再需要的旧版本。这个过程通常称为垃圾回收。数据库系统会定期检查版本链，删除已经不再需要的旧版本，以释放存储空间。</p><h3 id="5-MVCC-的优点"><a href="#5-MVCC-的优点" class="headerlink" title="5. MVCC 的优点"></a>5. <strong>MVCC 的优点</strong></h3><ul><li><strong>高并发性能</strong>：通过<font color="#f79646">避免加锁</font>，MVCC 可以同时处理大量并发读操作，减少读写之间的冲突。</li><li><strong>减少锁争用</strong>：读操作不需要等待写操作完成，因此避免了锁争用带来的性能瓶颈。</li><li><strong>实现更强的隔离性</strong>：特别是在可重复读和序列化隔离级别下，MVCC 可以有效避免脏读、不可重复读和幻读问题。</li></ul><h3 id="6-MVCC-的缺点"><a href="#6-MVCC-的缺点" class="headerlink" title="6. MVCC 的缺点"></a>6. <strong>MVCC 的缺点</strong></h3><ul><li><strong>存储开销</strong>：维护多个版本的记录需要额外的存储空间，而且需要有效的垃圾回收机制来管理旧版本。</li><li><strong>实现复杂性</strong>：MVCC 的实现比传统的锁机制更复杂，尤其是在处理事务冲突和回滚时。</li><li><strong>延迟问题</strong>：在某些情况下，长时间的事务可能导致版本链过长，从而增加读操作的开销。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】OOM怎么办</title>
    <link href="/2024/02/14/0919-OOM%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/02/14/0919-OOM%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>在项目开发过程中，如果遇到 <code>OutOfMemoryError</code>，说明程序在运行过程中使用的内存超出了 JVM 分配给它的最大内存限制。解决 OOM 问题需要分析内存的使用情况，找出内存泄漏或不必要的内存占用，并进行优化。以下是处理 OOM 问题的常见步骤和方法：</p><h3 id="1-分析日志和错误信息"><a href="#1-分析日志和错误信息" class="headerlink" title="1. 分析日志和错误信息"></a>1. 分析日志和错误信息</h3><p>首先，查看日志文件和错误信息，了解 OOM 发生的具体位置和场景。通常，JVM 会在 OOM 发生时生成堆转储（Heap Dump）文件，该文件记录了当时的内存使用情况，可以帮助你找到内存占用的热点和可能的内存泄漏。<br><font color="#c00000">如何查看dump文件</font></p><h3 id="2-增加-JVM-内存"><a href="#2-增加-JVM-内存" class="headerlink" title="2. 增加 JVM 内存"></a>2. 增加 JVM 内存</h3><p>如果内存不足是由于程序需要更多的内存而不是内存泄漏引起的，可以考虑增加 JVM 的堆内存分配。</p><p>可以通过修改 JVM 启动参数来增加堆内存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xms512m -Xmx1024m -jar myapp.jar<br></code></pre></td></tr></table></figure><ul><li><code>-Xms</code>：设置初始堆内存大小</li><li><code>-Xmx</code>：设置最大堆内存大小<br>不过，增加内存只能缓解问题，不能从根本上解决 OOM 问题，尤其是内存泄漏。</li></ul><h3 id="3-使用分析工具（Heap-Dump-分析）"><a href="#3-使用分析工具（Heap-Dump-分析）" class="headerlink" title="3. 使用分析工具（Heap Dump 分析）"></a>3. 使用分析工具（Heap Dump 分析）</h3><p>使用分析工具来检查堆转储文件是找出 OOM 根源的关键。常用的分析工具包括：</p><ul><li>**Eclipse MAT (Memory Analyzer Tool)**：可以用来分析内存泄漏和找到内存占用较大的对象。</li><li><strong>VisualVM</strong>：Java 自带的工具，可以实时监控内存使用情况，还可以生成和分析 Heap Dump。</li><li><strong>JProfiler、YourKit</strong>：商业化的性能分析工具，功能更强大，适合深度分析内存问题。<br>通过这些工具，你可以查看哪些对象占用了大量内存，是否有未被正确释放的对象，从而找出内存泄漏或不必要的大对象。</li></ul><h3 id="4-查找和修复内存泄漏"><a href="#4-查找和修复内存泄漏" class="headerlink" title="4. 查找和修复内存泄漏"></a>4. 查找和修复内存泄漏</h3><p>内存泄漏是指程序中的对象本应该被回收，但由于某种原因仍然被引用，导致不能被垃圾回收清除。常见的内存泄漏场景包括：</p><ul><li><strong>静态集合（Static Collection）</strong>：静态变量的生命周期与应用程序相同，如果将对象放入静态集合中，这些对象可能永远不会被回收。</li><li><strong>缓存（Cache）</strong>：如果缓存策略不当，比如没有合理的淘汰策略，缓存中的对象会一直占用内存。</li><li><strong>事件监听器和回调</strong>：未正确移除的<font color="#c00000">监听器或回调函数</font>引用会导致对象无法被 GC 回收。</li><li><strong>大对象的重复创建</strong>：比如某个方法中频繁创建大数组或字符串，可能导致短时间内大量内存被占用。</li></ul><p>找到内存泄漏后，需要检查代码逻辑，确保不再引用那些应该被回收的对象，或者<font color="#c00000">采用弱引用</font>（<code>WeakReference</code>）等方式来避免内存泄漏。</p><h3 id="5-优化内存使用"><a href="#5-优化内存使用" class="headerlink" title="5. 优化内存使用"></a>5. 优化内存使用</h3><p>有时，OOM 不是由内存泄漏引起的，而是程序的内存使用方式需要优化。可以通过以下方式优化：</p><ul><li><strong>减少对象的生命周期</strong>：尽量减少对象的生命周期，及时将不再使用的对象置为 <code>null</code>，让 GC 回收。</li><li><strong>优化数据结构</strong>：选择合适的数据结构，比如使用 <code>ArrayList</code> 而不是 <code>LinkedList</code>，使用 <code>StringBuilder</code> 而不是频繁地连接字符串。</li><li><strong>使用更小的对象</strong>：如果某个对象占用了大量内存，看看是否可以通过拆分或简化来减少内存占用。</li><li><strong>懒加载</strong>：如果某些对象不一定每次都需要加载，可以考虑懒加载（Lazy Loading），在真正需要时再创建对象。</li></ul><h3 id="6-监控和预防"><a href="#6-监控和预防" class="headerlink" title="6. 监控和预防"></a>6. 监控和预防</h3><p>最后，建议在开发和测试阶段就进行内存监控，及时发现内存使用异常：</p><ul><li><strong>设置 JVM 参数</strong>：可以在启动参数中设置 <code>-XX:+HeapDumpOnOutOfMemoryError</code>，当 OOM 发生时自动生成 Heap Dump，方便事后分析。</li><li><strong>定期进行性能测试</strong>：使用压力测试工具（如 JMeter）来模拟高负载，提前发现潜在的内存问题。</li><li><strong>监控工具</strong>：使用 Prometheus、Grafana 等工具实时监控内存使用，设置告警机制。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【数据库】Redis的持久化</title>
    <link href="/2024/02/14/0919-Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2024/02/14/0919-Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Redis 提供了两种主要的持久化机制：RDB（Redis Database Backup）和 AOF（Append Only File）。</p><h3 id="1-RDB实现原理："><a href="#1-RDB实现原理：" class="headerlink" title="1. RDB实现原理："></a>1. <strong>RDB实现原理</strong>：</h3><p>RDB 通过<font color="#f79646">快照</font>的方式来持久化数据，具体来说，它会定期将内存中的数据生成一个快照（dump），保存到一个二进制文件（通常是 <code>dump.rdb</code>）。这个文件包含了 Redis 在某个时间点上的所有数据。</p><h4 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h4><ul><li>Redis 会按照配置的时间间隔（或者手动触发）生成快照，创建内存数据的副本，并将它写入到磁盘上的 RDB 文件中。</li><li>在生成快照的过程中，Redis 可以通过 <code>fork()</code> 创建子进程，子进程负责将数据写入磁盘，而主进程继续处理客户端请求。因此快照操作不会阻塞 Redis 的主线程。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>数据文件紧凑</strong>：RDB 是二进制格式的，文件相对较小，而且容易备份和传输。</li><li><strong>适合备份</strong>：由于它是定期生成的快照，非常适合定期备份数据。如果你不需要对数据进行非常频繁的持久化，RDB 会是一个不错的选择。</li><li><strong>恢复速度快</strong>：因为 RDB 文件体积较小，Redis 从 RDB 文件恢复数据的速度很快。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>数据丢失风险较高</strong>：RDB 只在特定的时间间隔生成快照，如果 Redis 崩溃或意外关闭，可能会丢失最近一次快照之后的所有数据。例如，如果你设置每 5 分钟生成一次 RDB 文件，那么 Redis 崩溃后，最多会丢失 5 分钟的数据。</li><li><strong>生成快照会占用性能</strong>：虽然 Redis 使用子进程生成快照，但在内存非常大的情况下，创建快照和写入磁盘的过程仍可能消耗较多系统资源。</li></ul><hr><h3 id="2-AOF实现原理："><a href="#2-AOF实现原理：" class="headerlink" title="2. AOF实现原理："></a>2. <strong>AOF实现原理</strong>：</h3><p>AOF 通过记录每次写操作的日志来实现持久化。它将每一次对 Redis 数据的写操作（如 <code>SET</code>、<code>INCR</code> 等）都以日志的方式追加到 AOF 文件中，从而确保每一个操作都被记录下来。</p><h4 id="实现过程：-1"><a href="#实现过程：-1" class="headerlink" title="实现过程："></a>实现过程：</h4><ul><li>每当 Redis 执行一个修改数据的命令时，都会将这个命令追加到 AOF 文件中。AOF 文件可以认为是一个命令的历史记录。</li><li>Redis 提供了三种不同的写入策略（通过 <code>appendfsync</code> 参数控制）：<code>always</code>（每次操作都同步写入磁盘）、<code>everysec</code>（每秒将数据写入磁盘）、<code>no</code>（由操作系统自行决定何时写入磁盘）。</li><li>为了防止 AOF 文件变得过大，Redis 支持文件重写（rewrite），它会定期对 AOF 文件进行压缩，删除冗余的命令，将其变得更简洁。</li></ul><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>数据安全性高</strong>：AOF 可以配置为每次操作都写入日志，最大程度地保证数据安全，即使 Redis 崩溃，恢复后也能保留几乎所有的数据。</li><li><strong>灵活的持久化策略</strong>：你可以选择根据系统负载来决定是每秒同步一次还是每次写操作都同步，灵活性较高。</li><li><strong>AOF 更易读</strong>：AOF 文件是一个按顺序记录的命令日志，即使是手动编辑，也比较容易理解。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>文件体积大</strong>：由于每次写操作都要记录，因此 AOF 文件可能比 RDB 文件大得多，特别是当数据写入频繁时。</li><li><strong>恢复速度较慢</strong>：AOF 文件需要重放每一个写操作，恢复速度会比从 RDB 文件恢复要慢，尤其是当 AOF 文件非常大时。</li><li><strong>性能开销</strong>：如果配置为 <code>appendfsync always</code>，每次写操作都同步到磁盘，会对 Redis 性能产生较大影响。即使是每秒写入的策略，在高并发的场景下，也可能增加系统的 I&#x2F;O 负担。</li></ul><hr><h3 id="3-RDB-与-AOF-的比较："><a href="#3-RDB-与-AOF-的比较：" class="headerlink" title="3. RDB 与 AOF 的比较："></a>3. <strong>RDB 与 AOF 的比较</strong>：</h3><table><thead><tr><th align="center">特性</th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center"><strong>持久化方式</strong></td><td align="center">定期快照，将整个内存生成副本</td><td align="center">日志记录，每次写操作都追加日志</td></tr><tr><td align="center"><strong>数据安全性</strong></td><td align="center">可能丢失最近的一些数据</td><td align="center">数据最安全，几乎不丢失</td></tr><tr><td align="center"><strong>文件体积</strong></td><td align="center">文件体积较小</td><td align="center">文件体积较大</td></tr><tr><td align="center"><strong>恢复速度</strong></td><td align="center">恢复速度快</td><td align="center">恢复速度较慢</td></tr><tr><td align="center"><strong>性能开销</strong></td><td align="center">占用内存和 CPU 资源较多</td><td align="center">根据策略，性能影响灵活</td></tr><tr><td align="center"><strong>适合的场景</strong></td><td align="center">定期备份，不追求数据实时保存</td><td align="center">需要高数据安全性且可接受更大的文件</td></tr></tbody></table><h3 id="4-如何选择？"><a href="#4-如何选择？" class="headerlink" title="4. 如何选择？"></a>4. <strong>如何选择？</strong></h3><ul><li>如果你的业务对数据安全要求不高，偶尔丢失几分钟的数据是可以接受的，并且你更看重性能，那么 RDB 是不错的选择。</li><li>如果你对数据的持久化有较高的要求，不能容忍数据丢失，AOF 更适合你，尤其是设置为每秒持久化时，它能够在性能和数据安全之间取得平衡。</li><li>实际上，很多 Redis 用户会同时开启 RDB 和 AOF，这样即可以利用 RDB 快速恢复数据，又可以利用 AOF 最大程度保护数据安全。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【网络】TCP问题一二三</title>
    <link href="/2024/02/14/0919-TCP%E9%97%AE%E9%A2%98%E4%B8%80%E4%BA%8C%E4%B8%89/"/>
    <url>/2024/02/14/0919-TCP%E9%97%AE%E9%A2%98%E4%B8%80%E4%BA%8C%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>尽管 TCP 设计良好并且在大多数情况下表现出色，但它也有一些固有的问题和挑战。以下是 TCP 协议的一些常见问题：</p><h3 id="1-延迟问题"><a href="#1-延迟问题" class="headerlink" title="1. 延迟问题"></a>1. <strong>延迟问题</strong></h3><ul><li><strong>慢启动延迟</strong>：TCP 的慢启动机制在连接建立时会限制初始数据发送速率，导致连接开始时的传输速度较慢。特别是在高带宽、高延迟网络环境下，慢启动的初始阶段可能会带来显著的延迟。</li><li><strong>TCP 握手延迟</strong>：在建立连接时，TCP 需要进行三次握手，这会在连接建立之前引入一定的延迟。对于短暂的连接（如网页浏览中的单个请求），这个握手过程的延迟会更加明显。</li></ul><h3 id="2-头部开销"><a href="#2-头部开销" class="headerlink" title="2. 头部开销"></a>2. <strong>头部开销</strong></h3><ul><li><strong>TCP 头部开销</strong>：TCP 报文段中有20字节的固定头部信息，再加上可选字段，这些头部信息会增加每个数据包的大小。虽然这个开销对大数据流的影响较小，但对于小数据包传输（如物联网设备中的数据传输），这个开销会比较明显。</li></ul><h3 id="3-拥塞控制的问题"><a href="#3-拥塞控制的问题" class="headerlink" title="3. 拥塞控制的问题"></a>3. <strong>拥塞控制的问题</strong></h3><ul><li><strong>拥塞控制不适应性</strong>：TCP 的拥塞控制算法（如慢启动、拥塞避免）是基于一定的假设设计的，但在某些网络条件下（如高速或高延迟网络），这些算法可能不够有效，导致带宽利用率低下或过度拥塞。</li><li><strong>对突发流量的处理</strong>：TCP 的拥塞控制对突发性流量（短时间内大量数据传输）处理不佳，可能导致网络瞬间拥塞，并且需要时间恢复到正常状态。</li></ul><h3 id="4-传输效率问题"><a href="#4-传输效率问题" class="headerlink" title="4. 传输效率问题"></a>4. <strong>传输效率问题</strong></h3><ul><li><strong>小数据包的低效率</strong>：TCP 为了保证可靠性，需要对每个数据包进行确认（ACK），这对传输小数据包时的效率有一定影响。特别是当每个数据包都需要等待 ACK 才能继续发送时，效率会大幅降低。</li><li><strong>HOL 阻塞（Head-of-Line Blocking）</strong>：TCP 保证数据包按序传输。如果某个数据包丢失，接收方必须等待该数据包被重传并正确接收后才能继续处理后续数据包，这会导致队列前面的数据阻塞后续数据的处理。</li></ul><h3 id="5-网络安全问题"><a href="#5-网络安全问题" class="headerlink" title="5. 网络安全问题"></a>5. <strong>网络安全问题</strong></h3><ul><li><strong>TCP SYN 洪泛攻击</strong>：TCP 的三次握手机制存在被滥用的可能性，比如 SYN 洪泛攻击（SYN Flooding），攻击者可以通过大量发送 SYN 请求但不完成握手，从而耗尽服务器资源，导致拒绝服务（DoS）。</li><li><strong>TCP 会话劫持</strong>：<font color="#c00000">攻击者通过伪造一个有效的 TCP 报文段，可以劫持或插入数据到现有的 TCP 会话中，可能会窃取或篡改通信数据</font>。</li><li><strong>中间人攻击</strong>：TCP 协议本身缺乏加密机制，容易受到<font color="#c00000">中间人攻击</font>（MITM），攻击者可以拦截、修改或伪造通信数据。虽然现代应用通常使用 SSL&#x2F;TLS 来保护 TCP 通信，但原始的 TCP 并不提供这种安全性。</li></ul><h3 id="6-路径-MTU-问题"><a href="#6-路径-MTU-问题" class="headerlink" title="6. 路径 MTU 问题"></a>6. <strong>路径 MTU 问题</strong></h3><ul><li><strong>路径 MTU 发现（PMTUD）问题</strong>：TCP 在发送数据时，需要知道路径上的最大传输单元（MTU）。如果路径 MTU 发生变化（如因为网络路径的改变），而没有及时更新，可能会导致 TCP 报文段过大而被丢弃。这种情况下，TCP 需要重新调整数据段大小，可能导致性能下降。</li></ul><h3 id="7-流量控制和拥塞控制的冲突"><a href="#7-流量控制和拥塞控制的冲突" class="headerlink" title="7. 流量控制和拥塞控制的冲突"></a>7. <strong>流量控制和拥塞控制的冲突</strong></h3><ul><li><strong>流量控制和拥塞控制之间的复杂互动</strong>：TCP 同时使用流量控制（基于接收方的接收窗口）和拥塞控制（基于网络状况）。在某些情况下，这两者之间的相互作用可能导致次优性能。例如，接收窗口较小时，可能导致发送方误以为网络发生了拥塞，从而过度降低发送速率。</li></ul><h3 id="8-连接状态的维护"><a href="#8-连接状态的维护" class="headerlink" title="8. 连接状态的维护"></a>8. <strong>连接状态的维护</strong></h3><ul><li><strong>连接状态的开销</strong>：TCP 需要在连接的整个生命周期中维护状态信息，包括序列号、确认号、窗口大小等。在大量连接（如高并发服务器）场景下，管理这些状态可能带来显著的内存和处理开销。</li></ul><h3 id="9-不支持广播和多播"><a href="#9-不支持广播和多播" class="headerlink" title="9. 不支持广播和多播"></a>9. <strong>不支持广播和多播</strong></h3><ul><li><strong>TCP 不支持广播和多播</strong>：TCP 是面向连接的协议，每个连接都是一对一的，无法直接支持广播或多播通信。这对于需要发送相同数据给多个接收方的应用来说是一个限制，需要借助其他协议（如 UDP）来实现<font color="#c00000">多播或广播</font>功能。</li></ul><h3 id="10-高延迟或丢包网络中的性能问题"><a href="#10-高延迟或丢包网络中的性能问题" class="headerlink" title="10. 高延迟或丢包网络中的性能问题"></a>10. <strong>高延迟或丢包网络中的性能问题</strong></h3><ul><li><strong>在高延迟或高丢包率网络中的性能问题</strong>：TCP 的性能在高延迟或高丢包率网络中可能表现不佳。高延迟会导致慢启动阶段更长时间的低吞吐量，而高丢包率会频繁触发拥塞控制机制，显著降低数据传输效率。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【八股】Synchronized</title>
    <link href="/2024/02/14/0919-sybchronized/"/>
    <url>/2024/02/14/0919-sybchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>synchronized</code> 是 Java 中最基本的同步机制之一，它主要用于确保多个线程对共享资源的互斥访问。其底层原理涉及到 Java 对象的内存布局、锁的实现机制以及操作系统的原语支持。下面从多个方面解释 <code>synchronized</code> 的底层原理。</p><p>开篇明意，底层原理 &#x3D; 对象头的锁标志 + Monitor + Monitor指令</p><h3 id="1-对象头和锁状态"><a href="#1-对象头和锁状态" class="headerlink" title="1. 对象头和锁状态"></a>1. 对象头和锁状态</h3><p>在 Java 中，每个对象在内存中都有一个<font color="#f79646">对象头</font>（Object Header），对象头中包含了一些与对象自身状态有关的信息。其中，<code>Mark Word</code> 是对象头的一部分，存储了锁的信息。</p><ul><li><strong>Mark Word</strong>：<code>Mark Word</code> 的内容随对象是否被锁定以及锁的状态不同而变化。在<font color="#f79646">锁定状态</font>下，它包含指向锁记录（Lock Record）或监视器（Monitor）的指针。</li></ul><p>Java 中的锁状态可以分为以下几种：</p><ul><li><strong>无锁状态</strong>（Unlocked）：对象未被任何线程锁定，此时 <code>Mark Word</code> 中存储的是对象的哈希码、GC 标记等信息。</li><li><strong>偏向锁</strong>（Biased Locking）：当一个线程<font color="#f79646">首次访问</font>同步代码块时，JVM 会为该线程偏向锁定对象。<font color="#f79646">偏向锁允许同一个线程重复进入同步块而不需要加锁和解锁</font>。</li><li><strong>轻量级锁</strong>（Lightweight Lock）：当偏向锁被竞争（另一个线程也尝试获取锁）时，锁会膨胀为轻量级锁。此时会使用 <font color="#f79646">CAS</font> 操作尝试竞争锁。</li><li><strong>重量级锁</strong>（Heavyweight Lock）：当轻量级锁竞争失败时，会升级为重量级锁，线程将被阻塞。重量级锁由操作系统的<font color="#f79646">互斥量</font>（Mutex）实现。</li></ul><h3 id="2-锁的实现机制"><a href="#2-锁的实现机制" class="headerlink" title="2. 锁的实现机制"></a>2. 锁的实现机制</h3><p><code>synchronized</code> 的锁机制依赖于操作系统提供的原语，如互斥量（Mutex）和条件变量。Java 中的重量级锁是通过调用操作系统的底层 API 来实现的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是为了解决无竞争情况下的加锁和解锁开销。在没有竞争的情况下，一个线程在进入同步块时，只需在对象的 <code>Mark Word</code> 中记录下当前线程 ID，表示这个线程已经获得锁。偏向锁的撤销通常会在其他线程试图获取该锁时发生，此时锁可能升级为轻量级锁或重量级锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是通过 CAS 操作实现的。轻量级锁在进入同步块时，会尝试使用 CAS 操作将对象头的 <code>Mark Word</code> 替换为当前线程的锁记录。如果 CAS 成功，表示获得锁，否则说明存在竞争，锁会膨胀为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是通过操作系统的互斥量实现的。当轻量级锁竞争失败后，锁会膨胀为重量级锁，线程会被挂起，并进入阻塞状态，直到获得锁。重量级锁会使用操作系统的线程调度机制来管理锁的争用，导致线程的上下文切换，这也是重量级锁相对较慢的原因。</p><h3 id="3-Monitor-和-synchronized"><a href="#3-Monitor-和-synchronized" class="headerlink" title="3. Monitor 和 synchronized"></a>3. Monitor 和 synchronized</h3><p><code>synchronized</code> 关键字是通过 Java 的 <code>Monitor</code> 实现的。<code>Monitor</code> 是一种同步工具，每个对象都有一个 <code>Monitor</code>，它在 JVM 层面由 <code>ObjectMonitor</code> 实现。</p><p><code>Monitor</code> 主要负责管理进入和退出同步块的线程。<code>synchronized</code> 代码块或方法在编译后，会在字节码中生成 <code>monitorenter</code> 和 <code>monitorexit</code> 指令：</p><ul><li><strong>monitorenter</strong>：当线程进入同步块时，会尝试获取对象的 <code>Monitor</code>，如果获取成功，线程进入同步块，<code>Monitor</code> 的进入计数（entry count）加1。</li><li><strong>monitorexit</strong>：当线程退出同步块时，释放 <code>Monitor</code>，<code>Monitor</code> 的进入计数减1。如果计数为0，其他线程可以获取这个 <code>Monitor</code>。</li></ul><h3 id="4-锁优化"><a href="#4-锁优化" class="headerlink" title="4. 锁优化"></a>4. 锁优化</h3><p>JVM 通过一系列锁优化技术提高 <code>synchronized</code> 的性能：</p><ul><li><strong>偏向锁</strong>：前面提到过，偏向锁适用于只有一个线程竞争锁的情况，通过减少加锁和解锁的开销来提升性能。</li><li><strong>轻量级锁</strong>：用于减少线程在无竞争的情况下加锁的成本，通过 CAS 操作实现。</li><li><strong>自旋锁</strong>：在进入重量级锁之前，线程会自旋等待一段时间，尝试获取锁，而不是立即进入阻塞状态。这样可以避免线程在短时间内释放锁时频繁的上下文切换。</li><li><strong>锁消除</strong>：JVM 在 JIT 编译时会进行逃逸分析。如果发现某些锁对象不会被其他线程访问，则可以消除这些不必要的锁。</li><li><strong>锁粗化</strong>：JVM 在 JIT 编译时发现某些连续的加锁和解锁操作，可以将这些操作合并为一个更大的锁块，从而减少锁操作的开销。</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用 <code>synchronized</code> 的方法主要有三种：同步实例方法、同步代码块和同步静态方法。下面分别介绍这三种用法。</p><h3 id="1-同步实例方法"><a href="#1-同步实例方法" class="headerlink" title="1. 同步实例方法"></a>1. 同步实例方法</h3><p>将方法声明为 <code>synchronized</code>，意味着调用这个方法的线程必须先获得对象实例的锁，才能执行方法的内容。这种方式适用于保护对象实例的内部状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>increment</code> 和 <code>getCount</code> 方法被声明为 <code>synchronized</code>，因此如果一个线程正在执行 <code>increment</code> 方法，其他线程必须等待，直到这个线程执行完毕并释放锁后，才能进入 <code>increment</code> 或 <code>getCount</code> 方法。</p><h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2. 同步代码块"></a>2. 同步代码块</h3><p>如果你只希望同步某个方法中的部分代码，而不是整个方法，可以使用 <code>synchronized</code> 代码块。这样可以减少同步的范围，提升程序的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>synchronized (this)</code> 来锁定当前对象实例，只对 <code>count++</code> 操作进行同步。这样一来，其他线程在执行非同步代码时不会被阻塞。</p><h3 id="3-同步静态方法"><a href="#3-同步静态方法" class="headerlink" title="3. 同步静态方法"></a>3. 同步静态方法</h3><p><code>Synchronized</code> 关键字也可以用于静态方法。这种情况下，锁定的是类对象，而不是某个实例。这意味着，所有访问该静态方法的线程都会被同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，<code>increment</code> 和 <code>getCount</code> 是静态同步方法，因此锁定的是 <code>Counter.class</code>，而不是某个 <code>Counter</code> 实例。这种方式适用于多个线程访问类级别的共享资源时。</p><h3 id="4-同步代码块锁定类对象"><a href="#4-同步代码块锁定类对象" class="headerlink" title="4. 同步代码块锁定类对象"></a>4. 同步代码块锁定类对象</h3><p>有时你可能希望对静态方法或类级别的代码块进行部分同步，而不是整个方法。这时可以使用同步代码块来锁定类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (Counter.class) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (Counter.class) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们通过 <code>synchronized (Counter.class)</code> 只锁定了 <code>count++</code> 操作，而不是整个 <code>increment</code> 方法。</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【网络】三次握手、四次挥手</title>
    <link href="/2024/02/14/0919-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2024/02/14/0919-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>三次握手（Three-Way Handshake）是 TCP 协议中建立连接的过程，用来确保客户端和服务器之间的连接是可靠的。它是 TCP 协议确保数据传输可靠性的基础。</p><h3 id="三次握手的步骤"><a href="#三次握手的步骤" class="headerlink" title="三次握手的步骤"></a>三次握手的步骤</h3><p>假设客户端想要与服务器建立连接，整个过程可以分为三步：</p><ol><li><p><strong>第一次握手：客户端向服务器发送 SYN 请求</strong></p><ul><li>客户端发送一个带有 <code>SYN</code>（Synchronize Sequence Numbers，同步序列号）标志的数据包给服务器，表示“我想要和你建立连接”。</li><li>这个数据包中包含了一个初始的序列号（<code>Sequence Number</code>），用来标识接下来发送的数据包的顺序。我们可以把它想象成“从哪开始数数”。</li></ul></li><li><p><strong>第二次握手：服务器回应客户端的 SYN，并发送自己的 SYN</strong></p><ul><li>服务器收到客户端的 <code>SYN</code> 请求后，它会知道“有一个客户端想和我建立连接”，然后服务器会发送一个 <code>SYN-ACK</code>（Synchronize-Acknowledge，同步-确认）数据包作为响应。</li><li><code>SYN-ACK</code> 包中包含两个信息：一个是服务器自己的 <code>SYN</code>，表示“好的，我愿意和你建立连接”；另一个是 <code>ACK</code>（Acknowledgment，确认），表示“我收到了你发来的 <code>SYN</code> 包”。</li><li>同时，服务器也会指定一个序列号，用来表示自己这边的顺序控制。</li></ul></li><li><p><strong>第三次握手：客户端确认服务器的回应</strong></p><ul><li>客户端收到服务器的 <code>SYN-ACK</code> 包后，会发送一个 <code>ACK</code> 包给服务器，表示“我已经收到了你的 <code>SYN</code>，也确认了你愿意建立连接”。</li><li>这个 <code>ACK</code> 包中包含服务器发送的 <code>SYN</code> 的序列号加1，表示对服务器序列号的确认。</li></ul></li></ol><p>当这三次数据包的交换完成后，客户端和服务器之间的连接就建立起来了，接下来就可以进行可靠的数据传输了。</p><h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><p>三次握手的目的是为了确保连接双方都知道彼此的存在，并且双方的发送和接收能力都正常。具体来说：</p><ol><li><strong>第一次握手</strong> 是客户端向服务器表明自己要建立连接，并且发送了初始序列号。</li><li><strong>第二次握手</strong> 是服务器向客户端确认它收到了连接请求，并且同意建立连接，此外，服务器还会发送自己的初始序列号。</li><li><strong>第三次握手</strong> 是客户端确认服务器的 <code>SYN</code>，表示连接已经建立。</li></ol><p>三次握手能够防止<strong>旧的重复连接请求</strong>对服务器产生干扰。<font color="#c00000">假如只进行了两次握手，那么一个旧的重复连接请求到达服务器后，服务器就会误认为这是一个新的连接请求，并且开启连接，但客户端可能对此不知情。</font>三次握手能够避免这种情况发生，因为只有当客户端确认了服务器的 <code>SYN-ACK</code> 后，连接才会正式建立。</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>TCP 的连接终止过程被称为“四次挥手”，而不是“三次挥手”，这是因为在连接的关闭过程中，客户端和服务器之间需要进行四次消息交换才能确保连接的可靠关闭。这与建立连接时的三次握手不同。</p><h3 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h3><p>假设客户端想要关闭与服务器的连接，整个过程分为四个步骤：</p><ol><li><p><strong>第一次挥手：客户端发送 FIN 请求关闭连接</strong></p><ul><li>客户端发送一个带有 <code>FIN</code>（Finish）标志的报文段给服务器，表示“我不再有数据要发送了，我想关闭连接”。</li><li>此时，客户端进入 <code>FIN_WAIT_1</code> 状态。</li></ul></li><li><p><strong>第二次挥手：服务器回应客户端的 FIN</strong></p><ul><li>服务器收到客户端的 <code>FIN</code> 报文段后，会发送一个 <code>ACK</code>（Acknowledgment，确认）报文段，表示“我收到了你的请求”。</li><li>此时，客户端进入 <code>FIN_WAIT_2</code> 状态，服务器则进入 <code>CLOSE_WAIT</code> 状态。</li></ul></li><li><p><strong>第三次挥手：服务器发送 FIN 请求关闭连接</strong></p><ul><li>服务器在发送完所有的数据后，如果也想关闭连接，它会发送一个带有 <code>FIN</code> 标志的报文段给客户端，表示“我这边的数据也发送完了，可以关闭连接了”。</li><li>此时，服务器进入 <code>LAST_ACK</code> 状态。</li></ul></li><li><p><strong>第四次挥手：客户端回应服务器的 FIN</strong></p><ul><li>客户端收到服务器的 <code>FIN</code> 报文段后，会发送一个 <code>ACK</code> 报文段，表示“我收到了你的请求，可以关闭连接了”。</li><li>此时，客户端进入 <code>TIME_WAIT</code> 状态，并等待一段时间（通常是两个最大报文段生存时间，约 2 分钟），确保服务器收到了最后的 <code>ACK</code>，然后客户端才会真正关闭连接，进入 <code>CLOSED</code> 状态。</li><li>服务器在收到客户端的 <code>ACK</code> 后，也进入 <code>CLOSED</code> 状态，连接正式关闭。</li></ul></li></ol><h3 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h3><p>四次挥手之所以需要四个步骤，而不是像三次握手那样只需要三个步骤，主要原因在于 TCP 是全双工通信协议，意味着通信的双方都可以独立地关闭它们的发送通道。在连接关闭时，每个方向的通信都需要单独终止，因此需要四次消息交换。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【八股】Volatile</title>
    <link href="/2024/02/14/0919-volatile/"/>
    <url>/2024/02/14/0919-volatile/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>volatile</code> 关键字在 Java 中用于保证变量的<font color="#2DC26B">可见性</font>和<font color="#2DC26B">有序性</font>。理解 <code>volatile</code> 的底层实现，可以帮助我们更好地理解其工作原理，尤其是在多线程环境中的行为。</p><p>在多线程环境下，每个线程都有自己的<strong>工作内存</strong>（或称作本地内存），工作内存中保存了主内存中变量的副本。当一个线程修改某个变量时，通常是在工作内存中修改，而不是立即写回主内存，其他线程读取到的可能还是旧值。<code>volatile</code> 关键字的主要作用就是保证对变量的修改对于所有线程是可见的。</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><code>volatile</code> 的可见性是通过以下两方面来保证的：</p><ol><li><p><strong>内存屏障（Memory Barrier）</strong><br>   编译器在生成字节码时会插入内存屏障指令，来确保对 <code>volatile</code> 变量的读写操作不会被 CPU 和编译器重排序，并且对 <code>volatile</code> 变量的写操作之前的所有操作都不会被重排序到写操作之后。具体来说，在 <code>volatile</code> 变量读写前后插入以下屏障：</p><ul><li><strong>写屏障（Store Barrier）</strong>：在对 <code>volatile</code> 变量写入后，插入写屏障，确保写入的值立即刷到主内存中。</li><li><strong>读屏障（Load Barrier）</strong>：在读取 <code>volatile</code> 变量前，插入读屏障，确保在读取操作前先清空线程工作内存中的缓存，从主内存中重新读取该变量的值。<br>这种机制保证了变量的最新值总是被其他线程可见。</li></ul></li><li><p><strong>缓存一致性协议（Cache Coherence Protocol）</strong><br>   现代 CPU 通常采用缓存一致性协议，如 MESI 协议来保证多核 CPU 中的缓存一致性。当一个 CPU 核心对 <code>volatile</code> 变量进行写操作时，它会通过缓存一致性协议让其他 CPU 核心失效该变量的缓存，从而强制这些核心从主内存中重新加载该变量。<br>具体过程是：</p><ul><li>当一个线程修改 <code>volatile</code> 变量时，该变量所在的缓存行会被标记为无效。</li><li>其他线程想要读取这个变量时，发现缓存行无效，必须从主内存重新加载。</li></ul></li></ol><h3 id="volatile-和指令重排序"><a href="#volatile-和指令重排序" class="headerlink" title="volatile 和指令重排序"></a><code>volatile</code> 和指令重排序</h3><p>Java 内存模型允许编译器和处理器对指令进行重排序以优化性能，但重排序不能影响在单线程环境下的执行结果。在多线程环境中，<code>volatile</code> 关键字通过内存屏障的方式禁止了某些重排序，从而保证了多线程访问 <code>volatile</code> 变量时的有序性和可见性。</p><p>总结一下，<code>volatile</code> 关键字的底层实现依赖于<font color="#f79646">内存屏障</font>和 <font color="#f79646">CPU 的缓存一致性</font>协议来确保多线程之间的可见性。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【网络】流量控制、拥塞控制</title>
    <link href="/2024/02/14/0919-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/02/14/0919-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_46631497/article/details/137253124?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22137253124%22,%22source%22:%22qq_46631497%22%7D">什么是TCP滑动窗口？（解释+流程示例）</a><br><a href="https://blog.csdn.net/qq_46631497/article/details/137252874">流量控制</a><br><a href="https://blog.csdn.net/qq_46631497/article/details/137375809">拥塞控制</a></p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>TCP 的流量控制是<font color="#f79646">确保发送方的数据发送速率不会超过接收方的处理能力</font>，从而避免因接收方处理不及而导致数据丢失或网络拥塞。TCP 使用基于窗口的流量控制机制，这个机制通过动态调整发送方的发送窗口大小来实现。以下是流量控制的关键概念和机制：</p><h3 id="1-滑动窗口机制"><a href="#1-滑动窗口机制" class="headerlink" title="1. 滑动窗口机制"></a>1. 滑动窗口机制</h3><p>TCP 使用滑动窗口机制来进行流量控制。滑动窗口可以理解为一个发送方维护的缓冲区，规定了可以发送而无需等待确认的字节数。</p><ul><li><strong>发送窗口</strong>：发送方的发送窗口表示可以连续发送且未被确认的数据量。窗口的大小由接收方告知发送方。</li><li><strong>接收窗口</strong>：接收方的接收窗口表示接收方的缓冲区中还能容纳的数据量。接收方会通过在 ACK 报文中告知发送方当前的接收窗口大小。</li></ul><h3 id="2-接收方的通告窗口（Advertised-Window）"><a href="#2-接收方的通告窗口（Advertised-Window）" class="headerlink" title="2. 接收方的通告窗口（Advertised Window）"></a>2. 接收方的通告窗口（Advertised Window）</h3><p>接收方通过在 ACK 报文中包含一个窗口大小（<code>Window Size</code>）字段来告诉发送方它的接收能力。这被称为<strong>通告窗口</strong>。</p><ul><li><strong>通告窗口大小</strong>：接收方根据自身的缓冲区可用空间，动态调整通告窗口的大小。如果接收方的缓冲区即将满了，它会把通告窗口的大小设置为较小的值，甚至为零，通知发送方暂停发送。</li></ul><h3 id="3-零窗口（Zero-Window）和窗口探测"><a href="#3-零窗口（Zero-Window）和窗口探测" class="headerlink" title="3. 零窗口（Zero Window）和窗口探测"></a>3. 零窗口（Zero Window）和窗口探测</h3><ul><li><strong>零窗口</strong>：当接收方的缓冲区已经满了，它会将通告窗口大小设置为零，这意味着接收方暂时无法接收更多数据，发送方必须暂停发送数据。</li><li><strong>窗口探测（Window Probing）</strong>：如果发送方接收到零窗口的通知，它会定期发送一个小的探测报文段（Probe Segment）来询问接收方的窗口大小是否有变化。一旦接收方的缓冲区有了空闲空间，它会在响应中提供一个新的窗口大小，发送方可以恢复数据传输。</li></ul><h3 id="4-动态调整发送速率"><a href="#4-动态调整发送速率" class="headerlink" title="4. 动态调整发送速率"></a>4. 动态调整发送速率</h3><p>流量控制使得 TCP 发送方的发送速率自动适应接收方的处理能力，避免因为发送过快而导致接收方无法及时处理和丢包。</p><ul><li><strong>加速和减速</strong>：当接收方的窗口较大时，发送方可以快速发送数据，利用较大的窗口空间。当窗口较小时，发送方会减慢发送速率，甚至暂停发送，直到窗口增大。</li></ul><h3 id="5-TCP-流量控制与拥塞控制的区别"><a href="#5-TCP-流量控制与拥塞控制的区别" class="headerlink" title="5. TCP 流量控制与拥塞控制的区别"></a>5. TCP 流量控制与拥塞控制的区别</h3><ul><li><strong>流量控制</strong>：针对端到端的发送方和接收方，确保发送方不至于超出接收方的处理能力，避免接收方的缓冲区溢出。</li><li><strong>拥塞控制</strong>：针对整个网络路径，防止网络中间的路由器和链路发生拥塞，确保网络负载在可承受范围内。拥塞控制的机制包括慢启动、拥塞避免、快速重传和快速恢复等。</li></ul><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>TCP 拥塞控制是为了防止网络中的路由器和链路过载而设计的一套机制。拥塞控制通过调整数据的发送速率，确保网络不会被过多的数据流量压垮，从而维持网络的稳定性和高效性。拥塞控制主要依赖于发送方的算法来动态调整发送窗口的大小。以下是拥塞控制的核心机制和算法：</p><h3 id="1-拥塞窗口（Congestion-Window，cwnd）"><a href="#1-拥塞窗口（Congestion-Window，cwnd）" class="headerlink" title="1. 拥塞窗口（Congestion Window，cwnd）"></a>1. 拥塞窗口（Congestion Window，cwnd）</h3><p>拥塞窗口是 TCP 拥塞控制的关键参数，它限制了发送方在未接收到 ACK 的情况下可以发送的最大数据量。<code>cwnd</code> 的大小会根据网络的拥塞状况动态调整。</p><h3 id="2-拥塞控制的四个主要算法"><a href="#2-拥塞控制的四个主要算法" class="headerlink" title="2. 拥塞控制的四个主要算法"></a>2. 拥塞控制的四个主要算法</h3><p>TCP 的拥塞控制主要通过以下四个阶段和算法来实现：</p><h4 id="1-慢启动（Slow-Start）"><a href="#1-慢启动（Slow-Start）" class="headerlink" title="1. 慢启动（Slow Start）"></a>1. <strong>慢启动（Slow Start）</strong></h4><ul><li><strong>目的</strong>：逐步探测网络的可用带宽，避免初始发送数据过多而导致网络拥塞。</li><li><strong>实现</strong>：当连接开始时，TCP 将拥塞窗口 <code>cwnd</code> 初始化为一个较小的值（通常是1个MSS，即最大报文段大小）。每收到一个 ACK，<code>cwnd</code> 增加1个 MSS（即窗口大小翻倍），使得发送速率呈指数增长。</li><li><strong>结束条件</strong>：当 <code>cwnd</code> 达到一个阈值（称为慢启动阈值，<code>ssthresh</code>），或者发生了丢包事件（网络可能出现拥塞），慢启动阶段结束，转入拥塞避免阶段。</li></ul><h4 id="2-拥塞避免（Congestion-Avoidance）"><a href="#2-拥塞避免（Congestion-Avoidance）" class="headerlink" title="2. 拥塞避免（Congestion Avoidance）"></a>2. <strong>拥塞避免（Congestion Avoidance）</strong></h4><ul><li><strong>目的</strong>：避免拥塞发生，尽量维持网络的稳定性。</li><li><strong>实现</strong>：在拥塞避免阶段，<code>cwnd</code> 不再指数增长，而是线性增长。每经过一个 RTT（Round-Trip Time），<code>cwnd</code> 增加 1 个 MSS。这样，数据的发送速率增长得更加平稳。</li><li><strong>结束条件</strong>：如果检测到网络出现拥塞（比如发生丢包），则触发拥塞控制的应对机制，进入快速重传或慢启动阶段。</li></ul><h4 id="3-快速重传（Fast-Retransmit）"><a href="#3-快速重传（Fast-Retransmit）" class="headerlink" title="3. 快速重传（Fast Retransmit）"></a>3. <strong>快速重传（Fast Retransmit）</strong></h4><ul><li><strong>目的</strong>：及时检测并应对数据包丢失，而不必等待重传计时器超时。</li><li><strong>实现</strong>：当发送方连续收到三个相同的 ACK 时（即三个重复的 ACK，表示某个数据包丢失），它会立即重传被认为丢失的数据包，而无需等待超时。这有助于快速恢复丢失的数据包，减少对网络传输的影响。</li></ul><h4 id="4-快速恢复（Fast-Recovery）"><a href="#4-快速恢复（Fast-Recovery）" class="headerlink" title="4. 快速恢复（Fast Recovery）"></a>4. <strong>快速恢复（Fast Recovery）</strong></h4><ul><li><strong>目的</strong>：避免在丢包时立即进入慢启动，从而维持相对较高的传输速率。</li><li><strong>实现</strong>：在快速重传的基础上，TCP 认为网络可能并非完全拥塞，所以不需要将 <code>cwnd</code> 降到最小值（像慢启动那样），而是将 <code>cwnd</code> 减半，并直接进入拥塞避免阶段。这可以让 TCP 连接在网络情况有所好转时，迅速恢复到接近丢包前的发送速率。</li></ul><h3 id="3-拥塞控制的综合运行流程"><a href="#3-拥塞控制的综合运行流程" class="headerlink" title="3. 拥塞控制的综合运行流程"></a>3. 拥塞控制的综合运行流程</h3><p>当一个新的 TCP 连接建立时：</p><ol><li><strong>慢启动阶段</strong>：TCP 从一个很小的 <code>cwnd</code> 开始，指数增长发送窗口，探测网络的承载能力。</li><li><strong>拥塞避免阶段</strong>：当 <code>cwnd</code> 达到慢启动阈值 <code>ssthresh</code> 时，转入拥塞避免，发送速率线性增长。</li><li><strong>丢包检测</strong>：如果网络中发生丢包（通过超时或接收到三个重复的 ACK 检测到），TCP 会减少 <code>cwnd</code>，通常减少到之前的一半，并且调整 <code>ssthresh</code> 的值。<ul><li><strong>快速重传</strong>：如果检测到丢包，立即重传丢失的数据包。</li><li><strong>快速恢复</strong>：丢包后不会立即进入慢启动，而是通过减半 <code>cwnd</code> 来逐步恢复。</li></ul></li><li><strong>恢复过程</strong>：当 <code>cwnd</code> 再次超过 <code>ssthresh</code>，拥塞避免继续生效。</li></ol><h3 id="4-拥塞控制的作用"><a href="#4-拥塞控制的作用" class="headerlink" title="4. 拥塞控制的作用"></a>4. 拥塞控制的作用</h3><p>TCP 拥塞控制通过动态调整 <code>cwnd</code> 来控制数据的发送速率，从而避免网络拥塞，维持网络传输的效率和可靠性。拥塞控制确保了 TCP 的稳健性，即使在复杂和不稳定的网络环境下，仍能有效传输数据。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】索引</title>
    <link href="/2024/02/14/0924-MySQL%20%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/02/14/0924-MySQL%20%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、MySQL-索引的种类"><a href="#一、MySQL-索引的种类" class="headerlink" title="一、MySQL 索引的种类"></a>一、MySQL 索引的种类</h3><ol><li><strong>B-Tree 索引</strong><ul><li><strong>特点</strong>：MySQL 默认使用的索引类型（大多数情况下），其底层实现基于 B-Tree 数据结构。</li><li><strong>适用场景</strong>：适用于大多数 &#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D; 和 BETWEEN 的查询，也适用于 <code>ORDER BY</code> 和 <code>GROUP BY</code>。</li><li><strong>使用场景</strong>：对于需要快速定位行或排序的数据列，B-Tree 索引非常有效。</li></ul><ol start="2"><li><strong>哈希索引（Hash Index）</strong></li></ol><ul><li><strong>特点</strong>：基于哈希表的索引，查询速度快，但仅适用于精确匹配查询（&#x3D;），不能用于范围查询，也不支持排序。</li><li><strong>适用场景</strong>：非常适合等值查询，但不适用于范围查询或排序的场景。</li></ul><ol start="3"><li><strong>全文索引（FULLTEXT Index）</strong></li></ol><ul><li><strong>特点</strong>：用于全文搜索，适合文本字段（如 <code>CHAR</code>、<code>VARCHAR</code> 和 <code>TEXT</code>）。</li><li><strong>适用场景</strong>：全文检索场景，适合大段文本的模糊匹配、搜索等。</li><li><strong>使用场景</strong>：在查找文章或长文本时可以用到。</li></ul><ol start="4"><li><strong>空间索引（Spatial Index）</strong></li></ol><ul><li><strong>特点</strong>：用于地理数据类型（如 <code>GEOMETRY</code>），MySQL 支持 <code>R-Tree</code> 结构来存储这些索引。</li><li><strong>适用场景</strong>：处理地理空间数据，支持位置、范围等查询。</li></ul></li><li><strong>联合索引（Compound Index）</strong><ul><li><strong>特点</strong>：由多个列组成的复合索引。</li><li><strong>适用场景</strong>：适合频繁组合查询的多个列；需要注意顺序，查询时必须按索引列的顺序进行匹配。</li></ul></li></ol><h3 id="二、索引的使用原则"><a href="#二、索引的使用原则" class="headerlink" title="二、索引的使用原则"></a>二、索引的使用原则</h3><ol><li><strong>选择性高的列建立索引</strong><ul><li>索引应该建立在选择性高的列上，即该列值的重复度较低的情况下效果最佳。例如，对某个非常少重复的列（如主键）进行索引能够极大提高查询效率。</li></ul></li><li><strong>覆盖索引（Covering Index）</strong><ul><li>如果索引列包含了查询所需的所有列（即覆盖了查询的所有字段），查询时可以直接从索引中返回结果，避免回表查找数据。这可以显著提高查询性能。</li></ul></li><li><strong>避免在频繁更新的列上使用索引</strong><ul><li>索引会影响 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 的性能，因为这些操作需要维护索引。频繁变动的字段不适合建索引。</li></ul></li><li><strong>合理使用前缀索引</strong><ul><li>对于长文本字段，可以使用前缀索引（指定字段前若干字符作为索引），这样可以减少索引的存储空间，同时提高查询速度。</li></ul></li><li><strong>避免索引过多</strong><ul><li>虽然索引可以提升查询效率，但过多的索引会导致插入、更新、删除操作的性能下降。因此，索引应该根据实际查询需求合理设置。</li></ul></li><li><strong>联合索引顺序</strong><ul><li>联合索引中的列顺序非常重要，遵循最左前缀匹配原则。如果查询时只使用了联合索引的部分列，这些列必须是联合索引中的最左侧列。</li></ul></li></ol><h3 id="三、SQL-优化技巧"><a href="#三、SQL-优化技巧" class="headerlink" title="三、SQL 优化技巧"></a>三、SQL 优化技巧</h3><ol><li><strong>使用索引查询</strong><ul><li>确保在查询的 <code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code> 和 <code>GROUP BY</code> 字段上创建了合适的索引。</li><li>使用 <code>EXPLAIN</code> 命令检查查询是否使用了索引，并根据 <code>EXPLAIN</code> 输出调整查询。</li></ul></li><li><strong>避免全表扫描</strong><ul><li>尽量避免 <code>SELECT *</code>，只选择必要的列，这样可以减少查询的返回结果，并减小内存消耗。</li><li>使用合适的 <code>WHERE</code> 条件，避免不必要的全表扫描。</li></ul></li><li><strong>避免在 <code>WHERE</code> 子句中使用函数</strong><ul><li>如果在 <code>WHERE</code> 子句中使用了函数，MySQL 将无法使用索引。例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(date_column) <span class="hljs-operator">=</span> <span class="hljs-number">2024</span>;<br></code></pre></td></tr></table></figure>在这种情况下，最好使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">WHERE</span> date_column <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;2024-01-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;2024-12-31&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>合理的分页查询</strong><ul><li>对于大数据量的分页查询，直接使用 <code>LIMIT</code> 可能导致性能问题。可以使用 <code>LIMIT</code> + <code>WHERE</code> 或 <code>JOIN</code> 来优化分页查询：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> ? LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>使用 <code>JOIN</code> 代替子查询</strong><ul><li>尽量避免使用子查询，改用 <code>JOIN</code> 来优化查询，因为子查询可能会导致 MySQL 执行多次嵌套查询，性能较低。</li></ul></li><li><strong>避免 OR 条件</strong><ul><li><code>OR</code> 条件会影响索引的使用，最好将 <code>OR</code> 条件拆成多个 <code>UNION</code> 查询：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">WHERE</span> col1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;value1&#x27;</span> <span class="hljs-keyword">OR</span> col2 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;value2&#x27;</span>;<br></code></pre></td></tr></table></figure>可以优化为：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">WHERE</span> col1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;value1&#x27;</span>)<br><span class="hljs-keyword">UNION</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">WHERE</span> col2 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;value2&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>避免使用 <code>SELECT DISTINCT</code> 来排重</strong><ul><li><code>DISTINCT</code> 会导致额外的排序操作，如果能通过其他方法（如索引或 <code>GROUP BY</code>）优化，尽量避免使用 <code>DISTINCT</code>。</li></ul></li><li><strong>尽量减少数据传输</strong><ul><li>尽量减少从数据库返回的数据量，例如：<ul><li>使用 <code>LIMIT</code> 限制返回的记录数。</li><li>使用 <code>COUNT(*)</code> 代替返回整个表的数据量。</li></ul></li></ul></li><li><strong>分析和监控查询性能</strong><ul><li>使用 MySQL 自带的 <code>SHOW STATUS</code> 和 <code>SHOW PROFILE</code> 来分析查询执行过程，确定是否有慢查询或不必要的全表扫描。</li><li>通过 <code>EXPLAIN</code> 分析查询计划，检查索引使用情况，发现瓶颈。</li></ul></li></ol><h3 id="四、常见-SQL-优化示例"><a href="#四、常见-SQL-优化示例" class="headerlink" title="四、常见 SQL 优化示例"></a>四、常见 SQL 优化示例</h3><h4 id="1-优化-LIKE-查询"><a href="#1-优化-LIKE-查询" class="headerlink" title="1. 优化 LIKE 查询"></a>1. 优化 LIKE 查询</h4><ul><li><code>LIKE &#39;%value%&#39;</code> 无法使用索引，必须进行全表扫描。优化方法是：<ul><li>使用前缀匹配 <code>LIKE &#39;value%&#39;</code>，可以使用索引。</li><li>如果是全文搜索，可以使用 <code>FULLTEXT</code> 索引代替。</li></ul></li></ul><h4 id="2-优化-IN-查询"><a href="#2-优化-IN-查询" class="headerlink" title="2. 优化 IN 查询"></a>2. 优化 IN 查询</h4><ul><li>对于大量数据的 <code>IN</code> 查询，性能较差，最好使用 <code>EXISTS</code> 或 <code>JOIN</code> 替代：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> other_table);<br></code></pre></td></tr></table></figure>可以优化为：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> my_table <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> other_table <span class="hljs-keyword">WHERE</span> other_table.id <span class="hljs-operator">=</span> my_table.id);<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-优化-COUNT"><a href="#3-优化-COUNT" class="headerlink" title="3. 优化 COUNT(*)"></a>3. 优化 <code>COUNT(*)</code></h4><ul><li>如果只需要获取表的行数，不需要实际数据，<code>COUNT(*)</code> 比 <code>COUNT(column)</code> 或 <code>COUNT(1)</code> 更高效。</li></ul>]]></content>
    
    
    <categories>
      
      <category>索引</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】AQS</title>
    <link href="/2024/01/04/0924-AQS/"/>
    <url>/2024/01/04/0924-AQS/</url>
    
    <content type="html"><![CDATA[<p>在Java并发包<code>java.util.concurrent</code>中，<strong>AQS</strong>（<strong>AbstractQueuedSynchronizer</strong>）是一个用来构建锁和其他同步器的基础框架，像ReentrantLock、CountDownLatch、Semaphore等同步器都是基于AQS实现的。AQS主要使用一个基于FIFO的队列来管理同步状态的获取和释放，它通过一种“模板方法”模式提供了一个抽象的同步框架，子类通过继承AQS并实现其中的关键方法，来完成自定义的同步器。</p><p>AQS的核心机制可以总结为以下几部分：</p><ol><li><strong>状态（state）</strong><ul><li>AQS通过一个<code>int</code>类型的变量<code>state</code>来表示同步状态。这个状态变量的修改是通过<code>getState()</code>、<code>setState()</code>、<code>compareAndSetState()</code>等原子操作方法来实现的。</li><li><code>state</code>可以表示多种含义，比如在互斥锁（ReentrantLock）中，它表示锁的占用状态；在CountDownLatch中，它表示计数器的值。</li><li>通过<code>compareAndSetState</code>方法，可以使用CAS（Compare-And-Swap）操作保证状态修改的原子性。</li></ul></li><li><strong>FIFO等待队列</strong><ul><li>当线程请求的同步资源不可用时（如锁已被占用），该<font color="#974806">线程会被封装成一个节点</font>（Node）并被加入到AQS的<strong>等待队列</strong>中。</li><li>这个队列是一个双向链表，<font color="#974806">头节点为“占有同步资源的节点”，后续节点为“正在等待获取资源的节点”</font>。线程尝试获取资源失败后，会被添加到队列尾部，形成一个FIFO的等待队列。</li></ul></li><li><strong>独占模式和共享模式</strong><ul><li><strong>独占模式</strong>（Exclusive）：在独占模式下，只有一个线程可以获取到资源，其他线程必须等待。例如ReentrantLock的独占锁。</li><li><strong>共享模式</strong>（Shared）：在共享模式下，多个线程可以共享资源。例如Semaphore和CountDownLatch允许多个线程同时执行。</li><li>AQS通过不同的模板方法<code>tryAcquire</code>和<code>tryRelease</code>来支持这两种模式，子类可以覆盖这些方法实现具体的行为。</li></ul></li><li><strong>节点（Node）</strong><ul><li>AQS的等待队列中的每个元素都是一个节点（Node），每个节点包含了<font color="#974806">线程的引用和节点的状态信息</font>，主要有两种节点模式：<strong>共享节点（SHARED）</strong>\和<strong>独占节点（EXCLUSIVE）</strong>。</li><li>节点还有几种不同的状态：<ul><li><strong>CANCELLED（取消）</strong>：表示线程已经取消等待。</li><li><strong>SIGNAL（通知）</strong>：表示当前线程已经准备好，当其前驱节点释放锁时将唤醒该线程。</li><li><strong>CONDITION</strong>：与条件队列有关，表示线程在等待某个条件。</li><li><strong>PROPAGATE（传播）</strong>：与共享模式下的唤醒传播有关。</li></ul></li></ul></li></ol><h3 id="AQS的工作流程"><a href="#AQS的工作流程" class="headerlink" title="AQS的工作流程"></a>AQS的工作流程</h3><h4 id="独占模式（以ReentrantLock为例）"><a href="#独占模式（以ReentrantLock为例）" class="headerlink" title="独占模式（以ReentrantLock为例）"></a>独占模式（以ReentrantLock为例）</h4><ol><li><strong>获取锁（acquire）</strong><ul><li>当一个线程试图获取锁时，AQS会调用<code>acquire()</code>方法。该方法通过<code>tryAcquire()</code>尝试去获取资源（即锁）。</li><li>如果获取成功，线程就可以继续执行。如果失败，线程会被添加到AQS的等待队列中，线程会阻塞自己，直到被唤醒。</li><li>在队列中，线程以FIFO顺序等待，当锁释放时，队列头部的线程会被唤醒，继续尝试获取锁。</li></ul></li><li><strong>释放锁（release）</strong><ul><li>当持有锁的线程执行完毕后，会调用<code>release()</code>方法来释放锁。此时AQS会调用<code>tryRelease()</code>来修改<code>state</code>（将同步状态置为0，表示锁被释放）。</li><li>如果释放成功，AQS会通知等待队列中的下一个线程，使其可以重新尝试获取锁。</li></ul></li></ol><h4 id="共享模式（以CountDownLatch为例）"><a href="#共享模式（以CountDownLatch为例）" class="headerlink" title="共享模式（以CountDownLatch为例）"></a>共享模式（以CountDownLatch为例）</h4><ol><li><strong>获取资源（acquireShared）</strong><ul><li>在共享模式下，AQS通过<code>acquireShared()</code>来让多个线程共享资源。不同于独占模式，多个线程可能会同时获取到共享资源。</li><li><code>tryAcquireShared()</code>方法会尝试判断当前是否可以获取共享资源，如果可以，则立即返回，否则线程将加入等待队列并等待其他线程释放资源。</li></ul></li><li><strong>释放资源（releaseShared）</strong><ul><li>在共享模式下，AQS通过<code>releaseShared()</code>来释放共享资源。</li><li><code>tryReleaseShared()</code>会修改共享资源的状态，然后通知其他等待的线程，使它们可以继续获取资源。</li></ul></li></ol><h3 id="AQS中的关键方法"><a href="#AQS中的关键方法" class="headerlink" title="AQS中的关键方法"></a>AQS中的关键方法</h3><ol><li><strong><code>acquire(int arg)</code> 和 <code>acquireShared(int arg)</code></strong><ul><li>独占模式下，<code>acquire(int arg)</code>用于线程尝试获取资源。共享模式下，<code>acquireShared(int arg)</code>用于多个线程尝试共享资源。</li><li>如果资源不可用，线程将被阻塞并放入等待队列中。</li></ul></li><li><strong><code>release(int arg)</code> 和 <code>releaseShared(int arg)</code></strong><ul><li>独占模式下，<code>release(int arg)</code>用于释放资源。共享模式下，<code>releaseShared(int arg)</code>用于释放共享资源。</li><li>释放后，队列中的线程会被唤醒。</li></ul></li><li><strong><code>tryAcquire(int arg)</code> 和 <code>tryRelease(int arg)</code></strong><ul><li>这是子类实现的核心方法，用于定义如何获取和释放资源。AQS并没有直接实现这些方法，而是由具体的同步器（如ReentrantLock）来实现。</li></ul></li><li><strong><code>tryAcquireShared(int arg)</code> 和 <code>tryReleaseShared(int arg)</code></strong><ul><li>这也是子类实现的方法，用于共享模式下的资源获取与释放。具体的同步器如CountDownLatch会提供自己的实现。</li></ul></li></ol><h3 id="AQS如何实现线程阻塞与唤醒"><a href="#AQS如何实现线程阻塞与唤醒" class="headerlink" title="AQS如何实现线程阻塞与唤醒"></a>AQS如何实现线程阻塞与唤醒</h3><ul><li>当一个线程获取资源失败时，AQS会将该线程封装为一个Node并加入等待队列，同时调用<code>LockSupport.park()</code>方法阻塞该线程。</li><li>当资源被释放时，AQS会唤醒队列中下一个节点所代表的线程，唤醒的机制是通过<code>LockSupport.unpark()</code>实现的，这样该线程就可以继续执行并重新尝试获取资源。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>AQS基于状态和FIFO等待队列实现了同步机制</strong>。通过共享<code>state</code>状态变量和等待队列，多个线程可以安全地争用资源。</li><li><strong>独占模式和共享模式的灵活实现</strong>：通过不同的<code>acquire</code>和<code>release</code>方法，AQS支持多种同步机制的实现，如互斥锁、读写锁、信号量等。</li><li><strong>线程的阻塞与唤醒机制</strong>：通过<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>，AQS可以控制线程的阻塞与唤醒，确保线程间的有序通信。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【读书】哲学家们都干了些什么</title>
    <link href="/2023/12/28/%E3%80%90%E8%AF%BB%E4%B9%A601%E3%80%91%E5%93%B2%E5%AD%A6%E5%AE%B6%E4%BB%AC%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%20%EF%BC%88%E4%BF%AE%E8%AE%A2%E7%89%88%EF%BC%89/"/>
    <url>/2023/12/28/%E3%80%90%E8%AF%BB%E4%B9%A601%E3%80%91%E5%93%B2%E5%AD%A6%E5%AE%B6%E4%BB%AC%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%20%EF%BC%88%E4%BF%AE%E8%AE%A2%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 哲学家们都干了些什么？ （修订版）</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/10/3300013610/t7_3300013610.jpg" alt=" 哲学家们都干了些什么？ （修订版）|200"></li><li>书名： 哲学家们都干了些什么？ （修订版）</li><li>作者： 林欣浩</li><li>简介： 一部严谨却不严肃的哲学史！<br>宇宙的外面是什么？<br>世界会不会是假的？<br>我是不是活在虚拟世界&#x2F;别人的梦中？<br>上帝到底存在还是不存在？<br>这个世界有没有终极真理？<br>人生的意义是什么？<br>……<br>你知道吗，你想过或者没想过的这些奇奇怪怪的问题，早在几千年前就被哲学家们一本正经地提出，挖空心思地找证据，面红耳赤地争论过了。在整个世界忙着探索、开垦、打仗、上天、发展的漫长历史中，这帮哲学家们却神经质地死磕这个世界的真相和人生的意义，就好像一个网络游戏里的角色试图琢磨自己手里武器的代码是什么……<br>  翻开本书，从神烦的苏格拉底开始，了解哲学家们穷其一生苦思的问题及最终答案。</li><li>出版时间 2022-02-01 00:00:00</li><li>ISBN： 9787547742181</li><li>分类： 哲学宗教-哲学读物</li><li>出版社： 北京日报出版社</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="第一章-苏格拉底好讨厌"><a href="#第一章-苏格拉底好讨厌" class="headerlink" title="第一章 苏格拉底好讨厌"></a>第一章 苏格拉底好讨厌</h2><ul><li><p>📌 在被告人是否有罪这个问题上，陪审团是负责裁决的主角。法官才是陪衬，只能做做解释法律、引导庭审、剔除非法证据、维持法庭秩序之类的“服务”工作。 ^3300013610-50-1573-1643</p><ul><li>⏱ 2023-09-01 14:25:12</li></ul></li><li><p>📌 奢侈是什么？贵而无用就叫奢侈。而哲学这玩意儿超级无用。所以那个时代的人们一听说你是学哲学的，都狂羡慕。人家想：这人家里得多富裕才敢往哲学身上糟践钱啊。 ^3300013610-50-5955-6030</p><ul><li>⏱ 2023-09-01 14:30:32</li></ul></li></ul><h2 id="第二章-拯救哲学的少年国王"><a href="#第二章-拯救哲学的少年国王" class="headerlink" title="第二章 拯救哲学的少年国王"></a>第二章 拯救哲学的少年国王</h2><ul><li>📌 对于知识来说，宽容永远代表着光明。 ^3300013610-51-5671-5688<ul><li>⏱ 2023-09-03 00:22:46</li></ul></li></ul><h2 id="第三章-当哲学遇上宗教"><a href="#第三章-当哲学遇上宗教" class="headerlink" title="第三章 当哲学遇上宗教"></a>第三章 当哲学遇上宗教</h2><ul><li><p>📌 历史上有一个规律，在斗争中，哲学总站在弱者的一方。这是因为哲学讲思辨，讲道理，而只有弱者才会去讲理。强者不需要讲理。 ^3300013610-52-4562-4645</p><ul><li>⏱ 2023-09-03 00:28:58</li></ul></li><li><p>📌 宗教和哲学在根子上是无法协调的。宗教要求信仰，哲学要求怀疑，两者相悖。 ^3300013610-52-5188-5223</p><ul><li>⏱ 2023-09-03 15:22:31</li></ul></li><li><p>📌 上帝是善的，而上帝的善表现在上帝对人类的行为要进行公正的赏罚。既然要赏罚，前提是人类必须拥有自由意志，必须有能力自己选择行善还是作恶，否则人类就不应该对自己的行为负责。 ^3300013610-52-6617-6701</p><ul><li>⏱ 2023-09-11 09:05:56</li></ul></li><li><p>📌 宗教天生拒斥思考。 ^3300013610-52-7509-7518</p><ul><li>⏱ 2023-09-11 09:07:04</li></ul></li></ul><h2 id="第四章-哲学与基督教分道扬镳"><a href="#第四章-哲学与基督教分道扬镳" class="headerlink" title="第四章 哲学与基督教分道扬镳"></a>第四章 哲学与基督教分道扬镳</h2><ul><li>📌 有句俗话叫“能用钱解决的问题都不是问题”，其实还可以说一句话：“必须用暴力解决的问题都是解决不了的问题。”当强者对弱者使用暴力的时候，正说明强者没有别的招数可用了，也就说明他离失败不远了。政权屠杀革命者，说明政权快要灭亡。革命者反过来屠杀群众，说明革命即将失败。 ^3300013610-53-1579-1710<ul><li>⏱ 2023-09-11 09:46:00</li></ul></li></ul><h2 id="第七章-教会的权力有多大？"><a href="#第七章-教会的权力有多大？" class="headerlink" title="第七章 教会的权力有多大？"></a>第七章 教会的权力有多大？</h2><ul><li>📌 中国人对待宗教有更多实用主义的倾向，信宗教大多是为了要点儿好处。而且佛教说的是因果报应，就算你不信佛，多做好事也可以有好报。不像基督教讲人有原罪，光做好事没用，你不信仰基督不受洗就进不了天堂。中世纪的教会认为，刚出生的婴儿如果没来得及受洗就夭折了，那也是要下地狱的。 ^3300013610-56-2056-2189<ul><li>⏱ 2023-09-11 13:15:27</li></ul></li></ul><h2 id="第八章-哲学再次惨遭抛弃"><a href="#第八章-哲学再次惨遭抛弃" class="headerlink" title="第八章 哲学再次惨遭抛弃"></a>第八章 哲学再次惨遭抛弃</h2><ul><li><p>📌 垄断了对权威的解释权，就等于垄断了一切。 ^3300013610-57-4804-4824</p><ul><li>⏱ 2023-09-11 16:01:57</li></ul></li><li><p>📌 宗教改革最终以天主教和新教各占欧洲一半而告终。 ^3300013610-57-7738-7761</p><ul><li>⏱ 2023-09-11 16:06:39</li></ul></li></ul><h2 id="第九章-想做痛苦的苏格拉底，还是快乐的猪？"><a href="#第九章-想做痛苦的苏格拉底，还是快乐的猪？" class="headerlink" title="第九章 想做痛苦的苏格拉底，还是快乐的猪？"></a>第九章 想做痛苦的苏格拉底，还是快乐的猪？</h2><ul><li>📌 假如这世上存在一种让人易于接受，又能给人带来好处的道理，人们没有理由不把这个道理改写得通俗易懂，然后拼命到处传播呀。 ^3300013610-58-2647-2705<ul><li>⏱ 2023-09-11 16:10:19</li></ul></li></ul><h2 id="第十章-笛卡尔的疑问"><a href="#第十章-笛卡尔的疑问" class="headerlink" title="第十章 笛卡尔的疑问"></a>第十章 笛卡尔的疑问</h2><ul><li>📌 “我思”和“我在”不是因果关系，而是演绎推理的关系。也就是说：如果我们认为，“我正在思考”这件事是真的，那么可以推导出，“现在我存在”这件事是真的。而不是说“我不思考”的时候“我就不存在了”，存在不存在我们不知道。 ^3300013610-59-3272-3404<ul><li>⏱ 2023-09-11 18:49:15</li></ul></li></ul><h2 id="第十一章-“形而上学”不是个贬义词"><a href="#第十一章-“形而上学”不是个贬义词" class="headerlink" title="第十一章 “形而上学”不是个贬义词"></a>第十一章 “形而上学”不是个贬义词</h2><ul><li><p>📌 课本上的解释是：“形而上学就是用孤立、静止、片面的方式看待问题。” ^3300013610-60-1166-1199</p><ul><li>⏱ 2023-09-11 19:05:21</li></ul></li><li><p>📌 中文典出《易经》：“形而上者谓之道，形而下者谓之器。” ^3300013610-60-2187-2214</p><ul><li>⏱ 2023-09-11 19:06:54</li></ul></li><li><p>📌 那“形而上学”到底是什么意思呢？可以简单地理解成是用理性思维去研究那些能统一世间一切问题的“大道理”。 ^3300013610-60-2704-2755</p><ul><li>⏱ 2023-09-11 19:07:37</li></ul></li><li><p>📌 “世界的本质是什么”的问题，在哲学里又称作“本体论”。“哪些知识真实可信”的问题，在哲学里又称作“认识论”。 ^3300013610-60-4268-4349</p><ul><li>⏱ 2023-09-11 19:09:08</li></ul></li></ul><h2 id="第十二章-我的心灵与我的身体无关"><a href="#第十二章-我的心灵与我的身体无关" class="headerlink" title="第十二章 我的心灵与我的身体无关"></a>第十二章 我的心灵与我的身体无关</h2><ul><li>📌 更进一步说，二元论能帮助我们的关键是：我们在自己的精神世界里是无敌的，而一切体验归根结底都是精神体验。 ^3300013610-61-3061-3112<ul><li>⏱ 2023-09-11 20:33:01</li></ul></li></ul><h2 id="第十三章-寒冬夜行人斯宾诺莎的救赎"><a href="#第十三章-寒冬夜行人斯宾诺莎的救赎" class="headerlink" title="第十三章 寒冬夜行人斯宾诺莎的救赎"></a>第十三章 寒冬夜行人斯宾诺莎的救赎</h2><ul><li>📌 哲学史上有个不难理解的现象，生活越是困苦的哲学家，他的学说就越关注个人幸福。反之，生活富足的哲学家，学说更容易脱离现实。 ^3300013610-62-7316-7376<ul><li>⏱ 2023-09-12 00:02:15</li></ul></li></ul><h2 id="第十四章-科学派VS数学派"><a href="#第十四章-科学派VS数学派" class="headerlink" title="第十四章 科学派VS数学派"></a>第十四章 科学派VS数学派</h2><ul><li><p>📌 而科学的任务是探索自然界，获取新的知识。毫无疑问，数学是不可能完成这个任务的。归纳法是科学家们的唯一选择。 ^3300013610-63-2643-2696</p><ul><li>⏱ 2023-09-12 09:56:49</li></ul></li><li><p>📌 对于科学家们来说，数学是通向真理的桥梁，但不是真理本身。 ^3300013610-63-3207-3235</p><ul><li>⏱ 2023-09-12 09:57:58</li></ul></li><li><p>📌 洛克的哲学观点带有一部分政治内容。他是自由主义者，最痛恨独裁。所以洛克认为，如果像笛卡尔等人所说的，有一些真理是不言自明，是人先天就有的，那么这种观点可能会被独裁者利用。独裁者可以给人民灌输有利于自己统治的信仰，使得人民不懂得觉醒。 ^3300013610-63-4165-4281</p><ul><li>⏱ 2023-09-12 10:00:05</li></ul></li></ul><h2 id="第十五章-莱布尼茨的哲学论战"><a href="#第十五章-莱布尼茨的哲学论战" class="headerlink" title="第十五章 莱布尼茨的哲学论战"></a>第十五章 莱布尼茨的哲学论战</h2><ul><li><p>📌 我们还可以说，重视个别经验、对独断论充满警惕之心的经验主义，是英国人古板的民族性格的体现。而试图从万物根本一劳永逸地建立一个大一统理论的理性主义，正是荷兰和法国浪漫精神的代表。 ^3300013610-64-2042-2130</p><ul><li>⏱ 2023-09-12 11:48:58</li></ul></li><li><p>📌 我觉得，这正表明了理性主义者的弱点。因为理性主义者所有的结论都建立在不一定靠谱的公设上。只要公设、推理过程中有一点儿不可靠的东西，整个体系就不知道扯到哪里去了。最后得出来的结论也就很难让人信服了。 ^3300013610-64-6365-6463</p><ul><li>⏱ 2023-09-12 11:55:55</li></ul></li></ul><h2 id="第十七章-万物皆物理？"><a href="#第十七章-万物皆物理？" class="headerlink" title="第十七章 万物皆物理？"></a>第十七章 万物皆物理？</h2><ul><li><p>📌 简单地说，我们衡量某个学说、理论、定理是不是好用，有两个标准：第一看它能否准确地预测未来，第二看它是否足够简要。 ^3300013610-66-1291-1372</p><ul><li>⏱ 2023-09-12 15:33:37</li></ul></li><li><p>📌 机械论很好理解，我们在学校都学过辩证唯物主义。机械论就是除掉了辩证法之后的唯物主义，也可以叫作“机械唯物主义”。 ^3300013610-66-4055-4111</p><ul><li>⏱ 2023-09-12 15:37:08</li></ul></li></ul><h2 id="第十八章-你相信宿命吗？"><a href="#第十八章-你相信宿命吗？" class="headerlink" title="第十八章 你相信宿命吗？"></a>第十八章 你相信宿命吗？</h2><ul><li>📌 决定论对生活也有安慰作用。唯我论把人看得最大，可以安慰人。机械论和决定论把人看得渺小，也同样可以安慰人。 ^3300013610-67-4312-4364<ul><li>⏱ 2023-09-12 16:56:29</li></ul></li></ul><h2 id="第十九章-干掉因果律——休谟"><a href="#第十九章-干掉因果律——休谟" class="headerlink" title="第十九章 干掉因果律——休谟"></a>第十九章 干掉因果律——休谟</h2><ul><li><p>📌 因果律是什么呢？在经验世界里，我们可以把因果律说成：“如果A事件发生了，那么B事件一定会发生。”更严格的说法是：一　A事件发生在前，B事件发生在后。二　二者发生的关系是必然的。 ^3300013610-68-5753-5891</p><ul><li>⏱ 2023-09-12 22:33:58</li></ul></li><li><p>📌 罗素有一个比喻，说假设农场里有一只鸡，每次一看到农场主来，就被喂食物，那么这只鸡就会以为农场主和给它喂食之间有因果联系。但结果有一天，农场主带来的不是鸡食而是一把猎枪，农场主把鸡杀了。换句话说，鸡通过观察发现，农场主和喂食这两件事总在一起发生，便以为其中有因果关系。但实际上，耗费它毕生时间得到的观察结果，仍旧不能证明这两件事之间有必然联系或者因果关系。 ^3300013610-68-6880-7057</p><ul><li>⏱ 2023-09-12 22:36:18</li></ul></li><li><p>📌 从逻辑上还可以这么解释。两件事连在一起发生，发生了一回，经验只能告诉我们这是偶然的。那么无论这两件事连在一起发生了多少遍，它还是偶然发生的。因为再多次的偶然累计在一起也不可能把偶然变成必然。 ^3300013610-68-7082-7177</p><ul><li>⏱ 2023-09-12 22:36:39</li></ul></li><li><p>📌 休谟的意思是，我们在经验中发现的仅仅是相关性，永远无法发现因果性。 ^3300013610-68-7715-7748</p><ul><li>⏱ 2023-09-12 22:37:17</li></ul></li><li><p>📌 研究归纳法的前提，是必须相信存在因果律。 ^3300013610-68-8068-8088</p><ul><li>⏱ 2023-09-12 22:37:52</li></ul></li></ul><h2 id="第二十章-哲学遇到麻烦了"><a href="#第二十章-哲学遇到麻烦了" class="headerlink" title="第二十章 哲学遇到麻烦了"></a>第二十章 哲学遇到麻烦了</h2><ul><li>📌 怀疑主义者说“所有的话都必须被怀疑”的时候，还必须补上后半句“除了本句话之外”，要不就成了自相矛盾了。 ^3300013610-69-4446-4497<ul><li>⏱ 2023-09-12 22:44:25</li></ul></li></ul><h2 id="第二十一章-教会的衰落"><a href="#第二十一章-教会的衰落" class="headerlink" title="第二十一章 教会的衰落"></a>第二十一章 教会的衰落</h2><ul><li>📌 教权和王权之间有着尖锐的矛盾。在对抗中，教会唯一的武器是信仰，一旦这信仰被哲学、科学和民主思想慢慢消磨掉，教会的权力也就立刻萎缩，说话再也不好使了。 ^3300013610-70-10155-10229<ul><li>⏱ 2023-09-13 11:05:28</li></ul></li></ul><h2 id="第二十二章-宅男拯救哲学"><a href="#第二十二章-宅男拯救哲学" class="headerlink" title="第二十二章 宅男拯救哲学"></a>第二十二章 宅男拯救哲学</h2><ul><li><p>📌 。“先验”和“先天”差不多。意思是，先于经验，说某些东西是在人获得经验之前就存在的。这些东西不依赖于人的经验而存在，而且常常会决定着人的经验。显然，先天认识形式就是先验的。 ^3300013610-71-5650-5736</p><ul><li>⏱ 2023-09-13 11:32:05</li></ul></li><li><p>📌 康德的解决方法是，他把世界分成了两个部分。一个部分完全不可知，另一个部分则可以用理性把握。不可知的那部分因为永远不可知，所以对我们的生活没有什么影响。只要我们在可把握的世界里生活，理性就又恢复了威力。 ^3300013610-71-9705-9805</p><ul><li>⏱ 2023-09-13 13:39:45</li></ul></li><li><p>📌 他规定自己每天只抽一烟斗的烟，但是据说他的烟斗一年比一年大。 ^3300013610-71-15041-15071</p><ul><li>⏱ 2023-09-13 15:38:27</li></ul></li></ul><h2 id="第二十三章-哲学能囊括一切吗？"><a href="#第二十三章-哲学能囊括一切吗？" class="headerlink" title="第二十三章 哲学能囊括一切吗？"></a>第二十三章 哲学能囊括一切吗？</h2><ul><li><p>📌 在康德那里，世界的本质好像是一块石头，是静止不动的，等待别人来观察它。但是在黑格尔这里，世界的本质是在活动的，是自己在观察自己。 ^3300013610-72-3943-4007</p><ul><li>⏱ 2023-09-13 15:47:07</li></ul></li><li><p>📌 我们今天对辩证法有一种庸俗的理解，说辩证法就是“看待事物要分两个方面”。别人批评一个现象，我非要说“要辩证地看这件事，这件事也有好的一面嘛”。这是对辩证法的误读，这不叫辩证法，这叫诡辩法。它唯一的作用是把所有的事实都捣成一片糨糊，逃避有意义的讨论。 ^3300013610-72-4133-4257</p><ul><li>⏱ 2023-09-13 18:18:53</li></ul></li><li><p>📌 黑格尔认为，矛盾的双方虽然可以共存，但是处在互相冲突的动态之中。事物的正题和反题会发生强烈的冲突，这个冲突的结果并不是一方消灭另一方，而是正题和反题最终化为“合题”，进行了一次升华。因为所有的正题都可以找到它的反题，所以新的合题产生之后，它的反题也随之产生，这样就又产生了新的矛盾，又要有新的冲突和升华，再产生新的合题。这样，事物就不断地进化，最后达到最高等级，“绝对精神”自己认识了自己，整个人类也进步到最终的状态，哲学的使命也就完成了。 ^3300013610-72-5017-5262</p><ul><li>⏱ 2023-09-13 18:21:03</li></ul></li></ul><h2 id="第二章-悲观主义不悲观"><a href="#第二章-悲观主义不悲观" class="headerlink" title="第二章 悲观主义不悲观"></a>第二章 悲观主义不悲观</h2><ul><li><p>📌 叔本华还引用一句法国谚语，说明人们无止境的欲望：“更好是好的敌人。” ^3300013610-75-5332-5366</p><ul><li>⏱ 2023-09-13 19:52:10</li></ul></li><li><p>📌 王尔德说的，“人生有两大悲剧：一个是得不到想要的东西，另一个是得到了” ^3300013610-75-5516-5551</p><ul><li>⏱ 2023-09-13 19:52:32</li></ul></li></ul><h2 id="第四章-“上帝死了”"><a href="#第四章-“上帝死了”" class="headerlink" title="第四章 “上帝死了”"></a>第四章 “上帝死了”</h2><ul><li>📌 尼采特别反对这一点。他认为，同情弱者没错。但同情不能过度，弱者不能以此为理，去要挟、榨取强者，去拖强者的后腿，这样做是可耻的。 ^3300013610-77-4939-5002<ul><li>⏱ 2023-09-15 02:33:00</li></ul></li></ul><h2 id="第五章-克尔凯郭尔与“信仰的飞跃”"><a href="#第五章-克尔凯郭尔与“信仰的飞跃”" class="headerlink" title="第五章 克尔凯郭尔与“信仰的飞跃”"></a>第五章 克尔凯郭尔与“信仰的飞跃”</h2><ul><li><p>📌 这些人喜欢混在群体里，通过集体的暴行来彰显自己的强大 ^3300013610-78-3767-3793</p><ul><li>⏱ 2023-09-15 15:55:19</li></ul></li><li><p>📌 形而上学的目的是什么？是用理性的方法找到终极真理。这个真理至高无上，可以指导我们的一切行为。 ^3300013610-78-5783-5854</p><ul><li>⏱ 2023-09-15 15:57:58</li></ul></li></ul><h2 id="第六章-向科学求救"><a href="#第六章-向科学求救" class="headerlink" title="第六章 向科学求救"></a>第六章 向科学求救</h2><ul><li><p>📌 科学是坚持纯理性的。科学使用的是归纳法和演绎推理。所有的科学理论，都必须用理性的文字表达，都必须经得住严谨的实验。 ^3300013610-79-2113-2170</p><ul><li>⏱ 2023-09-15 15:59:54</li></ul></li><li><p>📌 随着科学成就的增加，人们相信科学可以解决一切问题。甚至有人提出来，以后没必要有哲学这个科目了。哲学问题不过都是人的心理活动而已，以后哲学只作为心理学的一个分支就足够了。这种用科学代替哲学的想法，被称为“科学主义”。 ^3300013610-79-3886-3993</p><ul><li>⏱ 2023-09-15 16:02:31</li></ul></li></ul><h2 id="第九章-罗素的幸福"><a href="#第九章-罗素的幸福" class="headerlink" title="第九章 罗素的幸福"></a>第九章 罗素的幸福</h2><ul><li><p>📌 他的名言是：“三种单纯又极其强烈的激情支配着我的一生：对爱情的渴望、对知识的追求，以及对于人类苦难不可遏制的同情。” ^3300013610-82-1579-1637</p><ul><li>⏱ 2023-09-16 09:59:56</li></ul></li><li><p>📌 “爱国就是为一些很无聊的理由去杀人或被杀” ^3300013610-82-1705-1726</p><ul><li>⏱ 2023-09-16 10:00:13</li></ul></li><li><p>📌 罗素回答：“不是我的孩子，是我老婆的。” ^3300013610-82-4948-4993</p><ul><li>⏱ 2023-09-16 10:08:24</li></ul></li></ul><h2 id="第十章-高富富富富富帅——维特根斯坦"><a href="#第十章-高富富富富富帅——维特根斯坦" class="headerlink" title="第十章 高富富富富富帅——维特根斯坦"></a>第十章 高富富富富富帅——维特根斯坦</h2><ul><li><p>📌 所以我们看历史，会看到有的人出身富家，继承巨额财产一辈子丰衣足食，而且长得还帅，还受到了良好的教育，还有好多艳遇，还高寿，吃喝玩乐一辈子，最后还有很大的成就，在艺术或者思想史上留下了名字（咦，这不就是罗素吗？）。所有的好事怎么都让他们给占了？你怎么着，还真没辙。 ^3300013610-83-1766-1897</p><ul><li>⏱ 2023-09-16 10:12:42</li></ul></li><li><p>📌 当时有人问他为什么把钱给自己的家人，怎么不给穷人啊。维特根斯坦回答说，金钱让人堕落，而他的亲人已经够堕落了，所以再堕落点儿也没关系。 ^3300013610-83-6217-6283</p><ul><li>⏱ 2023-09-16 10:18:24</li></ul></li><li><p>📌 有一次因为扁桃腺发炎住院，维特根斯坦来看她。这个女孩抱怨说：“我觉得自己像只被车碾过的狗。”结果维特根斯坦超级直男式地回答：“你根本就不知道一只被车碾过的狗是怎么感觉的。” ^3300013610-83-10268-10354</p><ul><li>⏱ 2023-09-16 10:23:25</li></ul></li></ul><h2 id="第十二章-哲学其实很实用"><a href="#第十二章-哲学其实很实用" class="headerlink" title="第十二章 哲学其实很实用"></a>第十二章 哲学其实很实用</h2><ul><li><p>📌 尼采说，真理和谬误其实全是虚构的，区分真理和谬误的关键是真理实用，而谬误不实用。 ^3300013610-85-1600-1640</p><ul><li>⏱ 2023-09-16 12:58:37</li></ul></li><li><p>📌 实际上，马克思当年为了维护工人阶级利益提出的很多要求，大部分都被资本主义国家接受并且实现了。 ^3300013610-85-3148-3194</p><ul><li>⏱ 2023-09-17 10:05:59</li></ul></li></ul><h2 id="第十三章-如何看穿伪科学？"><a href="#第十三章-如何看穿伪科学？" class="headerlink" title="第十三章 如何看穿伪科学？"></a>第十三章 如何看穿伪科学？</h2><ul><li><p>📌 换句话说，所有的科学理论都是一种假说，科学家没有办法证实任何一种科学理论[插图]。但是科学理论必须给别人提供验错的机会。在被检验出错误之前，我们就姑且相信这个科学理论是正确的。 ^3300013610-86-4409-4645</p><ul><li>⏱ 2023-09-17 10:13:25</li></ul></li><li><p>📌 因此，预测未来的历史规律，一劳永逸地设计一种绝对正确的政治制度，也是不可能的。用钱穆先生的话说：“制度须不断生长，又定须在现实环境要求下生长。”波普尔因此主张应当建立“开放社会”，要求执政者能够广泛接受意见，赋予大众质疑政策的权利。因为执政理论和科学理论一样，永远都可能是错的。必须不断地接受证伪，才能保证理论的正确。所以在波普尔等人看来，可以“纠错”才是现代民主思想的核心精神。有人可能会简单地以为，民主就是“大家一起投票，多数说了算”，就是“少数服从多数”。其实这种原始的民主制度有极大的缺陷，这个缺陷在雅典人判苏格拉底死刑、法国大革命的屠杀、希特勒被民众选上台等事件中已经暴露无遗，早就被现代社会抛弃了。 ^3300013610-86-7748-8103</p><ul><li>⏱ 2023-09-17 15:05:48</li></ul></li><li><p>📌 证伪主义的政治观，最关心的不是谁制定的政策，而是无论谁制定的政策，都不能成为绝对真理。不管是美国总统下的命令还是全世界人民投票的结果，都要给别人留出修改、推翻它的机会。 ^3300013610-86-8274-8358</p><ul><li>⏱ 2023-09-17 15:06:15</li></ul></li></ul><h2 id="第十四章-科学不为真理，只为实用？"><a href="#第十四章-科学不为真理，只为实用？" class="headerlink" title="第十四章 科学不为真理，只为实用？"></a>第十四章 科学不为真理，只为实用？</h2><ul><li><p>📌 这就好像我们生活中遇到的那种从来不懂得从根本上反省的人。他受了穷，就骂老板吝啬给他钱太少、商人太坏囤积居奇。要是怨不上老板商人，他就骂是政府太坏，要么是“社会的错”。要是赶上他还爱国怨不了国家，那还可以骂“一代不如一代了”“现在年轻人全都堕落了”。要是这些都骂不上，他还可以仰天大骂是老天不公，是命运不济。总之他遇到的所有坏事，都可以从别人身上找出无数理由，从而“严格地论证”出，他自己是不会出错的。 ^3300013610-87-2424-2624</p><ul><li>⏱ 2023-09-17 15:17:37</li></ul></li><li><p>📌 我们在筛选科学理论的时候，实用是唯一的标准。首位的要求是这个科学理论能够指导我们工作，不能够出错。其次，在不出错的基础上越简单易用越好。 ^3300013610-87-7080-7148</p><ul><li>⏱ 2023-09-17 16:30:21</li></ul></li><li><p>📌 科学就是我们在一堆科学假设中，挑出一个能够解释已有的实验和观测数据，而且表述尽量简单，还可以被证伪的理论。 ^3300013610-87-7323-7376</p><ul><li>⏱ 2023-09-17 16:30:49</li></ul></li></ul><h2 id="第十五章-为什么要相信科学？"><a href="#第十五章-为什么要相信科学？" class="headerlink" title="第十五章 为什么要相信科学？"></a>第十五章 为什么要相信科学？</h2><ul><li><p>📌 我们今天俗称的“西医”，严格地说要叫“现代医学”，指的是建立在科学结论的基础上，使用科学方法研究的医学。 ^3300013610-88-2692-2744</p><ul><li>⏱ 2023-09-18 11:42:43</li></ul></li><li><p>📌 我们今天俗称的“中医”，其实可以分成两部分。其中正规的中医学院、中医医院里使用的“中医”，已经学习了大量现代科学的思想，重视实验、重视统计，不排斥那些已经被广泛检验的科学成果（比如X光机）。这样的中医，在研究方法上和科学没有矛盾，也可以看成是“现代医学”。 ^3300013610-88-2827-2955</p><ul><li>⏱ 2023-09-18 11:43:00</li></ul></li><li><p>📌 但还有一种观点，认为“真正的中医”不能使用科学的方法，不能使用科学的结论，古代的典籍比现代的科技更正确，甚至认为正规的西医治疗是错的。这种主张，我们姑且称之为“民间医学”。 ^3300013610-88-2980-3066</p><ul><li>⏱ 2023-09-18 11:43:30</li></ul></li><li><p>📌 如果想证明“民间医学”比现代医学更有效，就必须在大范围内进行治疗实验。目前最好的方式是大样本随机双盲实验。做完实验一统计，对于某个病症，哪种治疗方法的效果更好，我们就选择哪种疗法。 ^3300013610-88-3536-3626</p><ul><li>⏱ 2023-09-18 11:44:23</li></ul></li><li><p>📌 “民间医学”的支持者有一种辩词，说过去的老方法已经流传了这么多年，还有这么多人相信，能说它没有效吗？我认为，这是一个有一定力量的辩护。流传时间越久、范围越广的理论，说明它积累的经验越多、经过的考验越多，的确可以增加它的可信度。但是这个辩护的力度还不够。首先，在现代医学进入中国以前，中国人只有民间医学，没有其他理论与之竞争。其次，今天很多中国人相信老方法，不仅是因为它有效，还有很多社会因素。就像有很多人相信宗教，但这并不能证明神迹一定是真的一样。所以这是一个不够强的证据。 ^3300013610-88-4054-4341</p><ul><li>⏱ 2023-09-18 11:45:42</li></ul></li><li><p>📌 有辩解说，每个人的身体情况都不一样，同样的病、同样的治疗方式在每个人身上的表现不同，怎么能用刻板的试验和冷冰冰的数字统计呢？——现代医学也认为每个人的身体情况都不一样，但还相信双盲实验，秘密就在“大样本”和“随机”这两个条件上。通过大样本的统计，可以消除个体差异，显示出真正的疗效。其实，强调每个人身体不同而不接受统计学的检验，就相当于承认自己的医术不可证伪。因为治疗好了，治疗者绝不可能说自己是蒙的，而是强调靠的是自己的医术。治不好，就说每个病人的具体情况不同。这是典型的不可证伪。 ^3300013610-88-6590-6832</p><ul><li>⏱ 2023-09-18 13:49:15</li></ul></li><li><p>📌 什么叫“迷信”呢？不经思考的相信，不允许别人质疑，就叫“迷信”。 ^3300013610-88-7671-7703</p><ul><li>⏱ 2023-09-18 14:26:11</li></ul></li></ul><h2 id="第十七章-人生荒诞、无意义吗？"><a href="#第十七章-人生荒诞、无意义吗？" class="headerlink" title="第十七章 人生荒诞、无意义吗？"></a>第十七章 人生荒诞、无意义吗？</h2><ul><li><p>📌 故事，是大部分人理解这个世界的方式。 ^3300013610-90-4858-4876</p><ul><li>⏱ 2023-09-18 14:08:33</li></ul></li><li><p>📌 用故事的方式记忆知识，对智力水平依赖程度低，知识不容易被遗忘，这在远古时代是最高效的，在现代也是最省力的方式。人生小感悟、心灵鸡汤这类用故事来说教的形式之所以最流行，就是这个缘故。 ^3300013610-90-4942-5032</p><ul><li>⏱ 2023-09-18 14:08:42</li></ul></li><li><p>📌 故事必须有开头，有冲突，有高潮，有结尾。 ^3300013610-90-5127-5147</p><ul><li>⏱ 2023-09-18 14:08:56</li></ul></li><li><p>📌 当人们面对亲朋好友的死亡时，尤其是年轻人的意外死亡时，人们会想：这就是人的一生？说结束就突然结束，好像还什么都没做，什么目的都没实现，就突然没了？那他到底算什么呢？——提最后这个问题的时候，其实是反省者在本能地要给死者没有目的的人生找一个目的，找一个总结。如果反省者一时找不到这个目的，那么就会对世界、对人生产生荒谬感。 ^3300013610-90-7480-7640</p><ul><li>⏱ 2023-09-18 14:11:59</li></ul></li><li><p>📌 第一，我的本质是不断变化的，我的每一个选择都在一点点地塑造我。如果你问：“你到底是什么？”我没法回答你，我就是我，一个正在前进的我。在心理学上，有一些人主张“寻找自我”，通过冥想、心理分析等办法，找到内心中的那个“真我”。在存在主义看来，这就是错的。根本没有一个固定不变的“真我”等着我寻找，“真我”是在我自己手中不断创造的。第二，我是独一无二的。既然我是我一切选择的总和，那我的本质就不可能用一两个词语、一两个标签来概括。我是一幅动态的画，我不是一个静态的词。所以，人生意义也不能由别人来告诉我。因为用语言说出来的人生意义，都是用有限的几个词语来描绘。这几个词无论是什么，肯定都是片面的。 ^3300013610-90-12010-12330</p><ul><li>⏱ 2023-09-18 14:17:09</li></ul></li><li><p>📌 真正的自由不是听从大众的选择 ^3300013610-90-12564-12578</p><ul><li>⏱ 2023-09-18 14:17:42</li></ul></li><li><p>📌 真正的自由也不是不经思考随便一选——假如我们的每一个决定都是通过掷骰子决定的，我们不会认为自己拥有自由意志。 ^3300013610-90-12618-12672</p><ul><li>⏱ 2023-09-18 14:17:49</li></ul></li><li><p>📌 真正的自由也不是听从自己的欲望——假如每一个决定都听从欲望，那我们就是最低等的动物了，那也不具备自由意志。 ^3300013610-90-12697-12750</p><ul><li>⏱ 2023-09-18 14:17:54</li></ul></li><li><p>📌 真正的自由意志，是经过认真思考后的结果。思考的是什么呢？思考的是我能不能为我的选择负责。当我选择看一部电视剧的时候，我认为这个选择是对的吗？我真愿意把自己生命中的几个小时献给这部电视剧，而不是用来做别的吗？当我选择拖延的时候，我愿意承担拖延的后果吗？我真心觉得拖延比不拖延好吗？ ^3300013610-90-12775-12914</p><ul><li>⏱ 2023-09-18 14:18:04</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>哲学宗教-哲学读物</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【教程02】GPT 辅助</title>
    <link href="/2023/11/02/GPT%20%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/11/02/GPT%20%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.promptgenius.site/">提示精灵-主页</a><br><a href="https://cookbook.openai.com/">OpenAI Cookbook</a><br><a href="https://articles.zsxq.com/id_1gr9k9156w4h.html">知识星球 </a><br><strong>一、核心要素</strong><br>向 GPT 有效提问，有个专业词叫 Prompt，核心动作就三个：任务、指令、角色。<br>任务指的是你提问的主题；<br>指令指的是你对主题的限制条件；<br>角色指的是你让 GPT 以什么角色来回答你的问题；</p><p>为了让 GPT 更能清楚我的指令，小林给出具体的规则，以及加上&lt;&gt;，&lt;&gt;的重点是让 GPT 意识到这是重点。<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231108233606.png" alt="image.png|500"></p><p><a href="https://futureforce.feishu.cn/file/CMpdbLxAhon5K5x5C1OcciYwnOf">OpenAI:GPT 最佳实践中文大白话版本</a></p><ol><li>清晰告诉GPT想要什么<ol><li>输入越清晰越具体越好</li><li>要长输出还是短输出，指单词数、句子数、段落数等，一个汉字大概是2~2.5个tokens，100个tokens带个是75个单词，可以统一规定输出是多少tokens</li><li>要专家级输出还是简单输出</li><li>嫌输出格式不好，那就给个样例</li><li>角色扮演一直好用</li><li>使用分隔符把话和话分开，三引号、xml标记也可以，主要是为了区分出不同文本</li><li>展开解题步骤</li><li>多给几个例子</li></ol></li><li>给GPT发阅读材料<ol><li>要求按阅读材料作答，不开放作答</li><li>增加要求：要求GPT将阅读材料中的原文引用出来</li></ol></li><li>把复杂任务拆解成子任务</li><li>时不时对以上的对话内容进行总结，做个前情提要</li><li>如果GPT没有输出完全，可以告诉他“哎，还没做完呢”</li></ol><h1 id="提示词教程"><a href="#提示词教程" class="headerlink" title="提示词教程"></a>提示词教程</h1><p><a href="https://zhuanlan.zhihu.com/p/625565256">[Misc] 科研实用 ChatGPT Prompts&#x2F;Tricks - 知乎</a><br><a href="https://www.zhihu.com/question/592937997/answer/2962566176">chatgpt学术提问模板有哪些？chatgpt的prompt有哪些？ - 知乎</a><br><a href="https://www.zhihu.com/question/593971202/answer/2972199269">你在使用ChatGPT进行论文润色时的指令有哪些? - 知乎</a><br><a href="https://b.ai6868.top/?p=354">ChatGPT 100条 指令大全 更能解决你的问题！ChatGPT 万能指令(必看)！！！ - GPT 账号网</a><br><a href="https://www.promptingguide.ai/zh">提示工程指南 | Prompt Engineering Guide</a><br><a href="https://www.promptgenius.site/">提示精灵-主页</a></p><h1 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h1><h2 id="了解、检索新的研究领域"><a href="#了解、检索新的研究领域" class="headerlink" title="了解、检索新的研究领域"></a>了解、检索新的研究领域</h2><p>场景：</p><ul><li><ol><li>你想了解一个新的研究领域，或</li></ol></li><li><ol start="2"><li>你对一个特定技术感兴趣，但不知道该技术是否&#x2F;在哪些领域被讨论过。<br>示例Prompt:</li></ol></li><li><ol><li>I’m a researcher working in [研究领域], can you introduce me the field of [你感兴趣的子领域] from the perspective of XXX, XXX, and [其他解释角度] ?</li></ol></li><li><ol start="2"><li>I’m a researcher working in [研究领域]. I’m thinking of [感兴趣的技术方案的描述]. Has this strategy been discussed in the related research literature? If so, show me some examples of how existing works achieved this.</li></ol></li></ul><h2 id="获取参考文献"><a href="#获取参考文献" class="headerlink" title="获取参考文献"></a>获取参考文献</h2><p>ChatGPT经常会使用&#x2F;给出不存在的参考文献，使用以下prompt可以很大程度上避免这种情况发生：<br>Please attach all your references at the last in [你想要的格式] format. Make sure that they can be found on Google Scholar.</p><h2 id="润色语言"><a href="#润色语言" class="headerlink" title="润色语言"></a>润色语言</h2><p>场景：</p><ul><li><ol><li>论文写作润色，</li></ol></li><li><ol start="2"><li>Rebuttal&#x2F;邮件润色。</li></ol></li><li>1）I’m a researcher working in [研究领域]. I want you to act as an English translator, spelling corrector, and improver. Please polish my text to meet the academic standard in my research area, your goal is to improve the spelling, grammar, <a href="https://www.zhihu.com/search?q=clarity&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222972199269%22%7D">clarity</a>, concision, and overall readability. When necessary, rewrite the whole sentence. Furthermore, list all modifications and explain the reasons to do so in a markdown table. Now please polish the following text: [文本]</li></ul><ol start="2"><li>I’m doing a rebuttal for a paper submitted to a venue in the field of [研究领域]. My goal is to answer reviewers’ questions in polite, professional, and academic language. Following these standards, please help me correct the grammar mistakes and make the language more natural and fluent, and keep the meaning of the sentences if possible. Following is the text to be rephrased: [文本]</li><li>请帮我润色我的论文。我需要进行语法和拼写检查，优化句子结构和表达，调整逻辑和结构，确保学术用语和术语准确，检查引用和参考文献格式，调整风格和语气，补充和删除必要的内容，检查图表和图示，确认格式和排版是否正确。[在这里粘贴您的论文] 请在润色过程中提供详细的反馈和建议，以指导您的修改。谢谢！</li><li>请你现在扮演一个[这里放你所研究的领域] 领域的专家，从专业的角度，您认为上面这些内容是否有需要修改的地方？注意，不要全文修改，您需要一一指出需要修改的地方，并且给出修改意见以及推荐的修改内容。</li><li>Prompt: I want you to act as an academic journal editor. Please rephrase the paragraph from an academic angle based on the writing style of the Nature journal.</li></ol><h2 id="简单修改"><a href="#简单修改" class="headerlink" title="简单修改"></a>简单修改</h2><ol><li>Prompt: Please rewrite and revise this paragraph in Chinese</li></ol><h2 id="起标题"><a href="#起标题" class="headerlink" title="起标题"></a>起标题</h2><ol><li>Prompt: I am writing a scientific paper. Can you help me think a good acronym of the following topic: A New low power Implantable Wireless Brain Machine Interface.</li><li>Prompt: “ALOWIBMI” is not good. can you find other one with positive meaning?</li></ol><h2 id="催稿"><a href="#催稿" class="headerlink" title="催稿"></a>催稿</h2><ol><li>Prompt: I am a graduate student. I want to write an email to the reviewer of Nature journal to ask him to accelerate the review process of my submitted paper.</li></ol><h2 id="简写-降低重复率"><a href="#简写-降低重复率" class="headerlink" title="简写&#x2F;降低重复率"></a>简写&#x2F;降低重复率</h2><p>Prompt: </p><ul><li>1）Please keep your answer concise and less ChatGPT-like.</li><li>2）请你充当一位[某个]领域的专家，对文本去重。如果文本中连续13个字一样，就算重复。你需要通过调整主谓宾语序替换同义词、增减字数等方法，来达到论文去重的目的。请你修改下面这段文字：[文本内容]</li></ul><h2 id="内容扩写"><a href="#内容扩写" class="headerlink" title="内容扩写"></a>内容扩写</h2><p>Prompt： 请你参考[某某领域]同类论文，帮我在[研究背景和意义]这一级目录下面，再增加三个子目录，并写出三个子目录的主要内容。</p><h2 id="优化语法句法"><a href="#优化语法句法" class="headerlink" title="优化语法句法"></a>优化语法句法</h2><p>Prompt：[文本内容]这段文本在语法上是不正确的，请你修改这段文本。<br>Prompt：[文本内容]这段文本的主语和动词在这句话中不一致，请你改正这段文本。<br>Prompt：[文本内容]这段文本似乎不合适，请你重新措辞以表达更清晰。<br>Prompt：[文本内容]我在这段文本中使用了被动语态，请你考虑改用主动语态。</p><h2 id="内容改写"><a href="#内容改写" class="headerlink" title="内容改写"></a>内容改写</h2><p>Prompt：[文本内容]请你对文本进行微调。<br>Prompt：[文本内容]请你提高文本流畅度和连贯性。<br>Prompt：[文本内容]请你重新构建内容。</p><h2 id="理解code"><a href="#理解code" class="headerlink" title="理解code"></a>理解code</h2><ol><li>Prompt: What does the following code do? [insert code here]</li><li>你现在是一个 [程式语言] 专家，请告诉我以下的程式码在做什么。[附上程式码]</li></ol><h2 id="重构code"><a href="#重构code" class="headerlink" title="重构code"></a>重构code</h2><ol><li>你现在是一个 Clean Code 专家，我有以下的程式码，请用更干净简洁的方式改写，让我的同事们可以更容易维护程式码。另外，也解释为什么你要这样重构，让我能把重构的方式的说明加到 Pull Request 当中。[附上程式码]</li></ol><h2 id="改bug"><a href="#改bug" class="headerlink" title="改bug"></a>改bug</h2><ol><li>你现在是一个 [程式语言] 专家，我有一段程式码，我预期这段程式码可以 [做到某个功能]，只是它通过不了 [测试案例] 这个测试案例。请帮我找出我哪里写错了，以及用正确的方式改写。[附上程式码]</li></ol><h2 id="写测试"><a href="#写测试" class="headerlink" title="写测试"></a>写测试</h2><ol><li>你现在是一个 [程式语言] 专家，我有一段程式码 [附上程式码]，请帮我写一个测试，请至少提供五个测试案例，同时要包含到极端的状况，让我能够确定这段程式码的输出是正确的。</li></ol><h2 id="给代码添加注释"><a href="#给代码添加注释" class="headerlink" title="给代码添加注释"></a>给代码添加注释</h2><ol><li>Prompt: Add comments to the following code [insert code here]</li></ol><h2 id="设计神经网络"><a href="#设计神经网络" class="headerlink" title="设计神经网络"></a>设计神经网络</h2><p>下面是我的需求（比较零散、没有考虑逻辑顺序的、头脑风暴后的结果，）： 1、学习、实践并且自己构建深度学习的神经网络，主要使用Pytorch框架，构建中可能需要掌握的知识比如：卷积核计算公式、其他等等 2、根据实际问题，需要调整神经网络哪里会有比较好的效果，我们着重在自己构建网络、修改别人的网络、利用别人的网络&#x2F;经典的网络解决具体算法应用问题 3、我会上传一段之前与ChatGPT大模型的对话内容，其中包含了我某些方面的需求，你可以初步知道我总需求中的小需求之一 4、定制辅导：你是一位长时间伴随我达成上述目标的导师，所以你要自己学习，回顾我们所有的对话，根据我的所有提问，推测我在神经网络学习与实践方面的水平，然后你以后的回答做出相应的调整或者优化网络 5、我在某些时候可能会要求你提出完整训练代码，包括训练测试评估等等，还有我会向你提供训练评估结果，你告诉我怎么调参 6、哪些工具&#x2F;网站代码&#x2F;python第三方库&#x2F;帮助构建、查看模型结构、网络可视化、训练评估可视化或者其他帮助的工具网站 7、根据我上面的需求，你可以建议我还可以提哪些需求</p><p>我总结一下应该着重关注的主要需求： 第一重要：实践构建应用神经网络； 第二重要：根据实践中的问题修改优化网络、优化训练技巧、调参；</p><p>Here are my needs (relatively scattered, without considering the logical order, the result of brainstorming):</p><ol><li>Learn, practice and build deep learning neural network by yourself, mainly using the Pytorch framework, the knowledge that may need to be mastered in the construction, such as convolution kernel calculation formula, etc.</li><li>According to the actual problems, where the neural network needs to be adjusted to have better effects, we focus on building our own network, modifying others’ network, and using others’ network&#x2F;classic network to solve specific algorithm application problems.</li><li>I will upload a previous dialogue with the ChatGPT large model, which contains some aspects of my needs, so you can preliminarily know one of the small needs in my total needs.</li><li>Customized tutoring: you are a long-time mentor who accompanied me to achieve the above goals, so you have to learn by yourself, review all our conversations, and estimate my level of neural network learning and practice according to all my questions, and then make corresponding adjustments or optimize the network in your future answers.</li><li>At some point, I may ask you to provide complete training code, including training test evaluation, etc., and I will provide you with the training evaluation results, and you tell me how to adjust the parameters. 6. Which tools&#x2F;website code&#x2F;python third-party libraries&#x2F;tools&#x2F;websites help build, view model structure, network visualization, training evaluation visualization or other help?</li><li>According to my requirements above, can you suggest what requirements I can also mention?</li></ol><p>I summarize the main requirements that should be focused on: First important: practice building applied neural networks; Second important: modify and optimize the network according to the problems in practice, optimize training techniques, adjust parameters;</p><h1 id="英文表述"><a href="#英文表述" class="headerlink" title="英文表述"></a>英文表述</h1><ul><li>“Subtle edits only”: 仅对文本进行微调</li><li>“Minor edits”: 进行一些小的编辑</li><li>“Rephrase for clarity”: 改写以提高表达清晰度</li><li>“Simplify sentence structure”: 简化句子结构</li><li>“Check grammar and spelling”: 检查语法和拼写</li><li>“Enhance flow and coherence”: 提高文本流畅度和连贯性</li><li>“Improve word choice”: 改善用词</li><li>“Revise for style”: 为文本调整风格</li><li>“Significant edits”: 进行重大编辑</li><li>“Restructure content”: 重新构建内容</li></ul><h1 id="账号购买"><a href="#账号购买" class="headerlink" title="账号购买"></a>账号购买</h1><p><a href="https://buy.doudianpu.com/">ChatGPT 成品号特价 - 稳定、可靠</a><br><a href="https://nf.video/">银河录像局 次世代合租平台</a><br><a href="https://naifeistation.com/?invite=216">星际放映厅-专业级流媒体合租平台</a><br><a href="https://api.ycestore.com/buy/4">ChatGPT Plus 代升级 | GPT-4.0 解锁开通 | 正规 Visa&#x2F;MasterCard 信用卡 | 可续费 | 永久质保 | 老王的2号杂货铺</a><br><a href="https://bento.me/xydzip">微信foryglin 支持淘宝</a><br><a href="https://m.ai6868.top/buy/5">ChatGPT -4 Plus账号【更懂你的AI】拼车 30天 | CHATGPT 账号网 最新ChatGPT注册方法教程【ChatGPT账号购买】</a><br><a href="https://link3.cc/aichatgpt">AI意识觉醒 | Link3</a><br><a href="http://www.hxdgpt.com/">首页 | chatgpt账号推送</a></p><h1 id="GPT网站"><a href="#GPT网站" class="headerlink" title="GPT网站"></a>GPT网站</h1><p><a href="https://chatglm.cn/main/detail">智谱清言</a> 中文、对话、文档、代码<br><a href="https://docsgpt.arc53.com/">Site Unreachable</a><br><a href="https://app.writesonic.com/library/a2ad892a-bcc4-44c1-9d11-56682fc14a2d/all">app.writesonic.com&#x2F;login</a><br><a href="https://www.chatyy.com/search">ChatYY</a><br><a href="https://hi.zhangsan.cloud/chat">Ai Loading</a><br><a href="https://toolai.io/zh/">ToolAI 全球最完整最全面的AI人工智能工具集合</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【教程03】Windows 设置不显示时间</title>
    <link href="/2023/11/02/windows%20%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/"/>
    <url>/2023/11/02/windows%20%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<ol><li>控制面板<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006193816.png" alt="image.png"></li><li>其他设置<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006193842.png" alt="image.png|500"></li><li>修改短时间为s<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006193942.png" alt="image.png|458"></li><li>如果想重新显示时间，点击重置<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006194028.png" alt="image.png|175"></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【教程01】cheat engine使用指南</title>
    <link href="/2023/08/26/cheat%20engine%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/08/26/cheat%20engine%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>备注：文章采用的例子是肥鹅健身房，并不是一个好例子，因为虽然明面上修改了，实际上并没有，毕竟是流水很大的游戏了，这些数据肯定是进服务器校验的，没给封号就已经算仁慈了。但是，有一些游戏是可以永久性修改的，也实验成功了，暂时还没去深究底层原理是什么。</p><ol><li><p>电脑端打开小游戏程序<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006114504.png" alt="image.png|500"></p></li><li><p>ctrl+alt+delete打开任务管理器，找到微信<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115934.png" alt="image.png|500"><br>展开<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115959.png" alt="image.png|225"><br>随便选一个右键，选择转到详细信息<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006120021.png" alt="image.png|355"><br>找到占用内存最多的程序对应的PID值，23640<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006120117.png" alt="image.png|500"><br>23640的十六进制值为5C58<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006120231.png" alt="image.png|475"></p></li><li><p>打开 cheat engine<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006114638.png" alt="image.png|500"></p></li><li><p>打开进程列表，选择“当前进程”，找到5C58对应的进程，打开<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006120346.png" alt="image.png|500"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006114848.png" alt="image.png|500"></p></li><li><p>找到要修改的数据，比如能量是316，在cheat engine中的数值框中输入316*2后的结果<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115248.png" alt="image.png|950"></p></li><li><p>首次扫描<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115343.png" alt="image.png|473"><br>右边会显示扫描结果<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115412.png" alt="image.png|500"></p></li><li><p>在小游戏中让能量值发生变化<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115537.png" alt="image.png|446"><br>比如，由之前的316变成了315<br>接下来在cheat engine中修改数值为315*2后的结果630，点击再次扫描<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20231006115655.png" alt="image.png|500"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习01】如何理解接口和抽象类</title>
    <link href="/2023/08/26/%E3%80%90%E5%AD%A6%E4%B9%A001%E3%80%91%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <url>/2023/08/26/%E3%80%90%E5%AD%A6%E4%B9%A001%E3%80%91%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>接口（Interface）和抽象类（Abstract Class）是Java中两种常用的概念，它们都用于定义一个类的规范，让不同的类可以实现或继承它们，从而共享一些相同的行为。但是，它们有一些重要的区别和不同的应用场景。</p><h3 id="1-接口和抽象类的区别："><a href="#1-接口和抽象类的区别：" class="headerlink" title="1. 接口和抽象类的区别："></a>1. <strong>接口和抽象类的区别</strong>：</h3><p><strong>接口（Interface）</strong>：</p><ul><li><strong>纯行为规范</strong>：接口就像是一个完全抽象的蓝图，它规定了一些方法，但这些方法没有具体实现。它只是告诉类：“你要实现这些功能。” </li><li><strong>多继承</strong>：一个类可以实现多个接口，这就像你能同时具备多个技能。</li><li><strong>没有状态</strong>：接口里不能有具体的属性（字段），也就是说，接口不能有“状态”，它只能定义行为。<br><strong>抽象类（Abstract Class）</strong>：</li><li><strong>部分实现</strong>：抽象类可以包含已经实现的方法和没有实现的方法（抽象方法），所以它比接口更灵活一点。它就像是一个半成品，子类可以继承并补充或重写它的部分功能。</li><li><strong>单继承</strong>：一个类只能继承一个抽象类，这就像你只能有一个“父类”，但是可以有多个技能（接口）。</li><li><strong>可以有状态</strong>：抽象类可以定义属性，子类可以继承这些属性，也就是说，抽象类可以保存一些“状态”或数据。</li></ul><h3 id="2-应用场景："><a href="#2-应用场景：" class="headerlink" title="2. 应用场景："></a>2. <strong>应用场景</strong>：</h3><ul><li><strong>接口的应用场景</strong>：<br>接口适合用在多个类需要实现某些功能，但这些类可能没有直接的继承关系时。例如，在一个公司里，员工、经理和实习生可能都是不同类型的类，但他们都有“工作”这一行为，那么可以通过接口来统一规范“工作”的方法。每个类根据自己的职责实现工作的方法。</li><li><strong>抽象类的应用场景</strong>：<br>抽象类适合用在有明显继承关系的场景下，比如动物这个抽象类。不同的动物有共同的属性（比如名字、年龄）和一些共同的行为（比如吃饭），但是具体吃什么饭是由不同动物决定的。所以抽象类可以定义通用属性和一些默认行为，子类可以继承和扩展。</li></ul><h3 id="3-我对接口和抽象类的理解："><a href="#3-我对接口和抽象类的理解：" class="headerlink" title="3. 我对接口和抽象类的理解："></a>3. <strong>我对接口和抽象类的理解</strong>：</h3><p>接口更像是告诉类必须具备哪些能力，而抽象类则是提供了一些基础框架，类可以继承并在这个基础上扩展。接口注重“规范”——约定你必须做哪些事；抽象类注重“模板”——我给你一些基本的实现，剩下的你自己完善。</p><h3 id="4-我怎么使用它们："><a href="#4-我怎么使用它们：" class="headerlink" title="4. 我怎么使用它们："></a>4. <strong>我怎么使用它们</strong>：</h3><ul><li><strong>使用接口</strong>：当我需要确保某些类都实现同样的功能，而这些类可能没有其他共同点时，我会使用接口。例如，做一个支付系统时，不同的支付方式（比如微信支付、支付宝支付）都要实现“支付”这个接口，但它们之间可能没有其他联系。</li><li><strong>使用抽象类</strong>：当我有一组类有很多共同点时，我会选择抽象类。例如，在电商系统中，商品类（Product）可能是一个抽象类，所有具体的商品（比如书籍、电子产品）都可以继承它，并扩展一些特定功能。<br>总结一下，接口更多是定义“你应该做什么”，抽象类则是“我帮你做了一些，你继续完善”。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java学习日志</title>
    <link href="/2023/06/28/%E9%9F%A9%E9%A1%BA%E5%B9%B3JAVA/"/>
    <url>/2023/06/28/%E9%9F%A9%E9%A1%BA%E5%B9%B3JAVA/</url>
    
    <content type="html"><![CDATA[<h1 id="2-java概述"><a href="#2-java概述" class="headerlink" title="2.java概述"></a>2.java概述</h1><h2 id="2-3-java技术体系平台"><a href="#2-3-java技术体系平台" class="headerlink" title="2.3 java技术体系平台"></a>2.3 java技术体系平台</h2><ol><li>java SE 标准版</li><li>java EE 企业版</li><li>java ME 小型版</li></ol><h2 id="2-4-java-重要特点"><a href="#2-4-java-重要特点" class="headerlink" title="2.4 java 重要特点"></a>2.4 java 重要特点</h2><ol><li>面向对象 oop</li><li>强壮的。强类型机制、异常处理、垃圾自动收集<ol><li>强类型：变量必须声明类型后才能使用</li></ol></li><li>跨平台。</li><li>解释型语言。</li></ol><h2 id="2-6-java运行机制和运行过程"><a href="#2-6-java运行机制和运行过程" class="headerlink" title="2.6 java运行机制和运行过程"></a>2.6 java运行机制和运行过程</h2><h3 id="2-6-2-java核心机制-java虚拟机-JVM"><a href="#2-6-2-java核心机制-java虚拟机-JVM" class="headerlink" title="2.6.2 java核心机制-java虚拟机 JVM"></a>2.6.2 java核心机制-java虚拟机 JVM</h3><ol><li>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK 中.</li><li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li><li>java -&gt; 编译javac -&gt; .class -&gt; 运行java</li></ol><h2 id="2-7-什么是JDK、JRE"><a href="#2-7-什么是JDK、JRE" class="headerlink" title="2.7 什么是JDK、JRE"></a>2.7 什么是JDK、JRE</h2><h3 id="2-7-1-JDK"><a href="#2-7-1-JDK" class="headerlink" title="2.7.1 JDK"></a>2.7.1 JDK</h3><ol><li>Java Development Kit。JAVA开发工具包</li><li>JDK &#x3D; JRE + java 的开发工具 [java, javac,javadoc,javap 等]</li><li>JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。</li></ol><h3 id="2-7-2-JRE"><a href="#2-7-2-JRE" class="headerlink" title="2.7.2 JRE"></a>2.7.2 JRE</h3><ol><li>Java Runtime Environment。Java 运行环境</li><li>JRE &#x3D; JVM + Java 的核心类库[类]</li></ol><h3 id="2-7-3-JDK、JRE和JVM包含关系"><a href="#2-7-3-JDK、JRE和JVM包含关系" class="headerlink" title="2.7.3 JDK、JRE和JVM包含关系"></a>2.7.3 JDK、JRE和JVM包含关系</h3><ol><li>JDK &#x3D; JRE + 开发工具集</li><li>JRE &#x3D; JVM + Java SE 标准类库</li></ol><h2 id="2-13-Java开发注意事项和细节"><a href="#2-13-Java开发注意事项和细节" class="headerlink" title="2.13 Java开发注意事项和细节"></a>2.13 Java开发注意事项和细节</h2><ol><li>严格区分大小写</li><li>一个源文件最多只能有一个public类</li><li>public类，则文件名必须按该类名命名</li></ol><h2 id="2-15-转义字符"><a href="#2-15-转义字符" class="headerlink" title="2.15 转义字符"></a>2.15 转义字符</h2><h3 id="2-15-1-常用的转义字符"><a href="#2-15-1-常用的转义字符" class="headerlink" title="2.15.1 常用的转义字符"></a>2.15.1 常用的转义字符</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\t</span>  一个制表位，实现对齐的功能<br><span class="hljs-string">\n</span> ：换行符<br><span class="hljs-string">\\</span> ：一个<span class="hljs-string">\</span><br><span class="hljs-string">\r</span> :一个回车<br></code></pre></td></tr></table></figure><h2 id="2-19-DOS命令"><a href="#2-19-DOS命令" class="headerlink" title="2.19 DOS命令"></a>2.19 DOS命令</h2><h3 id="2-19-3-常用的DOS命令"><a href="#2-19-3-常用的DOS命令" class="headerlink" title="2.19.3 常用的DOS命令"></a>2.19.3 常用的DOS命令</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dos">查看当前目录是有什么内容 <span class="hljs-built_in">dir</span><br>切换到其他盘下：盘符号 <span class="hljs-built_in">cd</span> : change directory<br>切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\表示上一级目录<br>切换到根目录：<span class="hljs-built_in">cd</span> \<br>查看指定的目录下所有的子级目录 <span class="hljs-built_in">tree</span><br>清屏 <span class="hljs-built_in">cls</span><br></code></pre></td></tr></table></figure><h1 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h1><h2 id="3-6-数据类型"><a href="#3-6-数据类型" class="headerlink" title="3.6 数据类型"></a>3.6 数据类型</h2><ol><li>java数据类型分为两大类：基本数据类型、引用类型<ol><li>基本数据类型<ol><li>整数类型：byte 1, short 2, int 4, long 8</li><li>浮点类型：float 4, doublue 8</li><li>字符型：char</li><li>布尔型：boolean</li></ol></li><li>引用类型<ol><li>类：class</li><li>接口：interface</li><li>数组：[]</li></ol></li></ol></li></ol><h2 id="3-8-浮点类型"><a href="#3-8-浮点类型" class="headerlink" title="3.8 浮点类型"></a>3.8 浮点类型</h2><h2 id="3-8-4"><a href="#3-8-4" class="headerlink" title="3.8.4"></a>3.8.4</h2><ol><li>浮点数&#x3D;符号位+指数位+尾数位</li></ol><h3 id="3-8-5-浮点数使用细节"><a href="#3-8-5-浮点数使用细节" class="headerlink" title="3.8.5 浮点数使用细节"></a>3.8.5 浮点数使用细节</h3><ol><li>浮点数常量有两种表现形式：<ol><li>十进制：5.12    5.12f   .512</li><li>科学计数法：5.12e2   5E2</li></ol></li><li>通常情况下，使用double</li></ol><h2 id="3-9-Java-Api-文档"><a href="#3-9-Java-Api-文档" class="headerlink" title="3.9 Java Api 文档"></a>3.9 Java Api 文档</h2><p><a href="https://itmyhome.com/java-api/">Java API中文在线文档 - itmyhome</a></p><h2 id="3-10-字符类型"><a href="#3-10-字符类型" class="headerlink" title="3.10 字符类型"></a>3.10 字符类型</h2><h3 id="3-10-3"><a href="#3-10-3" class="headerlink" title="3.10.3"></a>3.10.3</h3><ol><li>使用单引号括起来</li><li>允许赋值转义字符：char a &#x3D; ‘\n’</li><li>java中，char本质是一个整数，可以进行运算</li><li>可以赋值一个整数，输出对应的Unicode编码</li><li>a是97</li></ol><h2 id="3-15-基本数据类型转换"><a href="#3-15-基本数据类型转换" class="headerlink" title="3.15 基本数据类型转换"></a>3.15 基本数据类型转换</h2><h3 id="3-15-1-自动类型转换"><a href="#3-15-1-自动类型转换" class="headerlink" title="3.15.1 自动类型转换"></a>3.15.1 自动类型转换</h3><ol><li>char -&gt; int -&gt; long -&gt; float -&gt; double</li><li>byte -&gt;  short -&gt; int -&gt; long -&gt; float -&gt; double</li></ol><h3 id="3-15-4-强制类型转换细节"><a href="#3-15-4-强制类型转换细节" class="headerlink" title="3.15.4 强制类型转换细节"></a>3.15.4 强制类型转换细节</h3><ol><li>强制转换符号()只针对最近的操作数</li></ol><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h1><h3 id="4-8-标识符命名规范"><a href="#4-8-标识符命名规范" class="headerlink" title="4.8 标识符命名规范"></a>4.8 标识符命名规范</h3><ol><li>包名：都是小写 aa.bb.cc</li><li>类名、接口名：大驼峰 XxxYyyZzz</li><li>变量名、方法名：小驼峰 xxxYyyZzz</li><li>常量名：所有字母都大写 X_Y_Z</li></ol><h2 id="4-12-进制"><a href="#4-12-进制" class="headerlink" title="4.12 进制"></a>4.12 进制</h2><h3 id="4-12-1-进制介绍"><a href="#4-12-1-进制介绍" class="headerlink" title="4.12.1 进制介绍"></a>4.12.1 进制介绍</h3><ol><li>二进制：0b或0B开头</li><li>八进制：0开头</li><li>十六进制：0x或0X开头，A-F不区分大小写</li></ol><h2 id="4-27-原码、反码、补码"><a href="#4-27-原码、反码、补码" class="headerlink" title="4.27 原码、反码、补码"></a>4.27 原码、反码、补码</h2><ol><li>二进制最高位是符号位：0位正数、1为负数</li><li>正数的原码、反码、补码一样</li><li>负数的反码 &#x3D; 原码符号位不变，其他位取反</li><li>负数的补码 &#x3D; 反码 + 1</li><li>java中的数都是有符号的</li><li>计算机运行时，都是以补码的方式运算</li></ol><h2 id="4-28-位运算符"><a href="#4-28-位运算符" class="headerlink" title="4.28 位运算符"></a>4.28 位运算符</h2><ol><li>&amp;</li><li>|</li><li>^</li><li>~</li><li><blockquote><blockquote><p>：符号位不变，用符号位补溢出的高位</p></blockquote></blockquote></li><li>&lt;&lt;：符号位不变，低位补0</li><li><blockquote><blockquote><blockquote><p>：逻辑右移，无符号右移，低位溢出，高位补0</p></blockquote></blockquote></blockquote></li></ol><h1 id="5-程序控制结构"><a href="#5-程序控制结构" class="headerlink" title="5.程序控制结构"></a>5.程序控制结构</h1><h2 id="5-9-do-while循环"><a href="#5-9-do-while循环" class="headerlink" title="5.9 do..while循环"></a>5.9 do..while循环</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">do</span>&#123;<br>循环体;<br>&#125;<span class="hljs-keyword">while</span><span class="hljs-comment">(循环条件)</span>;<br></code></pre></td></tr></table></figure><ol><li>先执行一次，再判断，至少会执行一次</li><li>最后有一个分号</li></ol><h1 id="6-数组、排序和查找"><a href="#6-数组、排序和查找" class="headerlink" title="6.数组、排序和查找"></a>6.数组、排序和查找</h1><h2 id="6-2-数组的使用"><a href="#6-2-数组的使用" class="headerlink" title="6.2 数组的使用"></a>6.2 数组的使用</h2><h3 id="6-2-1-动态初始化"><a href="#6-2-1-动态初始化" class="headerlink" title="6.2.1 动态初始化"></a>6.2.1 动态初始化</h3><ol><li>声明数组<ol><li>int a[]; 或者 int[] a;</li></ol></li><li>创建数组<ol><li>a&#x3D;new int[10];</li></ol></li></ol><h3 id="6-2-2-静态初始化"><a href="#6-2-2-静态初始化" class="headerlink" title="6.2.2 静态初始化"></a>6.2.2 静态初始化</h3><ol><li>int[] a &#x3D; {1,2,3,4};</li></ol><h2 id="6-5-数组赋值机制"><a href="#6-5-数组赋值机制" class="headerlink" title="6.5 数组赋值机制"></a>6.5 数组赋值机制</h2><ol><li>数组在默认情况下是引用传递，赋值的是地址<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>[] arr1 = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">12</span>&#125;;<br><span class="hljs-built_in">int</span>[] arr2 = arr1;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-6-数组拷贝"><a href="#6-6-数组拷贝" class="headerlink" title="6.6 数组拷贝"></a>6.6 数组拷贝</h2><ol><li>开辟新的数据空间<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(int i<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;i&lt;n;i++)&#123;</span><br>arr2[i] <span class="hljs-operator">=</span> arr1[i]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-10-冒泡排序"><a href="#6-10-冒泡排序" class="headerlink" title="6.10 冒泡排序"></a>6.10 冒泡排序</h2><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><h2 id="6-16-二维数组使用细节"><a href="#6-16-二维数组使用细节" class="headerlink" title="6.16 二维数组使用细节"></a>6.16 二维数组使用细节</h2><ol><li>二维数组声明方式 <ol><li><code>int[][]y  int[]y[]  int y[][]</code></li></ol></li><li><code>int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;&#125;</code></li></ol><h1 id="7-面向对象编程"><a href="#7-面向对象编程" class="headerlink" title="7.面向对象编程"></a>7.面向对象编程</h1><h2 id="7-1-类与对象"><a href="#7-1-类与对象" class="headerlink" title="7.1 类与对象"></a>7.1 类与对象</h2><h3 id="7-1-8-类和对象的区别和联系"><a href="#7-1-8-类和对象的区别和联系" class="headerlink" title="7.1.8 类和对象的区别和联系"></a>7.1.8 类和对象的区别和联系</h3><ol><li>类是抽象的，是数据类型</li><li>对象是具体的，是实例</li><li>类是对象的模板</li></ol><h3 id="7-1-11-如何创建对象"><a href="#7-1-11-如何创建对象" class="headerlink" title="7.1.11 如何创建对象"></a>7.1.11 如何创建对象</h3><ol><li>先声明再创建<ol><li>Cat cat;</li><li>cat &#x3D; new Cat();</li></ol></li><li>直接创建<ol><li>Cat cat &#x3D; new Cat();</li></ol></li></ol><h3 id="7-1-13-类和对象的内存分配机制"><a href="#7-1-13-类和对象的内存分配机制" class="headerlink" title="7.1.13 类和对象的内存分配机制"></a>7.1.13 类和对象的内存分配机制</h3><ol><li>java内存的结构分析<ol><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象（Cat cat、数组等）</li><li>方法区：常量池、类加载信息</li><li>示意图</li></ol></li></ol><h2 id="7-2-成员方法"><a href="#7-2-成员方法" class="headerlink" title="7.2 成员方法"></a>7.2 成员方法</h2><h3 id="7-2-7-注意事项和使用细节"><a href="#7-2-7-注意事项和使用细节" class="headerlink" title="7.2.7 注意事项和使用细节"></a>7.2.7 注意事项和使用细节</h3><ol><li>一个方法最多有一个返回值，多个结果用数组返回</li><li>返回类型可以是任意类型</li><li>如果方法是void类型，可以没用return，或者只写return</li><li>方法名采用小驼峰命名</li><li>方法定义时的参数称为形参，调用时传入的参数称为实参</li><li>方法中不能再定义方法</li></ol><h2 id="7-5-方法重载-OverLoad"><a href="#7-5-方法重载-OverLoad" class="headerlink" title="7.5 方法重载 OverLoad"></a>7.5 方法重载 OverLoad</h2><h3 id="7-5-1-基本介绍"><a href="#7-5-1-基本介绍" class="headerlink" title="7.5.1 基本介绍"></a>7.5.1 基本介绍</h3><ol><li>java中允许同一个类中，多个同名方法存在，但是每个方法形参列表不一样</li></ol><h3 id="7-5-4-注意事项和使用细节"><a href="#7-5-4-注意事项和使用细节" class="headerlink" title="7.5.4 注意事项和使用细节"></a>7.5.4 注意事项和使用细节</h3><ol><li>方法名：必须相同</li><li>形参列表：必须不同</li><li>返回类型：不做要求</li></ol><h2 id="7-6-可变参数"><a href="#7-6-可变参数" class="headerlink" title="7.6 可变参数"></a>7.6 可变参数</h2><h3 id="7-6-1-基本概念"><a href="#7-6-1-基本概念" class="headerlink" title="7.6.1 基本概念"></a>7.6.1 基本概念</h3><ol><li>java允许将同一个类中多个同名同功能但是参数不同的方法，封装成一个方法。</li></ol><h3 id="7-6-4-注意事项和使用细节"><a href="#7-6-4-注意事项和使用细节" class="headerlink" title="7.6.4 注意事项和使用细节"></a>7.6.4 注意事项和使用细节</h3><ol><li>可变参数的实参可以是0个或者任意个</li><li>实际上是数组</li><li>可以用数组表示，也可以用int…，三个点表示</li><li>可变参数和普通类型的参数一起放在形参列表，必须保证可变参数在最后</li><li>一个形参列表中，只能出现一个可变参数</li></ol><h2 id="7-7-作用域"><a href="#7-7-作用域" class="headerlink" title="7.7 作用域"></a>7.7 作用域</h2><h3 id="7-7-1-基本使用"><a href="#7-7-1-基本使用" class="headerlink" title="7.7.1 基本使用"></a>7.7.1 基本使用</h3><ol><li>java中，主要变量是属性（成员变量、全局变量）和局部变量</li><li>局部变量一般指在成员方法中定义的变量</li><li>全局变量作用域为整个类体</li><li>局部变量作用域在定义它的代码块中</li><li>全局变量可以不赋值，直接使用，有默认值；局部变量必须赋值后才能使用</li><li>属性和局部变量可以重名，访问时就近原则</li><li>在同一个作用域中，变量不能重名</li><li>属性生命周期较长，伴随对象的创建而创建，销毁而销毁；局部变量生命周期较短，伴随代码块的执行而创建，随代码块的结束而销毁。</li><li>作用域范围不同<ol><li>全局变量：可以被本类或其他类使用</li><li>局部变量：只能在本类的对应方法中使用</li></ol></li><li>修饰符不同<ol><li>全局变量：可以加修饰符</li><li>局部变量：不能加修饰符</li></ol></li></ol><h2 id="7-8-构造方法、构造器"><a href="#7-8-构造方法、构造器" class="headerlink" title="7.8 构造方法、构造器"></a>7.8 构造方法、构造器</h2><h3 id="7-8-1-需求"><a href="#7-8-1-需求" class="headerlink" title="7.8.1 需求"></a>7.8.1 需求</h3><ol><li>之前创建对象的时候，是先把一个对象创建好后，再给对应的属性赋值</li><li>如果要求在创建对象的时候，直接指定属性值，可以使用构造器</li></ol><h3 id="7-8-2-基本语法"><a href="#7-8-2-基本语法" class="headerlink" title="7.8.2 基本语法"></a>7.8.2 基本语法</h3><ol><li>构造器的修饰符可以任意</li><li>构造器没有返回值</li><li>方法名和类名必须一样</li><li>参数列表和成员方法一样的规制</li><li>构造器的调用，由系统完成</li></ol><h3 id="7-8-3"><a href="#7-8-3" class="headerlink" title="7.8.3"></a>7.8.3</h3><ol><li>构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。</li><li><ol><li>方法名和类名相同</li></ol></li><li><ol start="2"><li>没有返回值</li></ol></li><li><ol start="3"><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。</li></ol></li></ol><h3 id="7-8-3-快速入门"><a href="#7-8-3-快速入门" class="headerlink" title="7.8.3 快速入门"></a>7.8.3 快速入门</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Person p = <span class="hljs-built_in">new</span> Person(&quot;smith&quot;,<span class="hljs-number">80</span>);<br><br><span class="hljs-keyword">class</span> Person&#123;<br>String <span class="hljs-type">name</span>;<br><span class="hljs-type">int</span> age;<br><span class="hljs-built_in">public</span> Person(String <span class="hljs-type">name</span>, <span class="hljs-type">int</span> age)&#123;<br><span class="hljs-type">name</span> = <span class="hljs-type">name</span>;<br>age = age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-8-5-注意事项和细节"><a href="#7-8-5-注意事项和细节" class="headerlink" title="7.8.5 注意事项和细节"></a>7.8.5 注意事项和细节</h3><ol><li>一个类可以定义多个不同的构造器，即构造器重载</li><li>构造器名和类名相同</li><li>构造器没有返回值</li><li>构造器是完成对象的初始化，不是创建对象</li><li>创建对象时，系统自动调用该类的构造方法</li><li>如果程序没有定义构造器，系统会自动给类生成一个默认的无参构造器</li><li>一旦定义了构造器，默认的构造器就被覆盖了，除非显式地定义一下</li></ol><h2 id="7-10-this关键字"><a href="#7-10-this关键字" class="headerlink" title="7.10 this关键字"></a>7.10 this关键字</h2><ol><li>jvm给每个对象分配this，代表当前对象</li><li>this关键字可以访问本类的属性、方法、构造器</li><li>this用于区分当前类的属性和局部变量</li><li>访问成员方法的语法：this.方法名（参数列表）</li><li>访问构造器语法：<ol><li>this(参数列表)</li><li>只能在构造器中使用，即只能在构造器中访问另外一个构造器，必须放在第一条语句</li></ol></li><li>this不能在类定义的外部使用，只能在类定义的方法中使用</li></ol><h1 id="8-面向对象编程（中级部分）"><a href="#8-面向对象编程（中级部分）" class="headerlink" title="8.面向对象编程（中级部分）"></a>8.面向对象编程（中级部分）</h1><h2 id="8-3-IDEA"><a href="#8-3-IDEA" class="headerlink" title="8.3 IDEA"></a>8.3 IDEA</h2><p><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">GitHub - judasn&#x2F;IntelliJ-IDEA-Tutorial: IntelliJ IDEA 简体中文专题教程</a></p><h3 id="8-3-5-常用快捷键"><a href="#8-3-5-常用快捷键" class="headerlink" title="8.3.5 常用快捷键"></a>8.3.5 常用快捷键</h3><p><a href="https://www.jianshu.com/p/5de7cca0fefc">IntelliJ Idea 常用快捷键列表 - 简书</a></p><h3 id="8-3-6-模板-自定义模板"><a href="#8-3-6-模板-自定义模板" class="headerlink" title="8.3.6 模板&#x2F;自定义模板"></a>8.3.6 模板&#x2F;自定义模板</h3><p>file - settings - editor - live templates</p><h2 id="8-4-包"><a href="#8-4-包" class="headerlink" title="8.4 包"></a>8.4 包</h2><h3 id="8-4-3-包基本语法"><a href="#8-4-3-包基本语法" class="headerlink" title="8.4.3 包基本语法"></a>8.4.3 包基本语法</h3><p><code>package com.edu</code> 声明当前类所在的包，放在文件最上面</p><ol><li>package 关键字，表示打包</li><li>com.edu 表示包名</li><li>com.公司名.项目名.业务模块名</li></ol><h2 id="8-5-访问修饰符"><a href="#8-5-访问修饰符" class="headerlink" title="8.5 访问修饰符"></a>8.5 访问修饰符</h2><h3 id="8-5-1-基本介绍"><a href="#8-5-1-基本介绍" class="headerlink" title="8.5.1 基本介绍"></a>8.5.1 基本介绍</h3><ol><li>java提供四种访问修饰符，用来控制类、方法和属性的访问权限<ol><li>public：对外公开</li><li>protected：对子类和同一个包中的类公开</li><li>默认：同一个包中的类公开</li><li>private：只有类本身可以访问</li></ol></li><li>只有default和public才能修饰类</li></ol><h2 id="8-6-面向对象编程的三大特征"><a href="#8-6-面向对象编程的三大特征" class="headerlink" title="8.6 面向对象编程的三大特征"></a>8.6 面向对象编程的三大特征</h2><h3 id="8-6-1-基本介绍"><a href="#8-6-1-基本介绍" class="headerlink" title="8.6.1 基本介绍"></a>8.6.1 基本介绍</h3><ol><li>封装、继承和多态</li></ol><h3 id="8-6-2-封装介绍"><a href="#8-6-2-封装介绍" class="headerlink" title="8.6.2 封装介绍"></a>8.6.2 封装介绍</h3><ol><li>封装是把抽象出的数据(属性)和对数据的操作方法封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的方法才能对数据进行操作</li><li>好处<ol><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ol></li><li>封装的实现步骤<ol><li>将属性私有化</li><li>提供public的set方法</li><li>提供public的get方法</li></ol></li></ol><h2 id="8-8-继承"><a href="#8-8-继承" class="headerlink" title="8.8 继承"></a>8.8 继承</h2><ol><li>继承可以解决代码复用</li><li>当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法</li><li>子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类</li></ol><h3 id="8-8-1-继承的基本语法"><a href="#8-8-1-继承的基本语法" class="headerlink" title="8.8.1 继承的基本语法"></a>8.8.1 继承的基本语法</h3><ol><li>class 子类 extends 父类</li><li>子类自动拥有父类定义的属性和方法</li><li>父类叫超类、基类</li><li>子类叫派生类</li></ol><h3 id="8-8-6-继承的细节"><a href="#8-8-6-继承的细节" class="headerlink" title="8.8.6 继承的细节"></a>8.8.6 继承的细节</h3><ol><li>子类继承了所有的属性和方法，非私有的方法和属性可以直接方法，私有属性和方法不能在子类直接访问，只能通过父类提供的公共方法访问</li><li>子类必须调用父类的构造器，完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译失败</li><li>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</li><li>super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)</li><li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java 所有类都是 Object 类的子类, Object 是所有类的基类.</li><li>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制</li><li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系<br><a href="https://zhuanlan.zhihu.com/p/663091776">设计与对象：理解“有一个（Has-a）”与“是一个（Is-a）”关系 Professional C++ (English Edition) 5th Edition - 知乎</a></li></ol><h2 id="8-9-super关键字"><a href="#8-9-super关键字" class="headerlink" title="8.9 super关键字"></a>8.9 super关键字</h2><ol><li>super代表父类的引用，用于访问父类的属性、方法、构造器</li><li>当子类有和父类重名的属性或者方法时，为了访问父类的成员，必须通过super</li><li>super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，可以用super访问爷爷类的成员；如果多个基类都有相同名的成员，那就super就近原则</li></ol><h2 id="8-10-方法重写-覆盖"><a href="#8-10-方法重写-覆盖" class="headerlink" title="8.10 方法重写&#x2F;覆盖"></a>8.10 方法重写&#x2F;覆盖</h2><ol><li>方法覆盖或重写，是子类的一个方法和父类的某个方法在名称、返回类型、参数一样，那么就是子类覆盖了父类的方法</li><li>子类方法的返回类型需要和父类返回类型一样，或者是父类返回类型的子类也可以，比如父类是Object，子类是String</li><li>子类方法不能缩小父类方法的访问权限</li></ol><h3 id="8-10-4-重写和重载"><a href="#8-10-4-重写和重载" class="headerlink" title="8.10.4 重写和重载"></a>8.10.4 重写和重载</h3><ol><li>重载 overload ，作用在本类，方法名必须一致，形参列表不同，返回类型和修饰符无要求</li><li>重写 override，作用在父子类，方法名必须一致，形参列表一样，返回类型一样或子类，修饰符不能缩小</li></ol><h2 id="8-11-多态"><a href="#8-11-多态" class="headerlink" title="8.11 多态"></a>8.11 多态</h2><ol><li>多态是建立在封装和继承的基础上</li></ol><h3 id="8-11-3"><a href="#8-11-3" class="headerlink" title="8.11.3"></a>8.11.3</h3><ol><li>方法的多态<ol><li>重写和重载就是多态</li></ol></li><li>对象的多态<ol><li>一个对象的编译类型和运行类型可以不一致</li><li>&#x3D;的左边是编译类型，右边是运行类型</li><li>编译类型在定义对象时就确定了，不能改变</li><li>运行类型可以变化<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Animal animal <span class="hljs-operator">=</span> new Dog()<span class="hljs-comment">;</span><br><span class="hljs-attribute">animal</span> <span class="hljs-operator">=</span> new Cat()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="8-11-5-多态注意事项和细节"><a href="#8-11-5-多态注意事项和细节" class="headerlink" title="8.11.5 多态注意事项和细节"></a>8.11.5 多态注意事项和细节</h3><ol><li>多态的前提：两个对象或者类存在继承关系</li><li>多态的向上转型<ol><li>语法：父类类型  引用名 &#x3D; new 子类类型();</li><li>本质：父类的引用指向了子类的对象</li><li>特点：<ol><li>可以调用父类中所有的成员</li><li>不能调用子类中特有的成员</li><li>最终运行效果看子类的具体实现</li></ol></li></ol></li><li>多态的向下转型<ol><li>语法：子类类型  引用名 &#x3D; (子类类型) 父类引用;</li><li>只能强转父类的引用，不能强转父类的对象</li><li>向下转型后，可以调用子类类型中所有的成员</li></ol></li><li>属性没有重写一说</li><li>instanceOf用来判断对象的运行类型是否是xx类型或者xx类型的子类型</li></ol><h2 id="8-11-7-java的动态绑定机制"><a href="#8-11-7-java的动态绑定机制" class="headerlink" title="8.11.7 java的动态绑定机制"></a>8.11.7 java的动态绑定机制</h2><ol><li>当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</li><li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li></ol><h3 id="8-11-8-多态的应用"><a href="#8-11-8-多态的应用" class="headerlink" title="8.11.8 多态的应用"></a>8.11.8 多态的应用</h3><ol><li>多态数组<ol><li>数组的定义类型为父类类型，里面保存的实际元素为子类类型</li><li>执行子类特有的方法的话，先用instanceof判断子类类型，然后强转子类类型，就可以执行子类特有方法</li></ol></li><li>多态参数<ol><li>方法定义的形参类型为父类类型，实参允许位子类类型</li></ol></li></ol><h2 id="8-12-Object详解"><a href="#8-12-Object详解" class="headerlink" title="8.12 Object详解"></a>8.12 Object详解</h2><h3 id="8-12-1-equals方法"><a href="#8-12-1-equals方法" class="headerlink" title="8.12.1 equals方法"></a>8.12.1 equals方法</h3><ol><li>&#x3D;&#x3D; <ol><li>如果判断基本类型，判断的是值是否相等</li><li>如果判断引用类型，判断的是地址是否相等，判断是不是同一个对象</li></ol></li><li>equals<ol><li>只能判断引用类型，用于判断内容是否相等</li></ol></li></ol><h3 id="8-12-4-hashCode方法"><a href="#8-12-4-hashCode方法" class="headerlink" title="8.12.4 hashCode方法"></a>8.12.4 hashCode方法</h3><ol><li>返回对象的哈希码值</li><li>两个引用，如果指向的是同一个对象，哈希值肯定是相同的</li><li>哈希值主要根据地址号来的，但是不完全等价于地址</li></ol><h3 id="8-12-5-toString方法"><a href="#8-12-5-toString方法" class="headerlink" title="8.12.5 toString方法"></a>8.12.5 toString方法</h3><ol><li>默认返回：全类名+@+哈希值的十六进制</li><li>子类往往会重写toString方法，用于返回对象的属性信息</li></ol><h3 id="8-12-6-finalize-方法"><a href="#8-12-6-finalize-方法" class="headerlink" title="8.12.6 finalize 方法"></a>8.12.6 finalize 方法</h3><ol><li>当对象被回收时，系统自动调用该对象的finalize方法</li><li>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法。</li><li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li></ol><h3 id="8-13-断点调试"><a href="#8-13-断点调试" class="headerlink" title="8.13 断点调试"></a>8.13 断点调试</h3><ol><li>断点调试过程中，是运行状态，以对象的运行类型来执行的</li><li>快捷键<ol><li>F7 跳入方法内</li><li>F8 逐行执行代码</li><li>shift + F8 跳出</li><li>F9 执行到下一个断点</li></ol></li></ol><h1 id="10-面向对象编程（高级部分）"><a href="#10-面向对象编程（高级部分）" class="headerlink" title="10. 面向对象编程（高级部分）"></a>10. 面向对象编程（高级部分）</h1><h2 id="10-1-类变量和类方法"><a href="#10-1-类变量和类方法" class="headerlink" title="10.1 类变量和类方法"></a>10.1 类变量和类方法</h2><h3 id="10-1-4-类变量内存分布"><a href="#10-1-4-类变量内存分布" class="headerlink" title="10.1.4 类变量内存分布"></a>10.1.4 类变量内存分布</h3><ol><li>static 变量是对象共享</li><li>不管static变量在哪，同一个类所有对象共享</li><li>static 类变量，在类加载的时候就生成了</li></ol><h3 id="10-1-5-什么是类变量"><a href="#10-1-5-什么是类变量" class="headerlink" title="10.1.5 什么是类变量"></a>10.1.5 什么是类变量</h3><ol><li>类变量也叫静态变量&#x2F;静态属性</li><li>该类所有对象共享的变量</li><li>任何一个该类的对象访问它的时候，取到的值是相同的值</li></ol><h3 id="10-1-6-定义类变量"><a href="#10-1-6-定义类变量" class="headerlink" title="10.1.6 定义类变量"></a>10.1.6 定义类变量</h3><ol><li>访问修饰符 static 数据类型 变量名</li><li>static 访问修饰符 数据类型 变量名</li></ol><h3 id="10-1-7-访问类变量"><a href="#10-1-7-访问类变量" class="headerlink" title="10.1.7 访问类变量"></a>10.1.7 访问类变量</h3><ol><li>类名.类变量名（推荐）</li><li>对象名.类变量名</li><li>类变量的访问权限受访问修饰符限制</li></ol><h3 id="10-1-8-类变量使用和注意事项"><a href="#10-1-8-类变量使用和注意事项" class="headerlink" title="10.1.8 类变量使用和注意事项"></a>10.1.8 类变量使用和注意事项</h3><ol><li>当我们需要让某个类的所有对象共享一个变量时，就可以考虑使用类变量</li><li>加上static称为类变量或静态变量，否则称为实例变量、普通变量、非静态变量</li><li>实例变量不能通过 类名.类变量名 访问</li><li>类变量是在类加载时就初始化了，即使没有创建对象，只要类加噪了就可以使用类变量</li><li>类变量生命周期是随类的加载开始，类的消亡而消亡</li></ol><h3 id="10-1-9-类方法基本介绍"><a href="#10-1-9-类方法基本介绍" class="headerlink" title="10.1.9 类方法基本介绍"></a>10.1.9 类方法基本介绍</h3><ol><li>类方法也叫静态方法</li><li>形式：<ol><li>访问修饰符 static 数据返回类型 方法名(){} 推荐</li><li>static 访问修饰符 数据返回类型 方法名(){}</li></ol></li><li>类方法的调用<ol><li>类名.类方法名  </li><li>对象名.类方法名</li></ol></li><li>类方法的经典使用场景<ol><li>当方法中不涉及到任何和对象相关的成员，就可以将方法设计成静态方法<ol><li>比如工具类的方法 utils</li><li>把一些通用的方法设计成静态方法，这样不需要创建对象就可以使用</li></ol></li></ol></li><li>注意事项和细节<ol><li>类方法和普通方法都随着类的加载而加载，将结构信息存储在方法区</li><li>类方法中没有this的参数，普通方法中隐含着this的参数</li><li>类方法可以通过类名调用，可以通过对象名调用</li><li>普通方法和对象有关，需要通过对象名调用</li><li>类方法中不允许使用和对象有关的关键字，比如this和super</li><li>类方法只能访问静态变量或静态方法</li><li>普通方法既可以访问非静态成员，也可以访问静态成员</li></ol></li></ol><h2 id="10-2-理解main方法语法"><a href="#10-2-理解main方法语法" class="headerlink" title="10.2 理解main方法语法"></a>10.2 理解main方法语法</h2><ol><li>public static void main(String[] args)<ol><li>main 方法时虚拟机调用</li><li>java虚拟机需要调用类的main方法，所以访问权限必须是public</li><li>java虚拟机在执行main方法时不必创建对象，所以是static</li></ol></li><li>main() 方法中，可以直接调用main方法所在类的静态方法或静态属性<ol><li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol></li></ol><h2 id="10-3-代码块"><a href="#10-3-代码块" class="headerlink" title="10.3 代码块"></a>10.3 代码块</h2><ol><li>代码块又称为初始化块，类似于方法，但是没有方法名、返回、参数，只有方法体</li><li>加载类时，创建对象时隐式调用</li><li>语法 ： <ol><li>static{}; 静态代码块，随着类的加载而执行，只会执行一次</li><li>{}; 非静态代码块，创建一个对象就执行</li></ol></li><li>相当于另外一种形式的构造器，可以做初始化操作</li><li>场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性</li><li>类什么时候被加载<ol><li>创建对象实例时  new</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时</li></ol></li><li>创建一个对象时，在一个类中调用顺序：</li></ol><h2 id="10-4-单例模式"><a href="#10-4-单例模式" class="headerlink" title="10.4 单例模式"></a>10.4 单例模式</h2><ol><li>单例：单个实例</li><li>采取一定的方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</li><li>两种方式<ol><li>饿汉式<ol><li>构造器私有化 -&gt; 防止直接new</li><li>类的内部创建private static对象</li><li>向外暴露一个静态公共方法，public getInstance</li><li>饿汉式的缺点是创建了对象但是没有使用，导致资源的浪费</li></ol></li><li>懒汉式<ol><li>构造器私有化</li><li>定义静态属性对象 private static Cat cat;</li><li>提供public static方法，可以返回一个Cat对象</li><li>只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象</li></ol></li><li>区别<ol><li>主要区别是创建对象的时机不同，饿汉式是类加载时就创建了对象实例，懒汉是在使用时才创建</li><li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li><li>饿汉式存在资源浪费的可能</li></ol></li></ol></li></ol><h2 id="10-5-final关键字"><a href="#10-5-final关键字" class="headerlink" title="10.5 final关键字"></a>10.5 final关键字</h2><ol><li>final 可以修饰类、属性、方法、局部变量</li><li>需求<ol><li>不希望类被继承时，可以用final修饰</li><li>不希望父类的某个方法被子类重写</li><li>不希望类的某个属性的值被修改</li><li>不希望某个局部变量值被修改</li></ol></li><li>注意<ol><li>final修饰的属性又叫常量，一般用 XX_XX_XX 命令</li><li>final修饰的属性在定义时，必须赋初值，并且以后不能再修改<ol><li>赋值的位置可以在定义时、构造器中、代码块中</li></ol></li><li>如果final修饰的属性是静态的，初始化的位置只能是定义时、静态代码块中</li><li>final类不能被继承，但是可以实例化对象</li><li>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</li><li>一般来说，如果一个类已经是final类了，就没必要将该方法修饰成final方法。都已经不能被继承了，还怎么可以重写方法</li><li>final不能修饰构造方法</li><li><strong>final和static往往搭配使用，不会导致类加载</strong></li><li>包装类都是final类，Integer  Double  Float  Boolean  String</li></ol></li></ol><h2 id="10-6-抽象类"><a href="#10-6-抽象类" class="headerlink" title="10.6 抽象类"></a>10.6 抽象类</h2><ol><li>当父类的某些方法需要声明，但是不确定如何实现时，可以将其声明为抽象方法，这个类就是抽象类</li><li>抽象方法就是没有实现的方法</li><li>用abstract修饰的类就是抽象类</li><li>抽象类不一定要包含抽象方法，有抽象方法类一定要声明abstract</li><li>abstract只能修饰类和方法，不能修饰其他</li><li>抽象类可以有任意成员，本质还是类</li><li>抽象方法不能有主体，也就是不能有实现，也就是不能有大括号，有了大括号就意味着实现</li><li>如果一个类继承了抽象类，必须实现抽象类中所有的抽象方法，除非自己也声明abstract</li><li>抽象方法不能被private final static这三个关键字修饰</li></ol><h2 id="10-7-抽象类最佳实践-模板设计模式"><a href="#10-7-抽象类最佳实践-模板设计模式" class="headerlink" title="10.7 抽象类最佳实践 - 模板设计模式"></a>10.7 抽象类最佳实践 - 模板设计模式</h2><ol><li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行拓展、改造，但是子类总体上会保留抽象类的行为方式。</li><li>模板设计模式能解决的问题<ol><li>当功能内部一部分实现是确定的，一部分实现是不确定的，就可以把不确定的部分暴露出去，让子类去实现</li><li>编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式</li></ol></li></ol><h2 id="10-8-接口"><a href="#10-8-接口" class="headerlink" title="10.8 接口"></a>10.8 接口</h2><ol><li>接口是将一些没有实现的方法封装到一起，到某个类要使用的时候，根据具体情况把这些方法写出来<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名&#123;<br>属性<br>抽象方法<br>&#125;<br>class 类名 implements 接口&#123;<br>自己属性<br>自己方法<br>&#125;<br></code></pre></td></tr></table></figure></li><li>接口是更加抽象的抽象类，接口里的所有方法都没有方法体 jdk7</li><li>接口体现了程序设计的多态和高内聚低耦合的设计思想</li><li>jdk8后，接口类可以有静态方法、普通方法，也就是可以有方法的具体实现</li><li>注意<ol><li>接口不能被实例化</li><li>接口中所有方法都是public方法，接口中的抽象方法可以不用abstract修饰</li><li>抽象类实现接口可以不用实现接口的方法</li><li>一个普通类实现接口必须将接口的所有方法都实现</li><li>一个类可以同时实现多个接口 <code>class A implements B,C&#123;&#125;</code></li><li>接口中的属性只能是public static final修饰</li><li>接口中属性的访问：接口名.属性名</li><li>接口不能继承其他的类，但是可以继承多个接口 <code>interface A extends B,C&#123;&#125;</code></li><li>接口的修饰符和类一样，只能是默认或者public</li></ol></li><li>实现接口 vs 继承类<ol><li>继承的价值：解决代码的复用性和可维护性</li><li>接口的价值：设计好规范(方法)，让其他类去实现</li><li>接口比继承更灵活，继承是 is-a关系 ，接口是like-a关系</li><li>接口在一定程度上实现代码解耦，即接口规范性+动态绑定机制</li></ol></li><li>接口的多态性<ol><li>多态参数：用到接口的参数，可以用实现了接口的子类代替</li><li>多态数组：</li><li>接口存在多态传递</li></ol></li><li>可以使用接口定义对象，比如<code>Interface A = new A实现类();</code></li></ol><h2 id="10-9-内部类"><a href="#10-9-内部类" class="headerlink" title="10.9 内部类"></a>10.9 内部类</h2><ol><li>定义类在局部位置(方法中&#x2F;代码块)<ol><li>局部内部类</li><li>匿名内部类</li></ol></li><li>定义类在成员位置<ol><li>成员内部类</li><li>静态内部类</li></ol></li><li>一个类的内部又完整地嵌套了另一个类结构，被嵌套的类称为内部类，嵌套其他类的类称为外部类，是我们类的第五大成员（属性、方法、构造器、代码块、内部类）</li><li>内部类最大的特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系</li><li>语法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>内部类的分类<ol><li>定义在外部类局部位置，比如方法内<ol><li>局部内部类，有类名</li><li>匿名内部类，没有类名</li></ol></li><li>定义在外部类的成员位置上<ol><li>成员内部类，没用static修饰</li><li>静态内部类，使用static修饰</li></ol></li></ol></li></ol><h3 id="10-9-5-局部内部类的使用"><a href="#10-9-5-局部内部类的使用" class="headerlink" title="10.9.5 局部内部类的使用"></a>10.9.5 局部内部类的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> n+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</li><li>可以直接访问外部类所有成员，包含私有的属性和方法</li><li>不能添加添加访问修饰符，但是可以使用final修饰</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>局部内部类可以直接访问外部类的成员</li><li>外部类要想访问局部内部类的成员，方式是创建对象再访问，必须在作用域中</li><li>外部其他类不能访问局部内部类</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则；如果要访问外部类的成员，可以使用 外部类名.this.成员 访问</li></ol><h3 id="10-9-6-匿名内部类的使用（重要）"><a href="#10-9-6-匿名内部类的使用（重要）" class="headerlink" title="10.9.6 匿名内部类的使用（重要）"></a>10.9.6 匿名内部类的使用（重要）</h3><ol><li>本质是类</li><li>内部类</li><li>该类没有名字，其实系统低层会分配一个名字，我们也可以打印出来，但是不能在代码流程中使用</li><li>同时也是一个对象</li><li>匿名内部类定义在外部类的局部位置，比如方法中，没有类名</li><li>语法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类或接口(参数列表)&#123;<br>类体<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java\接口">//5. tiger的编译类型 ? IA<br>//6. tiger的运行类型 ? 就是匿名内部类  Outer04$1<br>IA tiger = new IA() &#123;  <br>    @Override  <br>    public void cry() &#123;  <br>        System.out.println(&quot;老虎叫唤...&quot;);  <br>    &#125;  <br>&#125;;<br><br>class Outer04$1 implements IA &#123;  <br>    @Override    public void cry() &#123;        System.out.println(&quot;老虎叫唤...&quot;);  <br>    &#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">father</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>(<span class="hljs-string">&quot;jack&quot;</span>)&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;匿名内部类重写了test方法&quot;</span>);  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure></li><li>匿名内部类使用一次就不能再使用了，但是new 的对象是可以重复使用，比如tiger</li><li>匿名内部类的语法比较奇特<ol><li>匿名内部类既是一个类的定义，同时本身也是一个对象，因此从语法上，它既有定义类的特征，也有创建对象的特征<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">88</span>;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//可以直接访问外部类的所有成员，包含私有的  </span><br>        <span class="hljs-comment">//如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，  </span><br>        <span class="hljs-comment">//默认遵循就近原则，如果想访问外部类的成员，则可以使用 （外部类名.this.成员）去访问  </span><br>        System.out.println(<span class="hljs-string">&quot;匿名内部类重写了 hi方法 n1=&quot;</span> + n1 +  <br>                <span class="hljs-string">&quot; 外部内的n1=&quot;</span> + Outer05.<span class="hljs-built_in">this</span>.n1 );  <br>    &#125;  <br>&#125;;  <br>p.hi();<span class="hljs-comment">//动态绑定, 运行类型是 Outer05$1</span><br></code></pre></td></tr></table></figure></li></ol></li><li>可以直接访问外部类的所有成员，包含私有的</li><li>不能添加访问修饰符，它的地位就是一个局部变量</li><li>作用域：仅仅在定义它的方法或代码块</li><li>匿名内部类访问外部类成员：直接访问</li><li>外部其他类不能访问匿名内部类</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则；如果要访问外部类的成员，可以使用 外部类名.this.成员 访问</li></ol><h3 id="10-9-7-匿名内部类的最佳实践"><a href="#10-9-7-匿名内部类的最佳实践" class="headerlink" title="10.9.7 匿名内部类的最佳实践"></a>10.9.7 匿名内部类的最佳实践</h3><ol><li>当做实参直接传递，简洁高效<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IL</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;  <br>&#125;<br>f1(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IL</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;这是一副名画~~...&quot;</span>);  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h3 id="10-9-9-成员内部类"><a href="#10-9-9-成员内部类" class="headerlink" title="10.9.9 成员内部类"></a>10.9.9 成员内部类</h3><ol><li>成员内部类定义在外部类的成员位置，没有static修饰</li><li>可以直接访问外部类的所有成员，包含私有的</li><li>可以添加任意访问修饰符，因为地位就是一个成员</li><li>作用域：整个类体</li><li>成员内部类访问外部类成员，直接访问</li><li>外部类访问成员内部类，创建对象再访问，私有成员也可以直接访问，毕竟都是在同一个外部类中</li><li>外部其他类访问成员内部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一种方式</span><br><span class="hljs-comment">// outer08.new Inner08(); 相当于把 new Inner08()当做是outer08成员</span><br>Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> outer08.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();  <br>inner08.say();<br><span class="hljs-comment">// 第二方式 在外部类中，编写一个方法，可以返回 Inner08对象  </span><br>Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance</span> <span class="hljs-operator">=</span> outer08.getInner08Instance();  <br>inner08Instance.say();<br><span class="hljs-keyword">public</span> Inner08 <span class="hljs-title function_">getInner08Instance</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则；如果要访问外部类的成员，可以使用 外部类名.this.成员 访问</li></ol><h3 id="10-9-10-静态内部类的使用"><a href="#10-9-10-静态内部类的使用" class="headerlink" title="10.9.10 静态内部类的使用"></a>10.9.10 静态内部类的使用</h3><ol><li>静态内部类定义在外部类的成员位置，有static修饰</li><li>可以直接访问外部类的所有静态成员，包含私有的，但是不能直接访问非静态成员</li><li>可以使用任意访问修饰符</li><li>作用域：整个类体</li><li>静态内部类可以直接访问外部类所有静态成员</li><li>成员内部类访问外部类成员，直接访问</li><li>其他同成员内部类</li></ol><h1 id="11-枚举和注解"><a href="#11-枚举和注解" class="headerlink" title="11.枚举和注解"></a>11.枚举和注解</h1><ol><li>分析问题<ol><li>创建的对象有以下特点<ol><li>季节的值是有限的几个值</li><li>只读，不需要修改</li></ol></li></ol></li><li>解决方案<ol><li>枚举 enum</li><li>枚举是一组常量的集合</li><li>枚举是一种特殊的类，里面只包含一组有限的特定的对象</li></ol></li><li>实现方式<ol><li>自定义实现枚举</li><li>使用enum关键字实现枚举</li></ol></li><li>自定义实现枚举<ol><li>构造器私有化，目的防止直接new</li><li>不需要提供setXxx方法</li><li>对枚举对象&#x2F;属性使用final + static 修饰，实现低层优化</li><li>枚举对象名称通常使用全部大写</li><li>枚举对象根据需要，也可以有多个属性</li><li>本类内部创建一组对象，比如春夏秋冬四个对象</li><li>对外暴露对象，在对象前加 public final static 修饰符</li></ol></li></ol><h2 id="11-7-enum关键字"><a href="#11-7-enum关键字" class="headerlink" title="11.7 enum关键字"></a>11.7 enum关键字</h2><ol><li>使用关键字enum替代class，<code>class Season</code> -&gt; <code>enum Season</code></li><li>自定义格式<code>public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;)</code>，关键字格式<code>SPRING(&quot;春天&quot;, &quot;温暖&quot;) 解读 常量名(实参列表)</code></li><li>如果有多个常量（对象），使用逗号间隔即可</li><li>如果使用 enum 来实现枚举，要求将定义常量对象，写在前面</li></ol><h3 id="11-7-2-enum关键字实现枚举注意事项"><a href="#11-7-2-enum关键字实现枚举注意事项" class="headerlink" title="11.7.2 enum关键字实现枚举注意事项"></a>11.7.2 enum关键字实现枚举注意事项</h3><ol><li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类</li><li>传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)</li><li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li><li>当有多个枚举对象时，使用,间隔，最后有一个分号结尾</li><li>枚举对象必须放在枚举类的行首</li></ol><h2 id="11-9-enum常用方法说明"><a href="#11-9-enum常用方法说明" class="headerlink" title="11.9 enum常用方法说明"></a>11.9 enum常用方法说明</h2><ol><li>关键字enum隐式继承Enum类，使用可以使用Enum类相关方法</li><li>name：返回当前对象名（常量名）</li><li>ordinal：返回当前对象的位置号，默认从 0 开始</li><li>values：返回当前枚举类中所有的常量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Season2[] values = Season2.values();  <br>System.out.println(<span class="hljs-string">&quot;===遍历取出枚举对象(增强for)====&quot;</span>);  <br><span class="hljs-keyword">for</span> (Season2 season: values) &#123;<span class="hljs-comment">//增强for循环  </span><br>    System.out.println(season);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li>valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</li><li>compareTo：比较两个枚举常量，比较的就是编号</li><li>toString:Enum 类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息</li></ol><h2 id="11-11-enum实现接口"><a href="#11-11-enum实现接口" class="headerlink" title="11.11 enum实现接口"></a>11.11 enum实现接口</h2><ol><li>使用enum关键字后，就不能再继承其他类了，因为enum隐式继承Enum，java是单继承机制</li><li>枚举类和普通类一样可以实现接口<code>enum 类名 implements 接口 1，接口 2&#123;&#125;</code></li></ol><h2 id="11-12-注解"><a href="#11-12-注解" class="headerlink" title="11.12 注解"></a>11.12 注解</h2><ol><li>注解 annotation 也被称为元数据，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息</li><li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</li><li>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。</li></ol><h2 id="11-13-基本的Annotation介绍"><a href="#11-13-基本的Annotation介绍" class="headerlink" title="11.13 基本的Annotation介绍"></a>11.13 基本的Annotation介绍</h2><ol><li>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用</li><li>三个基本的注解<ol><li>@Override：限定某个方法，是重写父类方法<ol><li>如果你写了@Override注解，编译器就会去检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误</li><li>只能修饰方法，不能修饰其他类、包、属性等</li></ol></li><li>@Deprecated：用于表示某个程序元素（类、方法等）已过时<ol><li>可以修饰方法、类、字段、包、参数等</li><li>不推荐使用，但是可以继续使用</li><li>作用可以做到新旧版本的兼容和过渡</li></ol></li><li>@SuppressWarning：抑制编译器警告<ol><li>在{“”} 中，可以写入你希望抑制(不显示)警告信息<ol><li>all，抑制所有警告</li><li>cast，抑制与强制转型作业相关的警告</li><li>boxing，抑制与封装&#x2F;拆装作业相关的警告</li><li>null，抑制与空值分析相关的警告</li><li>…</li><li>unchecked 忽略没有检查的警告</li><li>rawtypes 忽略没有指定泛型的警告</li><li>unused 忽略没有使用某个变量的警告</li></ol></li><li>作用范围和放置的位置相关</li></ol></li></ol></li><li>@interface不是接口类，而是注解类</li><li>@Target 是修饰注解的注解，称为元注解</li></ol><h2 id="11-15-JDK的元注解（了解）"><a href="#11-15-JDK的元注解（了解）" class="headerlink" title="11.15 JDK的元注解（了解）"></a>11.15 JDK的元注解（了解）</h2><ol><li>元注解本身作用不大，是用来修饰注解的注解</li><li>元注解种类<ol><li>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME<ol><li>RetentionPolicy.SOURCE：编译器使用后，直接丢弃这种策略的注解</li><li>.CLASS：编译器将注解记录在class文件中，当运行java程序时，jvm不会保留注解，默认值</li><li>.RUNTIME：编译器将注解记录在class文件中，运行java程序时，JVM会保留注解。程序可以通过反射获取该注解</li></ol></li><li>Target &#x2F;&#x2F; 指定注解可以在哪些地方使用，注入范围<ol><li>Target.METHOD</li><li>.PARAMTER</li><li>.TYPE</li><li>.PACKAGE</li><li>…</li></ol></li><li>Documented &#x2F;&#x2F;指定该注解是否会在 javadoc 体现</li><li>Inherited &#x2F;&#x2F;子类会继承父类注解</li></ol></li></ol><h1 id="12-异常-Exception"><a href="#12-异常-Exception" class="headerlink" title="12.异常-Exception"></a>12.异常-Exception</h1><h2 id="12-2-异常捕获"><a href="#12-2-异常捕获" class="headerlink" title="12.2 异常捕获"></a>12.2 异常捕获</h2><ol><li>try-catch 异常处理机制解决异常问题</li><li>代码块 - 选中 - ctrl+alt+t - try-catch</li></ol><h2 id="12-3-异常介绍"><a href="#12-3-异常介绍" class="headerlink" title="12.3 异常介绍"></a>12.3 异常介绍</h2><ol><li>程序执行中发生的不正常情况，开发过程中的语法错误和逻辑错误不是异常</li><li>异常事件分为两类<ol><li>Error：JVM无法解决的问题，比如JVM系统内部错误、资源耗尽、StackOverflowError和OOM</li><li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理，比如空指针访问、试图读取不存在的文件、网络连接中断等<ol><li>运行时异常</li><li>编译时异常</li></ol></li></ol></li></ol><h2 id="12-4-异常体系图"><a href="#12-4-异常体系图" class="headerlink" title="12.4 异常体系图"></a>12.4 异常体系图</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240411165727.png" alt="image.png"></p><ol><li>运行时异常可以不做处理</li><li>编译时异常，必须要处理的异常</li><li>常见运行时异常包括<ol><li>NullPointerException 空指针异常</li><li>ArithmeticException 数学运算异常</li><li>ArrayIndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 类型转换异常</li><li>NumberFormatException 数字格式不正常异常</li></ol></li></ol><h2 id="12-6-编译异常"><a href="#12-6-编译异常" class="headerlink" title="12.6 编译异常"></a>12.6 编译异常</h2><ol><li>常见编译异常<ol><li>SQLException 操作数据库，查询表可能发生异常</li><li>IOExcetion 操作文件时，发生的异常</li><li>FileNotFoundException 操作一个不存在的文件时，发生异常</li><li>ClassNotFoundException 加载类，该类不存在时，异常</li><li>EOFException  操作文件，到文件末尾，发生异常</li><li>IllegalArgumentException 参数异常</li></ol></li></ol><h2 id="12-8-异常处理"><a href="#12-8-异常处理" class="headerlink" title="12.8 异常处理"></a>12.8 异常处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>代码可能有异常<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>捕获到异常时，将异常封装成Exception对象e，传递给<span class="hljs-keyword">catch</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>不管<span class="hljs-keyword">try</span>代码块是否有异常发生，都要执行<span class="hljs-keyword">finally</span><br>通常将资源的释放操作放在<span class="hljs-keyword">finally</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>方式<ol><li>try - cathc -finally<ol><li>程序员在代码捕获发生的异常，自行处理</li></ol></li><li>throws<ol><li>将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者JVM<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240411171245.png" alt="image.png|500"></li></ol></li></ol></li></ol><h2 id="12-9-try-catch-异常处理"><a href="#12-9-try-catch-异常处理" class="headerlink" title="12.9 try-catch 异常处理"></a>12.9 try-catch 异常处理</h2><ol><li>可以有多个catch语句，捕获不同的异常，要求父类异常在后，子类异常在前，如果发生异常只会匹配一个catch</li></ol><h2 id="12-10-throws异常处理"><a href="#12-10-throws异常处理" class="headerlink" title="12.10 throws异常处理"></a>12.10 throws异常处理</h2><ol><li>如果一个方法可能生成某种异常，但不确定如何处理，则此方法应显式声明抛出异常，表示该方法将不对这些异常进行处理，而该方法的调用者负责处理</li><li>throws可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li></ol><h2 id="12-11-自定义异常"><a href="#12-11-自定义异常" class="headerlink" title="12.11 自定义异常"></a>12.11 自定义异常</h2><ol><li>步骤<ol><li>定义类：自定义异常类名，继承Exception或RuntimeException</li><li>如果继承Exception，属于编译异常</li><li>如果继承RuntimeException，属于运行异常，一般都设置这个<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeException</span><span class="hljs-params">(String message)</span> &#123;<span class="hljs-comment">//构造器  </span><br>        <span class="hljs-built_in">super</span>(message);  <br>    &#125;  <br>&#125;<br><span class="hljs-keyword">if</span>(!(age &gt;= <span class="hljs-number">18</span> &amp;&amp; age &lt;= <span class="hljs-number">120</span>)) &#123;  <br>    <span class="hljs-comment">//这里我们可以通过构造器，设置信息  </span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeException</span>(<span class="hljs-string">&quot;年龄需要在 18~120之间&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="12-12-throw和throws的区别"><a href="#12-12-throw和throws的区别" class="headerlink" title="12.12 throw和throws的区别"></a>12.12 throw和throws的区别</h2><ol><li>throws：异常处理的一种方式，位置在方法声明处，后面跟异常类型</li><li>throw：手动生成异常对象的关键帧，位置在方法体中，后面跟异常对象</li></ol><h1 id="13-常用类"><a href="#13-常用类" class="headerlink" title="13.常用类"></a>13.常用类</h1><h2 id="13-1-包装类"><a href="#13-1-包装类" class="headerlink" title="13.1 包装类"></a>13.1 包装类</h2><ol><li>针对八种基本数据类型相应的引用类型</li><li>Boolean&#x2F;Character&#x2F;Byte&#x2F;Short&#x2F;Integer&#x2F;Long&#x2F;Float&#x2F;Double</li><li>jdk5前，手动装箱和拆箱，装箱：基本类型-&gt;包装类型</li><li>jdk5后，自动装箱和拆箱<ol><li>自动装箱int-&gt;Integer底层调用的是valueOf()，如Integer.valueOf()</li><li>拆箱 Integer-&gt;int，Integer.intValue()</li></ol></li></ol><h3 id="13-1-5-包装类型和-String-类型的相互转换"><a href="#13-1-5-包装类型和-String-类型的相互转换" class="headerlink" title="13.1.5 包装类型和 String 类型的相互转换"></a>13.1.5 包装类型和 String 类型的相互转换</h3><ol><li>Integer -&gt; String<ol><li>Integer.toString()</li><li>String.value(Integer i)</li><li>i+””</li></ol></li><li>String -&gt; Integer<ol><li>Integer.parseInt(str)</li><li>new Integer(str) &#x2F;&#x2F; 构造器</li></ol></li></ol><h2 id="13-2-String类"><a href="#13-2-String类" class="headerlink" title="13.2 String类"></a>13.2 String类</h2><ol><li>两种创建String对象的方式<ol><li>直接赋值：String s &#x3D; “123”;</li><li>调用构造器：String s &#x3D; new String(“123”);</li></ol></li><li>string是final类，代表不可变，一旦被分配内容，内容不可再变，每次更新实际改的是地址，效率较低</li><li>StringBuffer保存的是字符串变量，里面的值可以更改，更新的是内容不用更新地址，效率较高</li><li>String-&gt;StringBuffer<ol><li>方式1：StringBuffer stringBuffer &#x3D; new StringBuffer(str);</li><li>方式2：StringBuffer stringBuffer &#x3D; new StringBuffer(); stringBuffer &#x3D; stringBuffer.append(str);</li></ol></li><li>StringBuffer -&gt; String<ol><li>方式1：String s &#x3D; stringBuffer3.toString();</li><li>方式2：String s1 &#x3D; new String(stringBuffer3);</li></ol></li><li>StringBuilder，同StringBuffer，不是线程安全的，如果单线程使用优先使用，在大多数实现中，比StringBuffer快</li></ol><h2 id="13-8-Arrays类"><a href="#13-8-Arrays类" class="headerlink" title="13.8 Arrays类"></a>13.8 Arrays类</h2><ol><li>Arrays.toString(arr) 返回数组的字符串形式</li><li>Arrays.sort()</li><li>Arrays.binarySearch(arr, 3) 二分查找</li><li>Integer[] newArr &#x3D; Arrays.copyOf(arr, arr.length)</li><li>Arrays.fill(arr, 99)</li><li>Arrays.equals(arr1, arr2) 比较两个数组元素内容是否完全一致</li><li>List&lt;Integer&gt; asList &#x3D; Arrays.asList(arr) 转换成list</li></ol><h2 id="13-9-System类"><a href="#13-9-System类" class="headerlink" title="13.9 System类"></a>13.9 System类</h2><ol><li>exit(0) 退出当前程序,0表示正常退出状态</li><li>System.arraycopy(arr1, 0, arr2, 0, 3)</li><li>currentTimeMillens:返回当前时间距离1970-1-1到现在的毫秒数</li><li>System.gc()  垃圾回收机制</li></ol><h2 id="13-10-BigInteger和BigDecimal类"><a href="#13-10-BigInteger和BigDecimal类" class="headerlink" title="13.10 BigInteger和BigDecimal类"></a>13.10 BigInteger和BigDecimal类</h2><ol><li>BI：保存比较大的整型</li><li>BD：保存精度更高的浮点数</li><li>常见方法<ol><li>add 加</li><li>subtract 减</li><li>multiply 乘</li><li>divide 除</li></ol></li></ol><h2 id="13-11-日期类"><a href="#13-11-日期类" class="headerlink" title="13.11 日期类"></a>13.11 日期类</h2><ol><li>Date：精确到毫秒，代表特定瞬间<ol><li>Date d1 &#x3D; new Date(); &#x2F;&#x2F;获取当前系统时间</li></ol></li><li>SimpleDateFormat：格式和解析日期的类<ol><li>SimpleDateFormat sdf &#x3D; new SimpleDateFormat(“yyyy 年 MM 月 dd 日 hh:mm:ss E”);</li></ol></li><li>Calendar 是一个抽象类， 并且构造器是 private<ol><li>通过 getInstance() 来获取实例 Calendar c &#x3D; Calendar.getInstance();</li><li>c.get(Calendar.MONTH) + 1</li><li>c.get(Calendar.DAY_OF_MONTH)</li><li>…</li></ol></li><li>LocalDate&#x2F;LocalTime&#x2F;LocalDateTime<ol><li>使用 now() 返回表示当前日期时间的 对象</li><li>使用 DateTimeFormatter 对象来进行格式化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> dateTimeFormatter.format(ldt);<br>System.out.println(<span class="hljs-string">&quot;格式化的日期=&quot;</span> + format);<br></code></pre></td></tr></table></figure></li></ol></li><li>Instant 时间戳<ol><li>Instant now &#x3D; Instant.now();  获取表示当前时间戳的对象</li><li>Date date &#x3D; Date.from(now);   通过 from 可以把 Instant 转成 Date   </li><li>Instant instant &#x3D; date.toInstant();   通过 date 的 toInstant() 可以把 date 转成 Instant 对象</li></ol></li></ol><h1 id="14-集合"><a href="#14-集合" class="headerlink" title="14.集合"></a>14.集合</h1><ol><li>集合动态保存任意多个对象<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240412153126.png" alt="image.png"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240412153139.png" alt="image.png|474"></li></ol><h2 id="14-3-Collection接口"><a href="#14-3-Collection接口" class="headerlink" title="14.3 Collection接口"></a>14.3 Collection接口</h2><h3 id="14-3-2-Collection接口遍历元素方式"><a href="#14-3-2-Collection接口遍历元素方式" class="headerlink" title="14.3.2 Collection接口遍历元素方式"></a>14.3.2 Collection接口遍历元素方式</h3><ol><li>Iterator 迭代器<ol><li>Iterator 仅用于遍历集合，本身并不存放对象</li><li><code>Iterator iterator = coll.iterator();</code> 得到集合的迭代器</li><li>hashNext() 判断是否还有下一个元素</li><li>next() 下移元素，取出元素</li></ol></li><li>增强for循环<ol><li>增强for就是简化版的iterator</li><li>只能用来遍历集合或数组</li><li><code>for(元素类型 元素名：集合名或数组名)</code></li></ol></li></ol><h2 id="14-4-接口和常用方法"><a href="#14-4-接口和常用方法" class="headerlink" title="14.4 接口和常用方法"></a>14.4 接口和常用方法</h2><ol><li>List集合类中元素有序，添加元素顺序和取出顺序一致，可重复</li><li>每个元素都有对应的顺序索引，所以支持索引</li><li>List接口的实现类有ArrayLsit、LinkedList、Vector</li><li>常用方法<ol><li>add(元素)</li><li>add(index, 元素)</li><li>indexOf(元素)</li><li>get(index)</li><li>lastIndexOf(obj)</li><li>remove(obj)</li><li>set(index, obj)</li><li>subList(fromIndex, toIndex)</li></ol></li></ol><h3 id="14-4-4-List的三种遍历方式"><a href="#14-4-4-List的三种遍历方式" class="headerlink" title="14.4.4 List的三种遍历方式"></a>14.4.4 List的三种遍历方式</h3><ol><li>迭代器<ol><li>while(iterator.hasNext()){print(iterator.next())}</li></ol></li><li>增强for<ol><li>for(Object o : list)</li></ol></li><li>普通for</li></ol><h2 id="14-5-ArrayList-低层结构和源码分析"><a href="#14-5-ArrayList-低层结构和源码分析" class="headerlink" title="14.5 ArrayList 低层结构和源码分析"></a>14.5 ArrayList 低层结构和源码分析</h2><ol><li>ArrayList可以加入null，并且多个</li><li>ArrayList低层由数组实现</li><li>ArrayList基本等同于Vector，线程不安全，执行效率高，多线程情况下不建议用ArrayList</li><li>低层源码<ol><li>ArrayList中维护了应该Object类型的数组，elementData</li><li>transient Object[] elementData  &#x2F;&#x2F; transient表示瞬间短暂，表示该属性不会被序号号</li><li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加则扩容elementData为10，如果再次扩容，则扩容1.5倍</li><li>如果使用指定大小的构造器，则初始容量为指定大小，如扩容，扩1.5倍</li></ol></li></ol><h2 id="14-6-Vector-低层结构和源码分析"><a href="#14-6-Vector-低层结构和源码分析" class="headerlink" title="14.6 Vector 低层结构和源码分析"></a>14.6 Vector 低层结构和源码分析</h2><ol><li>Vector 底层也是一个对象数组，protected Object[] elementData;</li><li>Vector 是线程同步的，即线程安全的，操作方法带 synchronized</li><li>扩容<ol><li>无参构造，默认10，按2倍扩容</li><li>有参指定大小，2倍扩容</li></ol></li></ol><h2 id="14-7-LinkedList-低层结构和源码分析"><a href="#14-7-LinkedList-低层结构和源码分析" class="headerlink" title="14.7 LinkedList 低层结构和源码分析"></a>14.7 LinkedList 低层结构和源码分析</h2><ol><li>LinkedList底层实现了双向链表和双端队列特点</li><li>可以添加任意元素，重复元素，包括null</li><li>线程不安全，没有实现同步</li><li>底层操作机制<ol><li>LinkedList底层维护了一个双向链表</li><li>两个属性 first和last 分别指向首节点和尾结点</li><li>每个节点，里面又维护了 prev、next、item 三个属性</li></ol></li></ol><h2 id="14-8-ArrayList-和-LinkedList-比较"><a href="#14-8-ArrayList-和-LinkedList-比较" class="headerlink" title="14.8 ArrayList 和 LinkedList 比较"></a>14.8 ArrayList 和 LinkedList 比较</h2><ol><li>如果改查操作多，选择Arraylist</li><li>如果增删操作多，选择linkedList</li></ol><h2 id="14-9-Set接口和常用方法"><a href="#14-9-Set接口和常用方法" class="headerlink" title="14.9 Set接口和常用方法"></a>14.9 Set接口和常用方法</h2><ol><li>无序、没有索引</li><li>不允许重复元素，最多包含一个null</li><li>遍历方式<ol><li>迭代器</li><li>增强for</li><li>不能索引获取</li></ol></li></ol><h2 id="14-10-HashSet"><a href="#14-10-HashSet" class="headerlink" title="14.10 HashSet"></a>14.10 HashSet</h2><ol><li>HashSet实际上是HashMap</li><li>不能加入相同元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">set.add(<span class="hljs-string">&quot;lucy&quot;</span>);<span class="hljs-comment">//添加成功</span><br>set.add(<span class="hljs-string">&quot;lucy&quot;</span>);<span class="hljs-comment">//加入不了</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;tom&quot;</span>));<span class="hljs-comment">//OK</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;tom&quot;</span>));<span class="hljs-comment">//Ok</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hsp&quot;</span>));<span class="hljs-comment">//ok</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hsp&quot;</span>));<span class="hljs-comment">//加入不了.</span><br></code></pre></td></tr></table></figure></li><li>HashSet低层是HashMap，HashMap底层是数组+链表+红黑树<ol><li>添加一个元素时，先得到hash值，转换成 索引值</li><li>找到存储数据表 table，看这个索引位置是否已经存放元素</li><li>如果没有，直接加入</li><li>如果有，调用equals比较，如果相同，放弃添加，如果不同则添加到最后</li><li>java8后，如果一条链表的元素个数达到 TREEIFY_THREASHOLD 默认8，并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY 默认64，就会转换成红黑树，否则采用数组扩容机制</li></ol></li></ol><h2 id="14-11-LinkedHashSet"><a href="#14-11-LinkedHashSet" class="headerlink" title="14.11 LinkedHashSet"></a>14.11 LinkedHashSet</h2><ol><li>LinkedHashSet是HashSet子类</li><li>LinkedHashSet底层是LinkedHashMap，底层维护了一个 数组+双向链表</li><li>LinkedHashSet根据元素的 hashCode 值来决定元素的存储位置，同时用链表维护元素的次序，使得元素看起来是以插入顺序保存的</li><li>LinkedHashSet 不允许添加重复元素</li><li>说明<ol><li>每个节点都有before和after属性，这样可以形成双向链表</li><li>在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链表，如果已经存在则不添加</li></ol></li></ol><h2 id="14-12-Map-接口和常用方法"><a href="#14-12-Map-接口和常用方法" class="headerlink" title="14.12 Map 接口和常用方法"></a>14.12 Map 接口和常用方法</h2><ol><li>Map和Collection并列存在，用于保存具有映射关系的数据：key-value</li><li>key和value可以是任意引用类型的数据</li><li>key可以为null仅限一个，value也可以为null可以多个</li><li>一对k-v是放在 HashMap&amp;Node中，又因为Node实现了Entry接口，所以有些书也会说一对k-v就是一个Entry</li><li>Map接口遍历方法<ol><li>cotainsKey：查找键是否存在</li><li>keySet：获取所有的键 <code>Set keyset = map.keySet();</code></li><li>entrySet：获取所有关系 k-v </li><li>values：获取所有的值 <code>Collection values = map.values();</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Set</span> <span class="hljs-variable">entrySet</span> <span class="hljs-operator">=</span> map.entrySet();<span class="hljs-comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span><br><span class="hljs-comment">//(1) 增强 for</span><br><span class="hljs-keyword">for</span> (Object entry : entrySet) &#123;<br><span class="hljs-comment">//将 entry 转成 Map.Entry</span><br>Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Map.Entry) entry;<br>System.out.println(m.getKey() + <span class="hljs-string">&quot;-&quot;</span> + m.getValue());<br>&#125;<br><span class="hljs-comment">//(2) 迭代器</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator3</span> <span class="hljs-operator">=</span> entrySet.iterator();<br><span class="hljs-keyword">while</span> (iterator3.hasNext()) &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> iterator3.next();<br><span class="hljs-comment">//System.out.println(next.getClass());</span><br><span class="hljs-comment">//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span><br><span class="hljs-comment">//向下转型 Map.Entry</span><br>Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Map.Entry) entry;<br>System.out.println(m.getKey() + <span class="hljs-string">&quot;-&quot;</span> + m.getValue());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="14-13-HashMap"><a href="#14-13-HashMap" class="headerlink" title="14.13 HashMap"></a>14.13 HashMap</h2><ol><li>Map接口的常用实现类：HashMap，Hashtable、Properties</li><li>HashMap 是Map接口使用率最高的实现类</li><li>HashMap 以 key-val 对的方式存储数据</li><li>key不能重复，如果添加相同的key，会覆盖原来的key-val</li><li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式存储</li><li>HashMap 没有实现同步，因此线程不安全，没有 synchronized</li><li>扩容机制，同HashSet<ol><li>HashMap底层维护了Node类型的数组 table，默认为null</li><li>创建对象时，加载因子 loadfactor 初始化为0.75</li><li>当添加key-val 时，通过key的哈希值得到在table的索引，然后判断该索引处是否有元素，如果没有元素直接添加。如果索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，直接替换val，如果不相等需要判断是树结构还是链表结构，做出相应处理。如果容量不够，需要扩容。</li><li>第一次添加，需要扩容table容量为16， 临界值 为12 </li><li>再扩容，需要扩容table容量为原来的两倍</li></ol></li></ol><h2 id="14-14-HashTable"><a href="#14-14-HashTable" class="headerlink" title="14.14 HashTable"></a>14.14 HashTable</h2><ol><li>hashtable的key、value都不能为null，否则抛异常</li><li>hashtable的使用方法和HashMap一样</li><li>hashtable底层是线程安全的，效率较低</li></ol><h2 id="14-15-Properties"><a href="#14-15-Properties" class="headerlink" title="14.15 Properties"></a>14.15 Properties</h2><ol><li>Properties类继承了Hashtable类，并实现了Map接口</li><li>Properties 还可以用于 从xx.properties 文件中，加载数据到Properties类对象，并进行读取和修改</li><li>xx.properties文件通常作为配置文件</li></ol><h2 id="14-16-开发中如何选择集合实现类"><a href="#14-16-开发中如何选择集合实现类" class="headerlink" title="14.16 开发中如何选择集合实现类"></a>14.16 开发中如何选择集合实现类</h2><ol><li>判断存储类型，是一组对象还是一组键值对</li><li>一组对象：Collection<ol><li>允许重复：List<ol><li>增删多：LinkedList</li><li>改查多：Arraylist</li></ol></li><li>不允许重复<ol><li>无序：HashSet</li><li>排序：TreeSet</li><li>插入和取出顺一致：LinkedHashSet</li></ol></li></ol></li><li>一组键值对<ol><li>键无序：HashMap</li><li>键排序：TreeMap</li><li>键插入和取出顺序一致：LinkedHashMap</li><li>读取文件：Properties</li></ol></li></ol><h2 id="14-17-Collections-工具类"><a href="#14-17-Collections-工具类" class="headerlink" title="14.17 Collections 工具类"></a>14.17 Collections 工具类</h2><ol><li>排序操作，均为static方法<ol><li>reverse(List)</li><li>shuffle(List)</li><li>sort(List)</li><li>sort(List, Comparator)</li><li>swap(List, int, int)</li></ol></li><li>查找替换<ol><li>Object max(Collection)</li><li>Object max(Collection, Comparator) 根据指定顺序返回给定集合的最大值</li><li>Object min(Collection)</li><li>Object min(Collection, Comparator) </li><li>int frequency(Collection, Object) 返回集合指定元素出现的次数</li><li>void copy(List dest, List src) 将src中的内如复制到dest中</li><li>boolean replaceAll(List list, Object oldVal, Object newVal) 使用新值替换所有的旧值</li></ol></li></ol><h1 id="15-泛型"><a href="#15-泛型" class="headerlink" title="15.泛型"></a>15.泛型</h1><h2 id="15-1-泛型的理解和好处"><a href="#15-1-泛型的理解和好处" class="headerlink" title="15.1 泛型的理解和好处"></a>15.1 泛型的理解和好处</h2><ol><li>传统方法存在的问题<ol><li>不能对加入到集合的数据类型进行约束</li><li>遍历的时候，需要进行类型转换，如果集合中的数据量较大，效率低</li></ol></li><li>泛型 <code>ArrayList&lt;Dog&gt; arr = new ArrayList&lt;Dog&gt;()</code></li><li>泛型的好处<ol><li>编译时，检查添加元素的类型，提高安全性</li><li>减少类型转换次数，提高效率<ol><li>不使用泛型：Dog -&gt; 加入 -&gt; Object -&gt; 取出 -&gt; Dog</li><li>使用泛型：Dog -&gt; Dog -&gt; Dog</li></ol></li><li>不再提示编译警告</li></ol></li></ol><h2 id="15-3-泛型介绍"><a href="#15-3-泛型介绍" class="headerlink" title="15.3 泛型介绍"></a>15.3 泛型介绍</h2><ol><li>泛型 &#x3D;&gt; Integer、String、Dog…</li><li>泛型又称为参数化类型，解决数据类型的安全性问题</li><li>在类声明或实例化时只要指定好需要的类型就好</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生classcastexception异常</li><li>泛型的作用：<ol><li>可以在类声明时通过一个标识表示类中某个属性的类型</li><li>某个方法的返回值的类型</li><li>参数类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型</span><br>Person&lt;String&gt; person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;String&gt;(<span class="hljs-string">&quot;韩顺平教育&quot;</span>);<br><span class="hljs-comment">// 泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，</span><br><span class="hljs-comment">// 或者是某个方法的返回值的类型，或者是参数类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;E&gt; &#123;<br>E s ;<span class="hljs-comment">//E 表示 s 的数据类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(E s)</span> &#123;<span class="hljs-comment">//E 也可以是参数类型</span><br><span class="hljs-built_in">this</span>.s = s;<br>&#125;<br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回类型使用 E</span><br><span class="hljs-keyword">return</span> s;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="15-4-泛型的语法"><a href="#15-4-泛型的语法" class="headerlink" title="15.4 泛型的语法"></a>15.4 泛型的语法</h2><h3 id="15-4-1-泛型的声明"><a href="#15-4-1-泛型的声明" class="headerlink" title="15.4.1 泛型的声明"></a>15.4.1 泛型的声明</h3><ol><li>interface 接口 &lt;T&gt;{} 和 clss 类 &lt;K,V&gt;{}<ol><li>其中，TKV不代表值，代表类型</li><li>任意字母都可以</li></ol></li></ol><h3 id="15-4-2-泛型的实例化"><a href="#15-4-2-泛型的实例化" class="headerlink" title="15.4.2 泛型的实例化"></a>15.4.2 泛型的实例化</h3><ol><li>在类名后指定类型参数的类型<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">List&lt;Customer&gt; iterator <span class="hljs-operator">=</span> customer.iteratr()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="15-4-4-注意事项和细节"><a href="#15-4-4-注意事项和细节" class="headerlink" title="15.4.4 注意事项和细节"></a>15.4.4 注意事项和细节</h3><ol><li>T K V都必须是引用类型，不能是基本数据类型</li><li>给泛型指定具体类型后 ，可以传入该类型或其子类类型</li><li>泛型的使用形式：<ol><li><code>List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;()</code></li><li><code>List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;()</code> 推荐，编译器会进行类型推断</li></ol></li><li>如果 <code>List list3 = new ArrayList()</code> 默认给它的泛型是Object</li></ol><h2 id="15-6-自定义泛型"><a href="#15-6-自定义泛型" class="headerlink" title="15.6 自定义泛型"></a>15.6 自定义泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 &lt;T,R,V...&gt;&#123;<br>成员<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>&lt;T, R, M&gt;&#123;<br>String name;<br>T s;<br>R m;<br><span class="hljs-keyword">public</span> M <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br><span class="hljs-comment">//因为数组在 new 不能确定 T 的类型，就无法在内存开空间</span><br>T[] ts; <span class="hljs-comment">// ok</span><br>T[] ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// no</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>细节：<ol><li>普通成员可以使用泛型，比如属性、方法</li><li>使用泛型的数组不能初始化</li><li>静态方法中不能使用类的泛型，静态是和类相关的，在类加载时，对象还没创建</li><li>泛型类的类型是在创建对象时确定的，因为创建对象时，需要指定确定类型</li><li>如果在创建对象时，没有指定类型，默认为Object</li></ol></li><li>自定义泛型接口<ol><li>语法 <code>interface 接口名 &lt;T,R,M...&gt;&#123;&#125;</code></li><li>接口中，静态成员不能使用泛型</li><li>泛型接口的类型，在继承接口或者实现接口时确定</li><li>没有指定类型默认为Object<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUsb</span>&lt;U, R&gt; &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//U name; 不能这样使用</span><br><span class="hljs-comment">//普通方法中，可以使用接口泛型</span><br>R <span class="hljs-title function_">get</span><span class="hljs-params">(U u)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(R r)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(R r1, R r2, U u1, U u2)</span>;<br><span class="hljs-comment">//在 jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型</span><br><span class="hljs-keyword">default</span> R <span class="hljs-title function_">method</span><span class="hljs-params">(U u)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//在继承接口 指定泛型接口的类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IUsb</span>&lt;String, Double&gt; &#123;<br><br>&#125;<br><span class="hljs-comment">//当我们去实现 IA 接口时，因为 IA 在继承 IUsu 接口时，指定了 U 为 String R 为 Double</span><br><span class="hljs-comment">//，在实现 IUsu 接口的方法时，使用 String 替换 U, 是 Double 替换 R</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Double <span class="hljs-title function_">get</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(Double aDouble)</span> &#123;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Double r1, Double r2, String u1, String u2)</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>自定义泛型方法<ol><li>泛型方法可以定义在普通类中，也可以定义在泛型类中</li><li>当泛型方法被调用时，类型会确定</li><li><code>public void eat(E e)&#123;&#125;</code> 修饰符后没有&lt;T,R…&gt; eat，方法不是泛型方法而是使用了泛型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>&lt;T, R, M&gt; &#123;<span class="hljs-comment">//自定义泛型类</span><br><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">(E e)</span> &#123; <span class="hljs-comment">//泛型方法</span><br>System.out.println(e.getClass().getSimpleName());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(U u)</span> &#123;&#125;<span class="hljs-comment">//错误，因为 U 没有声明</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(M m)</span> &#123;<br>&#125; <span class="hljs-comment">//ok</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="15-7-泛型的继承和通配符"><a href="#15-7-泛型的继承和通配符" class="headerlink" title="15.7 泛型的继承和通配符"></a>15.7 泛型的继承和通配符</h2><ol><li>泛型不具备继承性<ol><li><code>List&lt;Object&gt; list = new ArrayList&lt;String&gt;()</code> 错</li></ol></li><li>&lt;?&gt;: 支持任意泛型类型</li><li>&lt;? extends A&gt; 支持A类及A的子类，规定了泛型的上限</li><li>&lt;? super A&gt; 支持A类及A的父类，不限于直接父类，规定了泛型的下限<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ? extends AA 表示 上限，可以接受 AA 或者 AA 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection2</span><span class="hljs-params">(List&lt;? extends AA&gt; c)</span> &#123;<br><span class="hljs-keyword">for</span> (Object object : c) &#123;<br>System.out.println(object);<br>&#125;<br>&#125;<br><span class="hljs-comment">//说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection1</span><span class="hljs-params">(List&lt;?&gt; c)</span> &#123;<br><span class="hljs-keyword">for</span> (Object object : c) &#123; <span class="hljs-comment">// 通配符，取出时，就是 Object</span><br>System.out.println(object);<br>&#125;<br>&#125;<br><span class="hljs-comment">// ? super 子类类名 AA:支持 AA 类以及 AA 类的父类，不限于直接父类，</span><br><span class="hljs-comment">//规定了泛型的下限</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection3</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> AA&gt; c)</span> &#123;<br><span class="hljs-keyword">for</span> (Object object : c) &#123;<br>System.out.println(object);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="15-9-JUnit"><a href="#15-9-JUnit" class="headerlink" title="15.9 JUnit"></a>15.9 JUnit</h2><ol><li>一个类有很多功能代码需要测试，为了测试就需要写入到main方法中</li><li>如果有多个功能代码测试，需要来回注销，切换麻烦</li><li>如果可以直接运行一个方法就方便很多，并且可以给出相关信息</li><li>JUnit是一个java的单元测试框架</li><li>@Test注解</li></ol><h1 id="17-多线程"><a href="#17-多线程" class="headerlink" title="17. 多线程"></a>17. 多线程</h1><h2 id="17-1-线程"><a href="#17-1-线程" class="headerlink" title="17.1 线程"></a>17.1 线程</h2><ol><li>进程是运行中的程序，比如QQ，操作系统会为该进程分配内存空间</li><li>进程是程序的一次执行过程，或是正在运行的一个程序，是动态过程：有自身的产生、存在和消亡的过程</li><li>什么是线程<ol><li>线程由进程创建，是进程的一个实体</li><li>一个进程可以拥有多个线程</li></ol></li><li>其他概念<ol><li>单线程：同一个时刻，只允许执行一个线程</li><li>多线程：同一个时刻，可以执行多个线程</li><li>并发：同一个时刻，多个任务交替执行，造成貌似同时的错觉，单核CPU实现多任务就是并发</li><li>并行：同一个时刻，多个任务同时执行，多核CPU可以实现并行</li></ol></li></ol><h2 id="17-2-线程基本使用"><a href="#17-2-线程基本使用" class="headerlink" title="17.2 线程基本使用"></a>17.2 线程基本使用</h2><ol><li>创建线程的两种方式<ol><li>继承Thread类，重写run方法</li><li>实现Runable接口，重写run方法</li></ol></li><li>start()方法调用start0后，该线程不一定会立马执行，只是将线程变成了可运行状态，具体什么时候执行，取决于CPU，由CPU统一调用</li><li>jconsole 监测线程</li></ol><h2 id="17-3-继承Thread和实现Runable的区别"><a href="#17-3-继承Thread和实现Runable的区别" class="headerlink" title="17.3 继承Thread和实现Runable的区别"></a>17.3 继承Thread和实现Runable的区别</h2><ol><li>继承Thread和实现Runable接口来创建线程本质上没有区别</li><li>实现Runable接口的方式更适合多个线程共享一个资源的情况，并且避免了单继承的限制</li></ol><h2 id="17-4-线程终止"><a href="#17-4-线程终止" class="headerlink" title="17.4 线程终止"></a>17.4 线程终止</h2><ol><li>当线程完成任务后，会自动退出</li><li>通过使用变量控制run方法退出的方式停止线程，即通知方式</li></ol><h2 id="17-5-线程常用方法"><a href="#17-5-线程常用方法" class="headerlink" title="17.5 线程常用方法"></a>17.5 线程常用方法</h2><ol><li>常用方法<ol><li>setName  设置线程名称</li><li>getName  返回该线程的名称</li><li>start  开始执行线程</li><li>run  调用线程对象的run方法</li><li>setPriority  更改线程的优先级</li><li>getPriority  获取线程的优先级</li><li>sleep  休眠</li><li>interrupt  中断线程</li></ol></li><li>注意事项和细节<ol><li>start 底层会创建新的线程，调用run </li><li>线程优先级的范围<ol><li>MAX_PRIORITY 10</li><li>NORMAL_PRIORITY 5</li><li>MIN_PRIORITY 1</li></ol></li><li>interrupt 中断线程，并没有真正的结束线程，一般用于中断正在休眠休眠线程</li><li>sleep  线程的静态方法</li></ol></li><li>常用方法2<ol><li>yield：线程的礼让，让出CPU，让其他线程执行，但是礼让的时间不确定，所以不一定礼让成功</li><li>join：线程的插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有任务</li></ol></li><li>用户线程和守护线程<ol><li>用户线程：也叫工作线程，当线程的任务执行完或通知方式结束</li><li>守护线程：一般为工作线程服务，当所有的用户线程结束，守护线程自动结束</li><li>常见的守护线程：垃圾回收机制</li></ol></li></ol><h2 id="17-6-线程的生命周期"><a href="#17-6-线程的生命周期" class="headerlink" title="17.6 线程的生命周期"></a>17.6 线程的生命周期</h2><ol><li>JDK中用Thread.State枚举表示线程的状态<ol><li>NEW  尚未启动的线程</li><li>RUNNABLE  在java虚拟机中执行的线程<ol><li>READY</li><li>RUNNING</li></ol></li><li>BLOCKED  被阻塞等待监视器锁定的线程</li><li>WAITING  正在等待另一个线程执行特定动作的线程</li><li>TIMED_WAITING  正在等待另一个线程执行动作达到特定等待时间的线程</li><li>TERMINATED  已退出的线程<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240414182952.png" alt="image.png"></li></ol></li></ol><h2 id="17-7-线程的同步"><a href="#17-7-线程的同步" class="headerlink" title="17.7 线程的同步"></a>17.7 线程的同步</h2><ol><li>Synchronized<ol><li>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻最多有一个线程访问，以保证数据的完整性</li><li>线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址机械能操作</li></ol></li><li>操作具体方法<ol><li>同步代码块  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<span class="hljs-comment">// 得到对象的锁，才能操作同步代码</span><br><span class="hljs-comment">// 需要被同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>synchronized 放在方法声明中，表示整个方法-为同步方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(String name)</span>&#123;<br><span class="hljs-comment">// 需要被同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="17-10-互斥锁"><a href="#17-10-互斥锁" class="headerlink" title="17.10 互斥锁"></a>17.10 互斥锁</h2><ol><li>java中，引入对象互斥锁来保证共享数据操作的完整性</li><li>每个对象都对应一个互斥锁的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</li><li>关键字synchronized来与对象的互斥锁联系，当某对象用synchronized修饰时，标明该对象在任一时刻只能由一个线程访问</li><li>同步的局限性：导致程序的执行效率降低</li><li>同步方法（非静态）的锁可以是this，也可以是其他对象</li><li>同步方法（静态）的锁为当前类本身 <code>synchronized (SellTicket03.class)</code></li><li>注意事项<ol><li>同步方法如果没有使用static修饰，默认锁对象为this</li><li>如果方法使用static修饰，默认锁对象为当前类.class</li><li>实现的落地步骤<ol><li>分析需要上锁的代码</li><li>选择同步代码块或同步方法</li><li>要求多个线程的锁对象为同一个即可</li></ol></li></ol></li></ol><h2 id="17-11-死锁"><a href="#17-11-死锁" class="headerlink" title="17.11 死锁"></a>17.11 死锁</h2><ol><li>多个线程都占用了对方的锁资源，但是不肯想让，导致了死锁</li></ol><h2 id="17-12-释放锁"><a href="#17-12-释放锁" class="headerlink" title="17.12 释放锁"></a>17.12 释放锁</h2><ol><li>释放锁的操作<ol><li>当前线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块、同步方法中遇到break、return</li><li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li><li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li></ol></li><li>不会释放锁的操作<ol><li>线程执行同步代码块或同步方法时，程序调用Thread.sleep() Thread.yeild()方法，暂停当前线程的执行，不会释放锁</li><li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁</li></ol></li></ol><h1 id="19-IO流"><a href="#19-IO流" class="headerlink" title="19.IO流"></a>19.IO流</h1><h2 id="19-1-文件"><a href="#19-1-文件" class="headerlink" title="19.1 文件"></a>19.1 文件</h2><ol><li>文件在程序中是以流的形式来操作的<ol><li>流：数据在数据源（文件）和程序（内存）之间经历的路径</li><li>输入流：数据从数据源到程序的路径</li><li>输出流：数据从程序到数据源的路径</li></ol></li><li>常见的文件操作<ol><li>创建文件对象相关构造器和方法<ol><li>new File(String pathName) 根据路径构建file对象</li><li>new File(File parent, String child) 根据父目录文件+子路径构建</li><li>new File(String parent, String child) 根据父目录+子路径构建</li></ol></li></ol></li><li>获取文件相关信息<ol><li>getName</li><li>getAbsolutePath</li><li>getParent</li><li>Length</li><li>exists</li><li>isFile 是文件还是目录</li><li>isDirectory</li></ol></li><li>目录的操作和文件的删除<ol><li>mkdir 创建一级目录</li><li>mkdirs 创建多级目录</li><li>delete 删除空目录或文件</li></ol></li></ol><h2 id="19-3-IO流原理及流的分类"><a href="#19-3-IO流原理及流的分类" class="headerlink" title="19.3 IO流原理及流的分类"></a>19.3 IO流原理及流的分类</h2><ol><li>Java IO流原理<ol><li>java程序中，对于数据的输入输出操作是以流的方式进行</li><li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据</li><li>输入input</li><li>输出output</li></ol></li><li>流的分类<ol><li>按操作数据单位不同<ol><li>字节流（8 bit）二进制文件，字符流（按字符）文本文件</li><li>字节流 InputStream  OutputStream</li><li>字符流 Reader  Writer</li><li>IO流都是从以上4个抽象基类派生的</li></ol></li><li>按数据流的流向不同<ol><li>输入流，输出流</li></ol></li><li>按流的角色不同<ol><li>节点流、处理流&#x2F;包装流</li></ol></li></ol></li></ol><h2 id="19-4-IO流体系图"><a href="#19-4-IO流体系图" class="headerlink" title="19.4 IO流体系图"></a>19.4 IO流体系图</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240414195601.png" alt="image.png"></p><h3 id="19-4-1-FileInputStream"><a href="#19-4-1-FileInputStream" class="headerlink" title="19.4.1 FileInputStream"></a>19.4.1 FileInputStream</h3><ol><li>单个字节的读取，效率比较低</li></ol><h3 id="19-4-5-FileOutputStream"><a href="#19-4-5-FileOutputStream" class="headerlink" title="19.4.5 FileOutputStream"></a>19.4.5 FileOutputStream</h3><ol><li>new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容</li><li>new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面</li><li>write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流</li></ol><h3 id="19-4-6-FileReader和FileWriter"><a href="#19-4-6-FileReader和FileWriter" class="headerlink" title="19.4.6 FileReader和FileWriter"></a>19.4.6 FileReader和FileWriter</h3><ol><li>FileReader相关方法<ol><li>new FileReader(File&#x2F;String)</li><li>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</li><li>read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li><li>相关API<ol><li>new String(char[])：将char[]转换为String</li><li>new String(char[], off, len)：将char[]的指定部分转换成String</li></ol></li></ol></li><li>FileWriter相关方法<ol><li>new FileWriter(File&#x2F;String) ：覆盖模式，相当于流的指针在首段</li><li>new FileWriter(File&#x2F;String, true)：追加模式，相当于流的指针在尾端</li><li>write(int)：写入单个字符</li><li>write(char[])：写入指定数组</li><li>write(char[], off, len)：写入指定数组的指定部分</li><li>write(String)：写入整个字符串</li><li>write(String, off, len)：写入指定字符串的指定部分</li><li>相关API<ol><li>toCharArray</li></ol></li><li>注意<ol><li>FileWriter使用后必须close或者flush，否则写入不到指定的文件</li></ol></li></ol></li></ol><h2 id="19-5-节点流和处理流"><a href="#19-5-节点流和处理流" class="headerlink" title="19.5 节点流和处理流"></a>19.5 节点流和处理流</h2><ol><li>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter</li><li>处理类也叫包装流，是连接在已经存在的流（节点流、处理流）之上，为程序提供更强大的读写功能，也更灵活，如BufferedReader、BufferedWriter</li><li><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415093850.png" alt="image.png"></li><li>节点流和处理流的区别和联系<ol><li>节点流是低层流&#x2F;低级流，直接跟数据源相接</li><li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li><li>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li></ol></li><li>处理流的功能<ol><li>性能的提高：主要以增加缓冲的方式提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷方法来一次输入输出大批量的数据，使用更加灵活方便</li></ol></li></ol><h3 id="19-5-5-BufferedReader、BufferedWriter"><a href="#19-5-5-BufferedReader、BufferedWriter" class="headerlink" title="19.5.5 BufferedReader、BufferedWriter"></a>19.5.5 BufferedReader、BufferedWriter</h3><ol><li>BufferedReader、BufferedWriter属于字符流，按照字符来读取数据</li><li>关闭时处理流只需要关闭外层流即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建 bufferedReader</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath));<br><span class="hljs-comment">//读取</span><br>String line; <span class="hljs-comment">//按行读取, 效率高</span><br><span class="hljs-comment">//说明</span><br><span class="hljs-comment">//1. bufferedReader.readLine() 是按行读取文件</span><br><span class="hljs-comment">//2. 当返回 null 时，表示文件读取完毕</span><br><span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>System.out.println(line);<br>&#125;<br><span class="hljs-comment">//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流</span><br>bufferedReader.close();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePath));<br>bufferedWriter.write(<span class="hljs-string">&quot;hello, 韩顺平教育!&quot;</span>);<br>bufferedWriter.newLine();<span class="hljs-comment">//插入一个和系统相关的换行</span><br>bufferedWriter.write(<span class="hljs-string">&quot;hello2, 韩顺平教育!&quot;</span>);<br>bufferedWriter.newLine();<br><span class="hljs-comment">//说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭</span><br>bufferedWriter.close();<br></code></pre></td></tr></table></figure></li><li>BufferedReader 和 BufferedWriter 是安装字符操作，不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏</li></ol><h3 id="19-5-6-处理流-BufferedInputStream-和-BufferedOutputStream"><a href="#19-5-6-处理流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="19.5.6 处理流-BufferedInputStream 和 BufferedOutputStream"></a>19.5.6 处理流-BufferedInputStream 和 BufferedOutputStream</h3><ol><li>BufferedOutputStream是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统，字节流可以操作二进制文件</li></ol><h3 id="19-5-8-对象流-ObjectInputStream-和-ObjectOutputStream"><a href="#19-5-8-对象流-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="19.5.8 对象流-ObjectInputStream 和 ObjectOutputStream"></a>19.5.8 对象流-ObjectInputStream 和 ObjectOutputStream</h3><ol><li>序列化：保存数据时，保存数据的值和数据类型，比如 int 100，Dog dog &#x3D; new Dog(“小黄”)</li><li>反序列化：恢复数据时，恢复数据的值和数据类型</li><li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现两个接口之一<ol><li>Serializable  标记接口，没有方法</li><li>Externalizable 该接口有方法需要实现，因此一般实现上面的 Serializable接口</li></ol></li><li>ObjectOutputStream 提供 序列化功能</li><li>ObjectInputStream 提供 反序列化功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\data.dat&quot;</span>;<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br><span class="hljs-comment">//序列化数据到 e:\data.dat</span><br>oos.writeInt(<span class="hljs-number">100</span>);<span class="hljs-comment">// int -&gt; Integer (实现了 Serializable)</span><br>oos.writeBoolean(<span class="hljs-literal">true</span>);<span class="hljs-comment">// boolean -&gt; Boolean (实现了 Serializable)</span><br>oos.writeChar(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">// char -&gt; Character (实现了 Serializable)</span><br>oos.writeDouble(<span class="hljs-number">9.5</span>);<span class="hljs-comment">// double -&gt; Double (实现了 Serializable)</span><br>oos.writeUTF(<span class="hljs-string">&quot;韩顺平教育&quot;</span>);<span class="hljs-comment">//String</span><br><span class="hljs-comment">//保存一个 dog 对象</span><br>oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;日本&quot;</span>, <span class="hljs-string">&quot;白色&quot;</span>));<br>oos.close();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建流对象</span><br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\data.dat&quot;</span>));<br><span class="hljs-comment">// 2.读取， 注意顺序</span><br>System.out.println(ois.readInt());<br>System.out.println(ois.readBoolean());<br>System.out.println(ois.readChar());<br>System.out.println(ois.readDouble());<br>System.out.println(ois.readUTF());<br>System.out.println(ois.readObject());<br><span class="hljs-comment">// 3.关闭</span><br>ois.close();<br></code></pre></td></tr></table></figure></li><li>注意事项<ol><li>读写顺序要一致</li><li>要求序列化或反序列化对象，需要实现Serializable</li><li>序列化的类中建议添加SerialVersionID，提高版本兼容性</li><li>序列化对象时，默认将里面所有属性都进行序列化，除了static或transient修饰的成员</li><li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li><li>序列化具有可继承性，如果某类已经实现了序列化，则它的子类也默认实现了序列化</li></ol></li></ol><h3 id="19-5-10-标准输入输出流"><a href="#19-5-10-标准输入输出流" class="headerlink" title="19.5.10 标准输入输出流"></a>19.5.10 标准输入输出流</h3><ol><li>System.in 标准输入</li><li>System.out 标准输出</li></ol><h3 id="19-5-11-转换流-InputStreamReader-和-OutputStreamWriter"><a href="#19-5-11-转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="19.5.11 转换流-InputStreamReader 和 OutputStreamWriter"></a>19.5.11 转换流-InputStreamReader 和 OutputStreamWriter</h3><ol><li>当处理纯文本数据时，使用字符流效率更高，并且可以有效解决中文问题，使用建议将字节流转换成字符流<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\a.txt&quot;</span>;<br><span class="hljs-comment">//1. 把 FileInputStream 转成 InputStreamReader</span><br><span class="hljs-comment">//2. 指定编码 gbk</span><br><span class="hljs-comment">//3. 把 InputStreamReader 传入 BufferedReader</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath), <span class="hljs-string">&quot;gbk&quot;</span>));<br><span class="hljs-comment">//4. 读取</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> br.readLine();<br>System.out.println(<span class="hljs-string">&quot;读取内容=&quot;</span> + s);<br><span class="hljs-comment">//5. 关闭外层流</span><br>br.close();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建流对象</span><br><span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;d:\\a.txt&quot;</span>), <span class="hljs-string">&quot;gbk&quot;</span>);<br><span class="hljs-comment">// 2.写入</span><br>osw.write(<span class="hljs-string">&quot;hello,韩顺平教育~&quot;</span>);<br><span class="hljs-comment">// 3.关闭</span><br>osw.close();<br></code></pre></td></tr></table></figure></li></ol><h2 id="19-6-打印流-PrintStream-和-PrintWriter"><a href="#19-6-打印流-PrintStream-和-PrintWriter" class="headerlink" title="19.6 打印流 PrintStream 和 PrintWriter"></a>19.6 打印流 PrintStream 和 PrintWriter</h2><h2 id="19-7-Properties-类"><a href="#19-7-Properties-类" class="headerlink" title="19.7 Properties 类"></a>19.7 Properties 类</h2><ol><li>专门用于读写配置文件的集合类<ol><li>配置文件的格式<ol><li>键&#x3D;值</li></ol></li></ol></li><li>键值对不需要有空格，值不需要用引号，默认类型就是String</li><li>常见方法<ol><li>load：加载配置文件的键值对到Properties对象</li><li>list：将数据显示到指定设备</li><li>getProperty(key)：根据键获取值</li><li>setProperty(key, value)：设置键值对到Properties对象</li><li>store：将Properties中的键值对存储到配置文件中，如果含有中文，会存储为Unicode码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用 Properties 类来读取 mysql.properties 文件</span><br><span class="hljs-comment">//1. 创建 Properties 对象</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><span class="hljs-comment">//2. 加载指定配置文件</span><br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;src\\mysql.properties&quot;</span>));<br><span class="hljs-comment">//3. 把 k-v 显示控制台</span><br>properties.list(System.out);<br><span class="hljs-comment">//4. 根据 key 获取对应的值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用 Properties 类来创建 配置文件, 修改配置文件内容</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><span class="hljs-comment">//1.如果该文件没有 key 就是创建</span><br><span class="hljs-comment">//2.如果该文件有 key ,就是修改</span><br>properties.setProperty(<span class="hljs-string">&quot;charset&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>);<br>properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;src\\mysql2.properties&quot;</span>), <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="21-网络编程"><a href="#21-网络编程" class="headerlink" title="21.网络编程"></a>21.网络编程</h1><h2 id="21-1-网络的相关概念"><a href="#21-1-网络的相关概念" class="headerlink" title="21.1 网络的相关概念"></a>21.1 网络的相关概念</h2><ol><li>网络通信：两台设备之间通过网络实现数据传输</li><li>java.net包下提供了一系列的类和接口，完成网络通信</li><li>ip地址：唯一标识网络中的每台计算机&#x2F;主机</li><li>查看ip地址：ipconfig</li><li>ip地址组成：网络地址+主机地址<ol><li>A:0-127</li><li>B:128-191</li><li>C:192-223</li><li>D:224-239</li><li>E:240-247</li><li>127.0.0.1表示本机地址</li></ol></li><li>端口号：用于标识计算机上某个特定的网络程序<ol><li>0-65535</li><li>0-1024已经被占用，ssh 22、ftp 21、smtp 25、HTTP 80</li><li>tomcat 8080、mysql 3306、oracle 1521、sqlserver 1433</li></ol></li></ol><h3 id="21-1-6-网络通信协议"><a href="#21-1-6-网络通信协议" class="headerlink" title="21.1.6 网络通信协议"></a>21.1.6 网络通信协议</h3><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415121042.png" alt="image.png"></p><ol><li>协议 tcp&#x2F;ip，网络通讯协议，是Internet的基础</li><li><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415121154.png" alt="image.png"></li><li>TCP和UDP<ol><li>TCP：传输控制协议<ol><li>使用tcp前，先建立tcp连接形成传输数据通道</li><li>传输前，三次握手，可靠的</li><li>连接中可进行大数据量的传输</li><li>传输完毕，需要释放已经建立的连接，效率低</li></ol></li><li>UDP：用户数据协议<ol><li>将数据、源、目的封装成数据包，不需要建立连接</li><li>每个数据报的大学限制在64k内，不适合传输大量数据</li><li>无需连接，故不可靠</li><li>发送数据结束时无需释放资源，因为不是面向连接的，速度快</li></ol></li></ol></li></ol><h2 id="21-2-InetAddress类"><a href="#21-2-InetAddress类" class="headerlink" title="21.2 InetAddress类"></a>21.2 InetAddress类</h2><ol><li>获取本机InetAddress对象 getlocalHost</li><li>根据指定主机名&#x2F;域名获取ip地址对象 getByName</li><li>获取InetAddress对象的主机名 getHostName</li><li>获取InetAddress对象的地址 getHostAddress</li></ol><h2 id="21-3-Socket"><a href="#21-3-Socket" class="headerlink" title="21.3 Socket"></a>21.3 Socket</h2><ol><li>套接字 Socket</li><li>通信的两端都要有Socket，是两台机器间通信的端点</li><li>网络通信其实就是Socket间的通信</li><li>Socket允许程序把网络连接当做一个流，数据在两个Socket间通过IO传输</li><li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li><li><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415152429.png" alt="image.png"></li></ol><h2 id="21-4-TCP"><a href="#21-4-TCP" class="headerlink" title="21.4 TCP"></a>21.4 TCP</h2><ol><li>基于客户端-服务端的网络通信</li><li>底层使用的是TCP&#x2F;IP协议</li><li>基于Socket的TCP编程</li><li>分为Server和Client端<ol><li>结束标记<ol><li>Socket.shutdown()</li><li>writer.newLine()<ol><li>需要使用readLine()来读取，否则没意义</li></ol></li></ol></li><li>输入输出</li></ol></li><li>案例4<ol><li>客户端<ol><li>将磁盘上的图片读取到字节数组中</li><li>通过socket拿到输出流</li></ol></li><li>服务端<ol><li>接收socket输入流</li><li>读取的文件数据转成某个目录下的图片</li><li>回复信息给客户端</li></ol></li></ol></li><li>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯，这个端口是TCP&#x2F;IP来分配的，是不确定的，随机的</li></ol><h3 id="21-4-6-netstat指令"><a href="#21-4-6-netstat指令" class="headerlink" title="21.4.6 netstat指令"></a>21.4.6 netstat指令</h3><ol><li>netstat -an 查看当前主机网络情况，包括端口监听情况和网络连接情况</li><li>netstat -an | more 分页显示</li><li>netstat -anb 查看哪个程序监听</li></ol><h2 id="21-5-UDP网络编程"><a href="#21-5-UDP网络编程" class="headerlink" title="21.5 UDP网络编程"></a>21.5 UDP网络编程</h2><ol><li>DatagramSocket和DatagramPacket类实现了基于UDP协议网络编程</li><li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能安全到目的地，也不确定什么时候可以抵达</li><li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</li><li>UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接</li><li>基本流程<ol><li>核心的两个类&#x2F;对象</li><li>建立发送端、接收端（没有服务端和客户端概念）</li><li>发送数据前，建立数据报 DatagramPacket对象</li><li>调用DatagramSocket的发送、接收方法</li><li>关闭DatagramSocket</li></ol></li></ol><h1 id="23-反射"><a href="#23-反射" class="headerlink" title="23.反射"></a>23.反射</h1><h2 id="23-1-引入反射"><a href="#23-1-引入反射" class="headerlink" title="23.1 引入反射"></a>23.1 引入反射</h2><ol><li>根据配置文件 re.properties 指定信息，创建Cat对象逼格调用方法hi<ol><li>传统方法：<ol><li>Cat cat &#x3D; new Cat();</li><li>cat.hi();</li></ol></li><li>通过外部文件配置，在不修改源码情况下控制程序，也符合设计模式的OCP原则（开闭原则：不修改源码，扩容功能）</li></ol></li></ol><h2 id="23-2-反射机制"><a href="#23-2-反射机制" class="headerlink" title="23.2 反射机制"></a>23.2 反射机制</h2><h3 id="23-2-1-Java-Reflection"><a href="#23-2-1-Java-Reflection" class="headerlink" title="23.2.1 Java Reflection"></a>23.2.1 Java Reflection</h3><ol><li>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，比如成员变量、构造器、成员方法等，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</li><li>加载完类之后，在堆中就产生了一个Class类型的对象，一个类志愿一个Class对象。这个对象包含了类的完整结构信息，通过这个对象得到类的结构。这个Class对象就像一面镜子，透过这个镜子可以看到类的结构。</li></ol><h3 id="23-2-2-Java反射机制原理图"><a href="#23-2-2-Java反射机制原理图" class="headerlink" title="23.2.2 Java反射机制原理图"></a>23.2.2 Java反射机制原理图</h3><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240415201604.png" alt="image.png"></p><ol><li>反射机制可以完成<ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol></li><li>反射相关类<ol><li>java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象</li><li>java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法</li><li>java.lang.reflect.Field：代表类的成员变量<ol><li>getField 不能得到私有的属性</li><li>传统写法 对象.成员变量 , 反射 : 成员变量对象.get(对象)</li></ol></li><li>java.lang.reflect.Constructor：代表类的构造方法</li></ol></li><li>反射优缺点<ol><li>可以动态地创建和使用对象，使用灵活</li><li>缺点：使用反射基本是解释执行，对执行速度有影响</li></ol></li><li>反射调用优化-关闭访问检查<ol><li>Method和Field、Constructor对象都有setAccessible()方法</li><li>setAccessible作用是启动和禁用访问安全检查的开关</li><li>参数值为true表示反射的对象在使用时取消访问检查，提高反射效率，参数值为false则进行访问检查</li></ol></li></ol><h2 id="23-3-Class类"><a href="#23-3-Class类" class="headerlink" title="23.3 Class类"></a>23.3 Class类</h2><ol><li>Class也是类，因此继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class对象可以完整地得到一个类的完整结构，通过一系列API</li><li>Class对象是存放在堆里</li><li>类的字节码二进制数据是放在方法区里，有的地方称为类的元数据（包括方法代码、变量名、方法名、访问权限等）</li><li>Class类常用方法<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416094823.png" alt="image.png"></li></ol><h2 id="23-4-获取-Class-类对象"><a href="#23-4-获取-Class-类对象" class="headerlink" title="23.4 获取 Class 类对象"></a>23.4 获取 Class 类对象</h2><ol><li>在不同阶段有不同的获取方式<ol><li>代码阶段&#x2F;编译阶段：Class.forName</li><li>加载阶段：类.class</li><li>运行阶段：对象.getClass</li><li>直接通过类加载器获取对象<br>  <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416110456.png" alt="image.png"><br>   <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416110502.png" alt="image.png"><br>   <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416110508.png" alt="image.png"></li></ol></li></ol><h2 id="23-5-哪些类型有Class对象"><a href="#23-5-哪些类型有Class对象" class="headerlink" title="23.5 哪些类型有Class对象"></a>23.5 哪些类型有Class对象</h2><ol><li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;String&gt; cls1 = String.class;<span class="hljs-comment">//外部类</span><br>Class&lt;Serializable&gt; cls2 = Serializable.class;<span class="hljs-comment">//接口</span><br>Class&lt;Integer[]&gt; cls3 = Integer[].class;<span class="hljs-comment">//数组</span><br>Class&lt;<span class="hljs-type">float</span>[][]&gt; cls4 = <span class="hljs-type">float</span>[][].class;<span class="hljs-comment">//二维数组</span><br>Class&lt;Deprecated&gt; cls5 = Deprecated.class;<span class="hljs-comment">//注解</span><br><span class="hljs-comment">//枚举</span><br>Class&lt;Thread.State&gt; cls6 = Thread.State.class;<br>Class&lt;Long&gt; cls7 = <span class="hljs-type">long</span>.class;<span class="hljs-comment">//基本数据类型</span><br>Class&lt;Void&gt; cls8 = <span class="hljs-keyword">void</span>.class;<span class="hljs-comment">//void 数据类型</span><br>Class&lt;Class&gt; cls9 = Class.class;<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="23-6-类加载"><a href="#23-6-类加载" class="headerlink" title="23.6 类加载"></a>23.6 类加载</h2><ol><li>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载<ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，也不报错，降低依赖性</li></ol></li><li>类加载时机<ol><li>创建对象时（new）&#x2F;&#x2F; 静态加载</li><li>当子类被加载时，父类也被加载 &#x2F;&#x2F; 静态加载</li><li>调用类中的静态成员时 &#x2F;&#x2F; 静态加载</li><li>通过反射 &#x2F;&#x2F; 动态加载</li></ol></li><li>类加载过程图<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416112506.png" alt="image.png"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416112913.png" alt="image.png"></li><li>加载阶段<ol><li>JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件也可能是jar包甚至网络）转化成二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</li></ol></li><li>连接阶段-验证<ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全</li><li>包括<ol><li>文件格式验证：是否以魔数 oxcafebabe开头</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol></li><li>可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间</li></ol></li><li>连接阶段-准备<ol><li>JVM会在该阶段对<strong>静态变量</strong>分配内存并默认初始化，这些变量所使用的内存都将在方法区中进行分配<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span><br><span class="hljs-comment">//2. n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是 20</span><br><span class="hljs-comment">//3. n3 是 static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure></li></ol></li><li>连接阶段-解析<ol><li>JVM将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程</li></ol></li><li>Initialization（初始化）<ol><li>初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行&lt;clinit&gt;()方法的过程</li><li>&lt;clinit&gt;()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并</li><li>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕</li></ol></li></ol><h2 id="23-7-通过反射获取类的结构信息"><a href="#23-7-通过反射获取类的结构信息" class="headerlink" title="23.7 通过反射获取类的结构信息"></a>23.7 通过反射获取类的结构信息</h2><ol><li>java.lang.Class类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416120332.png" alt="image.png|500"></li><li>java.lang.reflect.Field 类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416120354.png" alt="image.png|500"></li><li>: java.lang.reflect.Method 类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416120411.png" alt="image.png|500"></li><li>java.lang.reflect.Constructor 类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416120427.png" alt="image.png|500"></li></ol><h2 id="23-8-通过反射创建对象"><a href="#23-8-通过反射创建对象" class="headerlink" title="23.8 通过反射创建对象"></a>23.8 通过反射创建对象</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416121348.png" alt="image.png|575"></p><h2 id="23-9-通过反射访问类中的成员"><a href="#23-9-通过反射访问类中的成员" class="headerlink" title="23.9 通过反射访问类中的成员"></a>23.9 通过反射访问类中的成员</h2><ol><li>访问属性<ol><li>根据属性名获取Field对象 Field f &#x3D; class对象.getDeclaredField(属性名);</li><li>爆破：f.setAccessible(true)</li><li>访问<ol><li>f.set(o, 值)  o表示对象</li><li>syso(f.get(o))  o表示对象</li></ol></li><li>注意：如果是静态属性，则set和get中的参数o可以写成null</li></ol></li><li>访问方法<ol><li>根据方法名和参数列表获取Method方法对象 Method m &#x3D; class.getDeclaredMethod(方法名，xx.classs) 得到本类所有方法</li><li>获取对象  Object o &#x3D; class.newInstance()</li><li>爆破  m.setAccessible(true)</li><li>访问 Object returnValue &#x3D; m.invoke(o, 实参列表)  </li><li>注意：如果是静态方法，则invoke的参数哦可以写成null</li></ol></li></ol><h1 id="24-MySQL"><a href="#24-MySQL" class="headerlink" title="24.MySQL"></a>24.MySQL</h1><h2 id="24-2-数据库"><a href="#24-2-数据库" class="headerlink" title="24.2 数据库"></a>24.2 数据库</h2><ol><li>命令行连接mysql数据库：<code>mysql -h 主机名 -P 端口号 -u 用户名 -p密码</code></li><li>启动数据库：<code>net start mysql 服务名</code></li><li>关闭数据库：<code>net stop mysql 服务名</code></li></ol><h2 id="24-6-数据在数据库中的存储方式"><a href="#24-6-数据在数据库中的存储方式" class="headerlink" title="24.6 数据在数据库中的存储方式"></a>24.6 数据在数据库中的存储方式</h2><ol><li>表的一行称为一条记录</li><li>java中，一行记录往往使用对象表示</li></ol><h2 id="24-7-SQL语句分类"><a href="#24-7-SQL语句分类" class="headerlink" title="24.7 SQL语句分类"></a>24.7 SQL语句分类</h2><ol><li>DDL：数据定义语句</li><li>DML：数据操作语句</li><li>DQL：数据查询语句</li><li>DCL：数据控制语句</li></ol><h2 id="24-8-创建数据库"><a href="#24-8-创建数据库" class="headerlink" title="24.8 创建数据库"></a>24.8 创建数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建数据库  <br><span class="hljs-keyword">create</span> database hsp01;  <br># 删除数据库  <br><span class="hljs-keyword">drop</span> database hsp01;  <br># 创建数据库并指定字符集  <br><span class="hljs-keyword">create</span> database hsp02 <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;  <br><span class="hljs-keyword">drop</span> database hsp02;  <br># 创建数据库并指定字符集和校对集  <br># utf8_general_ci: 不区分大小写  <br># utf8_bin: 区分大小写  <br><span class="hljs-keyword">create</span> database hsp03 <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8 <span class="hljs-keyword">collate</span> utf8_general_ci;  <br><span class="hljs-keyword">drop</span> database hsp03;<br></code></pre></td></tr></table></figure><h2 id="24-9-查看、删除数据库"><a href="#24-9-查看、删除数据库" class="headerlink" title="24.9 查看、删除数据库"></a>24.9 查看、删除数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看所有数据库  <br><span class="hljs-keyword">show</span> databases;  <br># 查看创建hsp数据库的定义信息  <br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> database hsp;<br></code></pre></td></tr></table></figure><h2 id="24-10-备份恢复数据库"><a href="#24-10-备份恢复数据库" class="headerlink" title="24.10 备份恢复数据库"></a>24.10 备份恢复数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#备份, 要在 Dos 下执行 mysqldump 指令其实在 mysql 安装目录\bin<br>#这个备份的文件，就是对应的 <span class="hljs-keyword">sql</span> 语句<br>mysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-operator">-</span>B hsp_db02 hsp_db03 <span class="hljs-operator">&gt;</span> d:\\bak.sql<br><span class="hljs-keyword">DROP</span> DATABASE ecshop;<br>#恢复数据库(注意：进入 Mysql 命令行再执行)<br>source d:\\bak.sql<br>#第二个恢复方法， 直接将 bak.sql 的内容放到查询编辑器中，执行<br></code></pre></td></tr></table></figure><h2 id="24-13-创建表"><a href="#24-13-创建表" class="headerlink" title="24.13 创建表"></a>24.13 创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(  <br>    id <span class="hljs-type">int</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),  <br>    password <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),  <br>    birthday <span class="hljs-type">date</span>  <br>)<span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8 <span class="hljs-keyword">collate</span> utf8_general_ci engine innodb;<br></code></pre></td></tr></table></figure><h2 id="24-14-常用数据类型"><a href="#24-14-常用数据类型" class="headerlink" title="24.14 常用数据类型"></a>24.14 常用数据类型</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416152223.png" alt="image.png"></p><h3 id="24-14-1-数值型-整数-的基本使用"><a href="#24-14-1-数值型-整数-的基本使用" class="headerlink" title="24.14.1 数值型(整数)的基本使用"></a>24.14.1 数值型(整数)的基本使用</h3><ol><li>在能够满足需求的情况下，尽量选择占用空间小的<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table1(  <br>    id tinyint  <br>);  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table2(  <br>    id tinyint unsigned  <br>); # unsigned 无符号  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1 <span class="hljs-keyword">values</span>(<span class="hljs-number">-1</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1;<br></code></pre></td></tr></table></figure></li></ol><h3 id="24-14-4-数值型-小数-的基本使用"><a href="#24-14-4-数值型-小数-的基本使用" class="headerlink" title="24.14.4 数值型(小数)的基本使用"></a>24.14.4 数值型(小数)的基本使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table03(  <br>    num1 <span class="hljs-type">float</span>,  <br>    num2 <span class="hljs-keyword">double</span>,  <br>    num3 <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)  <br>);  <br># <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)表示总共<span class="hljs-number">10</span>位，小数点后保留<span class="hljs-number">2</span>位<br></code></pre></td></tr></table></figure><h3 id="24-14-5-字符串的基本使用"><a href="#24-14-5-字符串的基本使用" class="headerlink" title="24.14.5 字符串的基本使用"></a>24.14.5 字符串的基本使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t04(  <br>    name <span class="hljs-type">char</span>(<span class="hljs-number">255</span>),  <br>    fakename <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)  <br>);  <br># <span class="hljs-type">char</span> 固定长度，不足的用空格填充  <br># <span class="hljs-type">varchar</span> 可变长度<br></code></pre></td></tr></table></figure><h3 id="24-14-6-字符串使用细节"><a href="#24-14-6-字符串使用细节" class="headerlink" title="24.14.6 字符串使用细节"></a>24.14.6 字符串使用细节</h3><ol><li>char(4)：4表示字符数，不是字节数，不管是中文还是字母都是放4个，按字符计算</li><li>varchar(4)：4表示字符数，按定义好的表的编码存放数据<ol><li>可变长度，本事还需要占用1-3个字节来存放内容长度，L（实际数据大小）+（1-3）字节</li></ol></li><li>存放文本也可以使用 text 数据类型，text没有默认值，大小为0-2^16字节，如果要存放更多字符可以选择mediumtext和longtext<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t05(  <br>    name <span class="hljs-type">char</span>(<span class="hljs-number">4</span>)  <br>);  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t05 <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;aaaa&#x27;</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t05;  <br>  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t06(  <br>    name text,  <br>    content mediumtext,  <br>    content2 longtext  <br>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="24-14-7-日期类型的基本使用"><a href="#24-14-7-日期类型的基本使用" class="headerlink" title="24.14.7 日期类型的基本使用"></a>24.14.7 日期类型的基本使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t06(  <br>    birthdate <span class="hljs-type">date</span>,  <br>    job_time datetime,  <br>    create_time <span class="hljs-type">timestamp</span>  <br>                <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">current_timestamp</span>  <br>                <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">current_timestamp</span>  <br>);  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t06(birthdate, job_time) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1990-01-01&#x27;</span>, <span class="hljs-string">&#x27;2010-01-01 00:00:00&#x27;</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t06;<br></code></pre></td></tr></table></figure><h2 id="24-16-修改表"><a href="#24-16-修改表" class="headerlink" title="24.16 修改表"></a>24.16 修改表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 在emp 上增加一个image 列  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> image <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;  <br># 查看emp表结构  <br><span class="hljs-keyword">desc</span> emp;  <br># 修改某列，改变长度  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp  <br>    modify sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;  <br># 删除某列  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp  <br>    <span class="hljs-keyword">drop</span> image;  <br># 修改表的字符集  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp  <br>    <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> charset utf8;  <br># 修改列名  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp  <br>    change name user_name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><h2 id="24-18数据库-C-create-R-read-U-update-D-delete-语句"><a href="#24-18数据库-C-create-R-read-U-update-D-delete-语句" class="headerlink" title="24.18数据库 C[create]R[read]U[update]D[delete]语句"></a>24.18数据库 C[create]R[read]U[update]D[delete]语句</h2><h2 id="24-19-Insert-语句"><a href="#24-19-Insert-语句" class="headerlink" title="24.19 Insert 语句"></a>24.19 Insert 语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp (id, user_name, salary, sex) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><ol><li>插入的数据应于字段的数据类型相同</li><li>数据的长度应在列的规定范围内</li><li>在 values 中列出的数据位置必须与被加入的列的排列位置相对应</li><li>字符和日期型数据应包含在单引号中</li><li>. 列可以插入空值[前提是该字段允许为空]</li><li>insert into tab_name (列名..) values (),(),() 形式添加多条记录</li><li>如果是给表中的所有字段添加数据，可以不写前面的字段名称</li></ol><h2 id="24-20-update-语句"><a href="#24-20-update-语句" class="headerlink" title="24.20 update 语句"></a>24.20 update 语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> emp  <br>    <span class="hljs-keyword">set</span> user_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Tom&#x27;</span>  <br>    <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol><li>如果修改多个字段，可以 set 字段1&#x3D;值1，字段2&#x3D;值2</li></ol><h2 id="24-21-delete-语句"><a href="#24-21-delete-语句" class="headerlink" title="24.21 delete 语句"></a>24.21 delete 语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> emp  <br>    <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;  <br># 删除所有数据  <br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><ol><li>delete不能删除某一列的值，可以使用update设置为null或者’’</li></ol><h2 id="24-22-select-语句"><a href="#24-22-select-语句" class="headerlink" title="24.22 select 语句"></a>24.22 select 语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">select</span> 基本语法  <br># <span class="hljs-keyword">select</span> [<span class="hljs-keyword">distinct</span>] <span class="hljs-operator">*</span><span class="hljs-operator">|</span>&#123;col1, col2,...&#125;  <br>#       <span class="hljs-keyword">from</span> table_name;  <br># 查询所有学生信息  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;  <br># 查询所有学生的姓名和应用成绩  <br><span class="hljs-keyword">select</span> name, english <span class="hljs-keyword">from</span> student;  <br># 成绩去重  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> english <span class="hljs-keyword">from</span> student;<br></code></pre></td></tr></table></figure><ol><li>重命名 <code>select col1 as 别名 from 表名</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 统计每个学生总分  <br><span class="hljs-keyword">select</span> name,(chinese<span class="hljs-operator">+</span>math<span class="hljs-operator">+</span>english) <span class="hljs-keyword">as</span> total <span class="hljs-keyword">from</span> student;  <br># 统计每个学生总分，按总分降序排列  <br><span class="hljs-keyword">select</span> name,(chinese<span class="hljs-operator">+</span>math<span class="hljs-operator">+</span>english) <span class="hljs-keyword">as</span> total <span class="hljs-keyword">from</span> student <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> total <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="24-22-7-在-where-子句中经常使用的运算符"><a href="#24-22-7-在-where-子句中经常使用的运算符" class="headerlink" title="24.22.7 在 where 子句中经常使用的运算符"></a>24.22.7 在 where 子句中经常使用的运算符</h3><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240416160857.png" alt="image.png"></p><h3 id="24-22-10-使用-order-by-子句排序查询结果"><a href="#24-22-10-使用-order-by-子句排序查询结果" class="headerlink" title="24.22.10 使用 order by 子句排序查询结果"></a>24.22.10 使用 order by 子句排序查询结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1, col2,<br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> col1 <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><ol><li>asc 升序默认</li><li>desc 降序</li></ol><h2 id="24-23合计-统计函数"><a href="#24-23合计-统计函数" class="headerlink" title="24.23合计&#x2F;统计函数"></a>24.23合计&#x2F;统计函数</h2><h3 id="24-23-1-count"><a href="#24-23-1-count" class="headerlink" title="24.23.1 count"></a>24.23.1 count</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">|</span> <span class="hljs-built_in">count</span>(列名)<br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><ol><li>count(*) 返回满足条件的记录的行数</li><li>count(列): 统计满足条件的某列有多少个，但是会排除 为 null 的情况</li></ol><h3 id="24-23-2-sum"><a href="#24-23-2-sum" class="headerlink" title="24.23.2 sum"></a>24.23.2 sum</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(列名)<br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">where</span> ...;<br><br># 统计一个班级语文、英语、数学各科的总成绩<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(math) <span class="hljs-keyword">AS</span> math_total_score,<span class="hljs-built_in">SUM</span>(english),<span class="hljs-built_in">SUM</span>(chinese) <span class="hljs-keyword">FROM</span> student;<br># 统计一个班级语文成绩平均分<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(chinese)<span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student;<br></code></pre></td></tr></table></figure><h3 id="24-23-3-avg"><a href="#24-23-3-avg" class="headerlink" title="24.23.3 avg"></a>24.23.3 avg</h3><p>同sum</p><h3 id="24-23-4-max-min"><a href="#24-23-4-max-min" class="headerlink" title="24.23.4 max&#x2F;min"></a>24.23.4 max&#x2F;min</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">求出班级数学最高分和最低分<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(math) <span class="hljs-keyword">AS</span> math_high_socre, <span class="hljs-built_in">MIN</span>(math) <span class="hljs-keyword">AS</span> math_low_socre<br><span class="hljs-keyword">FROM</span> student;<br></code></pre></td></tr></table></figure><h3 id="24-23-5-使用-group-by-子句对列进行分组-先创建测试表"><a href="#24-23-5-使用-group-by-子句对列进行分组-先创建测试表" class="headerlink" title="24.23.5 使用 group by 子句对列进行分组 [先创建测试表]"></a>24.23.5 使用 group by 子句对列进行分组 [先创建测试表]</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1,col2,... <span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> col1<br></code></pre></td></tr></table></figure><h3 id="24-23-6-使用-having-子句对分组后的结果进行过滤"><a href="#24-23-6-使用-having-子句对分组后的结果进行过滤" class="headerlink" title="24.23.6 使用 having 子句对分组后的结果进行过滤"></a>24.23.6 使用 having 子句对分组后的结果进行过滤</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col1, col2,... <br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> col1 <span class="hljs-keyword">having</span> ...<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 对查询的结果进行分组统计  <br># <span class="hljs-keyword">having</span> 对分组后的结果进行筛选  <br>  <br># 显示每个部门的平均工资和最高工资  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal), <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;  <br># 使用数学方法，对小数点进行处理  <br><span class="hljs-keyword">select</span> round(<span class="hljs-built_in">avg</span>(sal), <span class="hljs-number">2</span>), round(<span class="hljs-built_in">max</span>(sal), <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;  <br><span class="hljs-keyword">SELECT</span> FORMAT(<span class="hljs-built_in">AVG</span>(sal),<span class="hljs-number">2</span>), <span class="hljs-built_in">MAX</span>(sal) , deptno <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno;  <br># 显示每个部门的每种岗位的平均工资和最低工资  <br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(sal), <span class="hljs-built_in">MIN</span>(sal) , deptno, job <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno, job;  <br>  <br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(sal) <span class="hljs-keyword">AS</span> avg_sal, deptno  <br>    <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno  <br>    <span class="hljs-keyword">HAVING</span> avg_sal <span class="hljs-operator">&lt;</span> <span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><h2 id="24-24字符串相关函数"><a href="#24-24字符串相关函数" class="headerlink" title="24.24字符串相关函数"></a>24.24字符串相关函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"># CHARSET(str) 返回字符串字符集  <br><span class="hljs-keyword">select</span> charset(ename) <span class="hljs-keyword">from</span> emp;  <br># CONCAT (string2 [,... ]) 连接字符串，拼接成一列  <br><span class="hljs-keyword">select</span> concat(ename,<span class="hljs-string">&#x27;工作是&#x27;</span>,job) <span class="hljs-keyword">from</span> emp;  <br># INSTR (string ,substring ) 返回 substring 在 string 中出现的位置,没有返回 <span class="hljs-number">0</span># dual 亚元表，用于测试函数  <br><span class="hljs-keyword">SELECT</span> INSTR(<span class="hljs-string">&#x27;hanshunping&#x27;</span>, <span class="hljs-string">&#x27;ping&#x27;</span>) <span class="hljs-keyword">FROM</span> DUAL;  <br># UCASE (string) 返回字符串的大写形式  <br><span class="hljs-keyword">select</span> ucase(ename) <span class="hljs-keyword">from</span> emp;  <br># LCASE (string) 返回字符串的小写形式  <br><span class="hljs-keyword">select</span> lcase(ename) <span class="hljs-keyword">from</span> emp;  <br># <span class="hljs-keyword">LEFT</span> (string, length) 返回字符串左边的 length 个字符  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">left</span>(ename,<span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> emp;  <br># <span class="hljs-keyword">RIGHT</span> (string, length) 返回字符串右边的 length 个字符  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">right</span>(ename,<span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> emp;  <br># LENGTH (string) 返回字符串的长度  <br><span class="hljs-keyword">select</span> length(ename) <span class="hljs-keyword">from</span> emp;  <br># REPLACE (string, <span class="hljs-keyword">from</span>, <span class="hljs-keyword">to</span>) 将字符串中的 <span class="hljs-keyword">from</span> 替换为 toselect replace(job,<span class="hljs-string">&#x27;MANAGER&#x27;</span>,<span class="hljs-string">&#x27;经理&#x27;</span>) <span class="hljs-keyword">from</span> emp;  <br># STRCMP (string1, string2) 比较两个字符串  <br><span class="hljs-keyword">select</span> strcmp(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">SUBSTRING</span> (string, <span class="hljs-keyword">start</span>, length) 返回字符串的子串  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">substring</span>(ename,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-keyword">from</span> emp;  <br># <span class="hljs-built_in">TRIM</span> (string) 删除字符串两端的空格  <br># LTRIM (string) 删除字符串左端的空格  <br># RTRIM (string) 删除字符串右端的空格  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(ename) <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h2 id="24-25数学相关函数"><a href="#24-25数学相关函数" class="headerlink" title="24.25数学相关函数"></a>24.25数学相关函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-built_in">ABS</span>(num) 绝对值  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">abs</span>(<span class="hljs-number">-10</span>) <span class="hljs-keyword">from</span> dual;  <br># BIN(num) 二进制  <br><span class="hljs-keyword">select</span> bin(<span class="hljs-number">10</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">CEIL</span>(num) 向上取整  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">10.1</span>) <span class="hljs-keyword">from</span> dual;  <br># CONV(num, from_base, to_base) 进制转换  <br><span class="hljs-keyword">select</span> conv(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> dual; # <span class="hljs-number">10</span>进制的<span class="hljs-number">9</span>转换为<span class="hljs-number">2</span>进制  <br># <span class="hljs-built_in">FLOOR</span>(num) 向下取整  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">10.9</span>) <span class="hljs-keyword">from</span> dual;  <br># FORMAT(num, <span class="hljs-type">decimal</span>) 格式化  <br><span class="hljs-keyword">select</span> format(<span class="hljs-number">1234567.892323</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> dual;  <br># HEX(num) 十六进制  <br><span class="hljs-keyword">select</span> hex(<span class="hljs-number">10</span>) <span class="hljs-keyword">from</span> dual;  <br># LEAST(num1, num2, ...) 返回最小值  <br><span class="hljs-keyword">select</span> least(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">MOD</span>(num1, num2) 取模  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">from</span> dual;  <br># POW(num1, num2) 幂运算  <br><span class="hljs-keyword">select</span> pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">from</span> dual;  <br># ROUND(num, <span class="hljs-type">decimal</span>) 四舍五入  <br><span class="hljs-keyword">select</span> round(<span class="hljs-number">10.123456</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> dual;  <br># RAND() 随机数  <br><span class="hljs-keyword">select</span> rand() <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h2 id="24-26时间日期相关函数"><a href="#24-26时间日期相关函数" class="headerlink" title="24.26时间日期相关函数"></a>24.26时间日期相关函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-built_in">CURRENT_DATE</span>() 当前日期 <span class="hljs-number">2024</span><span class="hljs-number">-04</span><span class="hljs-number">-16</span><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_date</span>() <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">CURRENT_TIME</span>() 当前时间 <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_time</span>() <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-built_in">CURRENT_TIMESTAMP</span>() 当前时间 <span class="hljs-number">2024</span><span class="hljs-number">-04</span><span class="hljs-number">-16</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_timestamp</span>() <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-type">DATE</span>(datetime) 返回日期部分  <br><span class="hljs-keyword">select</span> <span class="hljs-type">date</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-type">TIME</span>(datetime) 返回时间部分  <br><span class="hljs-keyword">select</span> <span class="hljs-type">time</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># DATE_ADD(<span class="hljs-type">date</span>, <span class="hljs-type">INTERVAL</span> expr type) 日期加法  <br><span class="hljs-keyword">select</span> date_add(<span class="hljs-string">&#x27;2024-04-16&#x27;</span>, <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">month</span> ) <span class="hljs-keyword">from</span> dual;  <br># DATE_SUB(<span class="hljs-type">date</span>, <span class="hljs-type">INTERVAL</span> expr type) 日期减法  <br><span class="hljs-keyword">select</span> date_sub(<span class="hljs-string">&#x27;2024-04-16&#x27;</span>, <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">year</span> ) <span class="hljs-keyword">from</span> dual;  <br># DATEDIFF(date1, date2) 日期差  <br><span class="hljs-keyword">select</span> datediff(<span class="hljs-string">&#x27;2024-04-16&#x27;</span>, <span class="hljs-string">&#x27;2024-04-15&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># TIMEDIFF(time1, time2) 时间差  <br><span class="hljs-keyword">select</span> timediff(<span class="hljs-string">&#x27;16:00:00&#x27;</span>, <span class="hljs-string">&#x27;15:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># NOW() 当前日期时间 <span class="hljs-number">2024</span><span class="hljs-number">-04</span><span class="hljs-number">-16</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-keyword">select</span> now() <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-keyword">YEAR</span><span class="hljs-operator">|</span><span class="hljs-keyword">MONTH</span><span class="hljs-operator">|</span><span class="hljs-keyword">DAY</span><span class="hljs-operator">|</span><span class="hljs-keyword">HOUR</span><span class="hljs-operator">|</span><span class="hljs-keyword">MINUTE</span><span class="hljs-operator">|</span><span class="hljs-keyword">SECOND</span>(datetime) 提取日期时间的年月日时分秒  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">month</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">day</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">hour</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">minute</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">second</span>(<span class="hljs-string">&#x27;2024-04-16 16:00:00&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># unix_timestamp(datetime) 返回时间戳  <br><span class="hljs-keyword">select</span> unix_timestamp() <span class="hljs-keyword">from</span> dual; # 返回<span class="hljs-number">1970</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>到当前时间的秒数  <br># FROM_UNIXTIME(unix_timestamp) 时间戳转日期时间  <br><span class="hljs-keyword">select</span> from_unixtime(<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> dual; # <span class="hljs-number">1970</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h2 id="24-27加密和系统函数"><a href="#24-27加密和系统函数" class="headerlink" title="24.27加密和系统函数"></a>24.27加密和系统函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">USER</span>() 查询用户，查看可以登录mysql的用户及IP  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">USER</span>() <span class="hljs-keyword">from</span> dual;  <br># DATABASE() 查询当前数据库  <br><span class="hljs-keyword">select</span> DATABASE() <span class="hljs-keyword">from</span> dual;  <br># MD5() 加密  <br><span class="hljs-keyword">select</span> MD5(<span class="hljs-string">&#x27;123456&#x27;</span>) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h2 id="24-28流程控制函数"><a href="#24-28流程控制函数" class="headerlink" title="24.28流程控制函数"></a>24.28流程控制函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"># IF(expr1, expr2, expr3) 如果expr1为真，则返回expr2，否则返回expr3  <br><span class="hljs-keyword">select</span> if(<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;true&#x27;</span>, <span class="hljs-string">&#x27;false&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># IFNULL(expr1, expr2) 如果expr1为<span class="hljs-keyword">NULL</span>，则返回expr2，否则返回expr1  <br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;null&#x27;</span>) <span class="hljs-keyword">from</span> dual;  <br># <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> expr1 <span class="hljs-keyword">THEN</span> expr2 <span class="hljs-keyword">WHEN</span> expr3 <span class="hljs-keyword">THEN</span> expr4 <span class="hljs-keyword">ELSE</span> expr5 <span class="hljs-keyword">END</span>  <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">case</span>  <br>    <span class="hljs-keyword">when</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;jack&#x27;</span>  <br>    <span class="hljs-keyword">when</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;rose&#x27;</span>  <br>    <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;lily&#x27;</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h2 id="24-29mysql-表查询–加强"><a href="#24-29mysql-表查询–加强" class="headerlink" title="24.29mysql 表查询–加强"></a>24.29mysql 表查询–加强</h2><ol><li>like操作符<ol><li>%表示0到多个字符</li><li>_表示单个字符</li></ol></li></ol><h3 id="24-29-2-分页查询"><a href="#24-29-2-分页查询" class="headerlink" title="24.29.2 分页查询"></a>24.29.2 分页查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">select</span> ... limit <span class="hljs-keyword">start</span>, <span class="hljs-keyword">rows</span>  <br># 表示从第<span class="hljs-keyword">start</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>行开始，取<span class="hljs-keyword">rows</span>行数据  <br># <span class="hljs-keyword">start</span>从<span class="hljs-number">0</span>开始  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> empno  <br>    limit <span class="hljs-number">0</span>, <span class="hljs-number">3</span>;  <br># <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <br>#     <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> empno  <br>#     limit 每页显示的条数 <span class="hljs-operator">*</span> (当前页码 <span class="hljs-operator">-</span> <span class="hljs-number">1</span>), 每页显示的条数;  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> empno  <br>    limit <span class="hljs-number">3</span>, <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="24-29-3-使用分组函数和分组子句"><a href="#24-29-3-使用分组函数和分组子句" class="headerlink" title="24.29.3 使用分组函数和分组子句"></a>24.29.3 使用分组函数和分组子句</h3><ol><li>select执行顺序<ol><li>group by</li><li>having</li><li>order by</li><li>limit</li></ol></li></ol><h2 id="24-30mysql-多表查询"><a href="#24-30mysql-多表查询" class="headerlink" title="24.30mysql 多表查询"></a>24.30mysql 多表查询</h2><h3 id="24-30-4-自连接"><a href="#24-30-4-自连接" class="headerlink" title="24.30.4 自连接"></a>24.30.4 自连接</h3><ol><li>自连接是在同一张表的连接查询<ol><li>将同一张表看做两张</li><li>需要给表取别名</li><li>列名不明确，可以指定列的别名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> worker.ename <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;职员名&#x27;</span> , boss.ename <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;上级名&#x27;</span><br><span class="hljs-keyword">FROM</span> emp worker, emp boss<br><span class="hljs-keyword">WHERE</span> worker.mgr <span class="hljs-operator">=</span> boss.empno;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="24-31mysql-表子查询"><a href="#24-31mysql-表子查询" class="headerlink" title="24.31mysql 表子查询"></a>24.31mysql 表子查询</h2><ol><li>子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询</li><li>单行子查询：指只返回一行数据的子查询语句</li><li>多行子查询：返回多行数据的子查询，使用关键字in  all  any<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <br>    <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> (  <br>        <span class="hljs-keyword">select</span> deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SMITH&#x27;</span>  <br>        );<br></code></pre></td></tr></table></figure></li><li>多列子查询：指查询返回多个列数据的子查询语句</li></ol><h2 id="24-32-表复制"><a href="#24-32-表复制" class="headerlink" title="24.32 表复制"></a>24.32 表复制</h2><h3 id="24-32-1-自我复制数据-蠕虫复制"><a href="#24-32-1-自我复制数据-蠕虫复制" class="headerlink" title="24.32.1 自我复制数据(蠕虫复制)"></a>24.32.1 自我复制数据(蠕虫复制)</h3><ol><li>为了对某个sql语句进行效率测试， 需要海量数据时，可以使用此法为表创建海量数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> my_tab01  <br>( id <span class="hljs-type">INT</span>, `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>), sal <span class="hljs-keyword">DOUBLE</span>, job <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>), deptno <span class="hljs-type">INT</span>);  <br>  <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_tab01  <br>(id, `name`, sal, job,deptno)  <br><span class="hljs-keyword">SELECT</span> empno, ename, sal, job, deptno <span class="hljs-keyword">FROM</span> emp;  <br>  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tab01;  <br>  <br># 自我复制  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_tab01  <br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tab01;  <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> my_tab01;  <br>  <br># 如何删除一张表重复记录  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_tab02 <span class="hljs-keyword">like</span> my_tab01;  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_tab02  <br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tab01;  <br># 创建一张临时表，my_tmp，结构和my_tab02一样  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_tmp <span class="hljs-keyword">like</span> my_tab02;  <br># 将my_tab02中的数据导入到my_tmp中  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_tmp  <br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tab02;  <br># 删除my_tab02记录  <br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> my_tab02;  <br># 将my_tmp中的数据导入到my_tab02中  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_tab02  <br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_tmp;  <br># 删除临时表  <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> my_tmp;<br></code></pre></td></tr></table></figure></li></ol><h2 id="24-33-合并查询"><a href="#24-33-合并查询" class="headerlink" title="24.33 合并查询"></a>24.33 合并查询</h2><ol><li>为了合并多个select语句的结果，可以使用集合操作 union、union all<ol><li>union all：获取两个结果集的并集，不会取消重复行</li><li>union：自动去除结果集中的重复行</li></ol></li></ol><h2 id="24-34mysql-表外连接"><a href="#24-34mysql-表外连接" class="headerlink" title="24.34mysql 表外连接"></a>24.34mysql 表外连接</h2><ol><li>左外连接：左侧的表完全显示 left join</li><li>右外连接：右侧的表完全显示  right join<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `name`, stu.id, grade  <br><span class="hljs-keyword">FROM</span> stu, exam  <br><span class="hljs-keyword">WHERE</span> stu.id <span class="hljs-operator">=</span> exam.id;  <br>  <br># 左外连接  <br><span class="hljs-keyword">SELECT</span> `name`, stu.id, grade  <br><span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> exam  <br><span class="hljs-keyword">ON</span> stu.id <span class="hljs-operator">=</span> exam.id;<br></code></pre></td></tr></table></figure></li></ol><h2 id="24-35mysql-约束"><a href="#24-35mysql-约束" class="headerlink" title="24.35mysql 约束"></a>24.35mysql 约束</h2><ol><li>约束用于确保数据库中数据满足特定的商业规则：not null、unique、primary key、foreign key、check<ol><li>primary key：主键，唯一标识数据，该列不能重复<ol><li>不能重复也不能为null</li><li>一张表最多只能有一个主键，但是可以是复合主键 primay key(id, name)</li><li>指定方式<ol><li>字段名 primary key</li><li>表定义最后 primay key(列名)</li></ol></li><li>desc 表名，可以查看primary key的情况</li></ol></li><li>not null：插入数据时，该列必须提供数据</li><li>unique：该列值不能重复<ol><li>一张表可以有多个unique字段</li><li>如果没有指定not null，unique字段可以有多个null</li></ol></li><li>foregin key<ol><li>用于定义主表和从表之间的关系，外键约束定义在从表上，主表必须具有主键约束或者unique约束</li><li>当定义外键约束后，要求外键列数据必须在主表的主键存在或是null</li><li>语法：<code>foregin key(本表字段名) references 主表名(主键名或unique字段名)</code></li><li>表的类型是innodb才支持外键</li><li>外键字段的类型要和主键字段类型一致，长度可以不同</li><li>外键字段的值，必须在主键字段中出现过，或者为null，前提是外键字段允许位null</li><li>一旦建立主外键的关节，数据就不能随意删除了</li></ol></li><li>check<ol><li>强制行数据必须满足的条件</li></ol></li></ol></li></ol><h2 id="24-36-自增长"><a href="#24-36-自增长" class="headerlink" title="24.36 自增长"></a>24.36 自增长</h2><ol><li>语法：<code>字段名 类型 primary key auto_increment</code></li><li>自增长一般配合primary key使用</li><li>自增长也可以单独使用，但是需要配合一个unique</li><li>自增长修饰的字段为整数型</li><li>自增长默认从1 开始，可以通过修改 alter table 表名 auto_increment &#x3D; 新的开始值</li><li>如果添加数据时，给自增长字段指定了值，那就按指定的值为准</li></ol><h2 id="24-37-mysql-索引"><a href="#24-37-mysql-索引" class="headerlink" title="24.37 mysql 索引"></a>24.37 mysql 索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建索引<br><span class="hljs-keyword">create</span> index empno_index <span class="hljs-keyword">on</span> emp(empno) # 在emp表的empno列创建索引<br></code></pre></td></tr></table></figure><ol><li>没有索引为什么慢：全表扫描</li><li>使用索引为什么快：形成一个索引的数据结构</li><li>索引的代价<ol><li>磁盘占用</li><li>对dml(update、delete、insert)语句的效率有影响</li></ol></li><li>索引的类型<ol><li>主键索引，primary key</li><li>唯一索引，unique</li><li>普通索引，index</li><li>全文索引，fulltext，一般开发不使用mysql自带的全文索引，而是全文搜索Solr和ElasticSearch</li></ol></li></ol><h3 id="24-37-4-索引使用"><a href="#24-37-4-索引使用" class="headerlink" title="24.37.4 索引使用"></a>24.37.4 索引使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建索引  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t25(  <br>    id <span class="hljs-type">int</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)  <br>);  <br># 查看是否有索引  <br><span class="hljs-keyword">show</span> indexes <span class="hljs-keyword">from</span> t25;  <br># 添加唯一索引，如果某列的值不会重复，优先考虑<span class="hljs-keyword">unique</span>索引，否则考虑普通索引  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index id_index <span class="hljs-keyword">on</span> t25(id);  <br># 添加普通索引  <br><span class="hljs-keyword">create</span> index name_index <span class="hljs-keyword">on</span> t25(name);  <br># 添加普通索引方式<span class="hljs-number">2</span>  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t25 <span class="hljs-keyword">add</span> index name_index2(name);  <br># 添加主键索引  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t26(  <br>    id <span class="hljs-type">int</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)  <br>);  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t26 <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(id);  <br># 删除索引  <br><span class="hljs-keyword">drop</span> index id_index <span class="hljs-keyword">on</span> t25;  <br># 删除主键索引  <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t26 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;  <br># 修改索引，先删除再添加  <br>  <br># 查看索引  <br><span class="hljs-keyword">show</span> indexes <span class="hljs-keyword">from</span> t25;  <br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> t25;  <br><span class="hljs-keyword">show</span> keys <span class="hljs-keyword">from</span> t25;<br><span class="hljs-keyword">desc</span> t25<br></code></pre></td></tr></table></figure><ol><li>小结：哪些列上适合使用索引<ol><li>较频繁的作为查询条件字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁被查询</li><li>更新非常频繁的字段不适合创建索引</li><li>不会出现在where子句中的字段不该创建索引</li></ol></li></ol><h2 id="24-38-mysql-事务"><a href="#24-38-mysql-事务" class="headerlink" title="24.38 mysql 事务"></a>24.38 mysql 事务</h2><ol><li>事务用于保证数据的一致性，由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败</li><li>当执行事务操作时，mysql会在表上加锁，防止其他用户改表</li><li>mysql数据库控制事务的操作<ol><li>start transaction：开始一个事务</li><li>savepoint：保存点名–设置保存点</li><li>rollback to：保存点名–回退事务</li><li>rollback：回退全部事务</li><li>commit：提交事务，所有的操作生效，不能回退<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建一张表  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1(  <br>    id <span class="hljs-type">int</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)  <br>);  <br># 开始事务  <br><span class="hljs-keyword">start</span> transaction;  <br># 设置保存点  <br><span class="hljs-keyword">savepoint</span> s1;  <br># dml操作  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1;  <br># 保存点  <br><span class="hljs-keyword">savepoint</span> s2;  <br># dml操作  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>);  <br># 回退到s2  <br><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> s2;  <br># 直接回退到事务开始状态  <br><span class="hljs-keyword">rollback</span>;  <br><span class="hljs-keyword">commit</span> ;<br></code></pre></td></tr></table></figure></li></ol></li><li>回退事务<ol><li>保存点是事务中的点，用于取消部分事务，当结束事务时(commit)会自动删除事务所定义的所有保存点</li><li>执行回退事务时，通过指定保存点可以回退到指定的点</li></ol></li><li>提交事务<ol><li>commit会确认事务的变化、结束事务、删除保存点、释放锁、数据生效</li><li>使用commit结束事务后，其他会话将可以查看到事务变化后的新数据</li></ol></li><li>事务细节<ol><li>如果不开始事务，默认情况下，dml操作是自动提交，不能回滚</li><li>如果开始一个事务，没有创建保存点，可以执行rollback，默认回退到事务开始状态</li><li>事务机制需要innodb存储引擎才可以使用</li></ol></li></ol><h2 id="24-39-事务隔离级别"><a href="#24-39-事务隔离级别" class="headerlink" title="24.39 事务隔离级别"></a>24.39 事务隔离级别</h2><ol><li>多个连接开启各自事务操作数据库的操作时，数据库要负责隔离操作，以保证各个连接在获取数据时的准确性</li><li>如果没有隔离，可能会导致：脏读、不可重复读、幻读<ol><li>脏读 dirty read：当一个事务读取到另一个事务尚未提交的改变</li><li>不可重复读 nonrepeatable read：同一个查询在同一个事务中多次进行，由于其他提交事务所作的修改或删除，导致每次返回不同的结果集</li><li>幻读 phantom read：同一查询在同一事务中多次进行，由于其他提交事务所作的插入操作，每次返回不同的结果集</li></ol></li><li>隔离级别<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240417165754.png" alt="image.png|500"></li><li>设置事务隔离级别<ol><li>查看当前会话隔离级别 select @@tx_isolation;</li><li>查看系统当前隔离级别 select @@global.tx_isolation;</li><li>设置当前会话隔离级别 set session transaction isolation level repeatable read;</li><li>设置系统当前隔离级别 set global transaction isolation level repeatable read;</li><li>默认情况下，mysql事务隔离级别是repeatable read，满足大部分项目需求</li><li>全局修改，修改 my.ini配置文件，在最后加上 transaction-isolation &#x3D; ?</li></ol></li></ol><h2 id="24-40-mysql-事务-ACID"><a href="#24-40-mysql-事务-ACID" class="headerlink" title="24.40 mysql 事务 ACID"></a>24.40 mysql 事务 ACID</h2><ol><li>ACID<ol><li>Atomicity：原子性，事务是不可分割的单位，要么全都发生，要么都不发生</li><li>Consistency：一致性，事务必须使数据库从一个一致性状态变换成另一个一致性状态</li><li>Isolation：隔离性</li><li>Durability：持久性，一旦提交，数据改变就是永久的，即使数据库发生故障也不会有影响</li></ol></li></ol><h2 id="24-41-mysql-表类型和存储引擎"><a href="#24-41-mysql-表类型和存储引擎" class="headerlink" title="24.41 mysql 表类型和存储引擎"></a>24.41 mysql 表类型和存储引擎</h2><ol><li>mysql的表类型由存储引擎决定，包括MyISAM、innodb、memory</li><li>mysql数据表主要支持六种类型：csv、memory、archive、mrg_myisam、myisam、innobdb</li><li>这六种又分两类：事务安全型（innobdb），其他都是非事务安全型</li><li><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240417171022.png" alt="image.png|500"></li><li>MyISAM：不支持事务，也不支持外键，访问速度快，对事务完整性没有要求</li><li>InnoDB提供了具有提交、回滚、奔溃恢复能力的事务安全，写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引</li><li>MEMORY使用内存中的内容创建表，每个memory表实际对应一个磁盘文件，访问非常快，默认使用hash索引，但是一旦mysql服务关闭，表中的数据就会丢失，表的结构还在</li><li>存储引擎的选择<ol><li>如果不需要事务，处理的是基本的CRUD操作，那么选择MyISAM</li><li>如果需要支持事务，选择InnoDB</li></ol></li><li>修改存储引擎：alter table table_name engine &#x3D; ‘存储引擎’</li></ol><h2 id="24-42-视图-view"><a href="#24-42-视图-view" class="headerlink" title="24.42 视图(view)"></a>24.42 视图(view)</h2><ol><li>视图是一个虚拟表，内容由查询定义，同真实的表一样，视图包含列，其数据来自对应的真实表（基表）<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建视图  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> emp_view01  <br>    <span class="hljs-keyword">as</span>  <br>    <span class="hljs-keyword">select</span> empno, ename, job, deptno <span class="hljs-keyword">from</span> emp;  <br># 查看视图  <br><span class="hljs-keyword">desc</span> emp_view01;  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp_view01;  <br># 查看创建视图的<span class="hljs-keyword">SQL</span>语句  <br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> emp_view01;  <br># 删除视图  <br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> emp_view01;  <br># 修改视图，会影响到基表  <br><span class="hljs-keyword">update</span> emp_view01 <span class="hljs-keyword">set</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span> <span class="hljs-keyword">where</span> empno <span class="hljs-operator">=</span> <span class="hljs-number">7369</span>;  <br># 视图中可以再使用视图  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> emp_view02  <br>    <span class="hljs-keyword">as</span>  <br>    <span class="hljs-keyword">select</span> empno, ename, job, deptno <span class="hljs-keyword">from</span> emp_view01;<br></code></pre></td></tr></table></figure></li><li>视图最佳实践<ol><li>安全，报名</li><li>性能</li><li>灵活</li></ol></li></ol><h2 id="24-43-Mysql-管理"><a href="#24-43-Mysql-管理" class="headerlink" title="24.43 Mysql 管理"></a>24.43 Mysql 管理</h2><h3 id="24-43-1-Mysql-用户"><a href="#24-43-1-Mysql-用户" class="headerlink" title="24.43.1 Mysql 用户"></a>24.43.1 Mysql 用户</h3><ol><li>mysql中的用户都存储在系统数据库mysql中的user表中<ol><li>host：允许登录的位置，localhost表示该用户只允许本机登录，也可以指定ip地址</li><li>user：用户名</li><li>authentication_string：密码，通过mysql的password()函数加密之后的密码</li></ol></li><li>创建用户<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;用户名&#x27;</span> @ <span class="hljs-string">&#x27;允许登录位置&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span><br></code></pre></td></tr></table></figure></li><li>删除用户<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;用户名&#x27;</span> @ <span class="hljs-string">&#x27;允许登录位置&#x27;</span><br></code></pre></td></tr></table></figure></li><li>用户修改密码<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">修改自己的密码<br><span class="hljs-keyword">set</span> password <span class="hljs-operator">=</span> password(<span class="hljs-string">&#x27;密码&#x27;</span>)<br>修改他人密码<br><span class="hljs-keyword">set</span> password <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;用户名&#x27;</span> @ <span class="hljs-string">&#x27;登录位置&#x27;</span> <span class="hljs-operator">=</span> password(<span class="hljs-string">&#x27;密码&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>给用户授权<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">基本语法<br><span class="hljs-keyword">grant</span> 权限列表 <span class="hljs-keyword">on</span> 库.对象名 <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;用户名&#x27;</span> @ <span class="hljs-string">&#x27;登录位置&#x27;</span> [identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span>]<br>说明<br><span class="hljs-number">1.</span>权限列表，多个权限用逗号分开<br><span class="hljs-number">2.</span><span class="hljs-operator">*</span>.<span class="hljs-operator">*</span>表示所有数据库的所有对象<br><span class="hljs-number">3.</span>库.<span class="hljs-operator">*</span>表示某数据库的所有数据对象<br></code></pre></td></tr></table></figure></li><li>回收用户权限 revoke 权限列表 on 库.对象名 from ‘用户名’ @ ‘登录位置’</li><li>权限生效指令：flush privileges</li></ol><h1 id="25-JDBC和数据库连接池"><a href="#25-JDBC和数据库连接池" class="headerlink" title="25.JDBC和数据库连接池"></a>25.JDBC和数据库连接池</h1><h2 id="25-1-JDBC"><a href="#25-1-JDBC" class="headerlink" title="25.1 JDBC"></a>25.1 JDBC</h2><ol><li>jdbc为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题</li><li>java程序员只需要面向这套接口编程即可</li><li>JDBC API</li></ol><h2 id="25-2-JDBC-快速入门"><a href="#25-2-JDBC-快速入门" class="headerlink" title="25.2 JDBC 快速入门"></a>25.2 JDBC 快速入门</h2><ol><li>JDBC 程序编写步骤<ol><li>注册驱动 - 加载Driver类</li><li>获取连接 - 得到Connection</li><li>执行增删改查 - 发送SQL给mysql执行</li><li>释放资源 - 关闭相关连接</li></ol></li></ol><h2 id="25-3-获取数据库连接-5-种方式"><a href="#25-3-获取数据库连接-5-种方式" class="headerlink" title="25.3 获取数据库连接 5 种方式"></a>25.3 获取数据库连接 5 种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;  <br>    <span class="hljs-comment">// 静态加载，灵活性差  </span><br>    <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>;  <br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);  <br>    properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>);  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> driver.connect(url, properties);  <br>&#125;  <br><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException &#123;  <br>    <span class="hljs-comment">// 反射加载Driver，灵活性高，减少代码耦合  </span><br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <br>    <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver) clazz.newInstance();  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>;  <br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);  <br>    properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>);  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> driver.connect(url, properties);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException &#123;  <br>    <span class="hljs-comment">// DriverManager替换Driver 统一管理，推荐方式  </span><br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <br>    <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver) clazz.newInstance();  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;  <br>    DriverManager.registerDriver(driver);  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password); <span class="hljs-comment">// 也可以使用Properties  </span><br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;  <br>    <span class="hljs-comment">// 使用Class.forName自动完成驱动注册，简化代码  </span><br>    Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect05</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, IOException, ClassNotFoundException &#123;  <br>    <span class="hljs-comment">// 使用配置文件  </span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/main/resources/jdbc.properties&quot;</span>));  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);  <br>    <span class="hljs-comment">// 加载驱动  </span><br>    Class.forName(properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>));  <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/hsp&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-4-ResultSet-结果集"><a href="#25-4-ResultSet-结果集" class="headerlink" title="25.4 ResultSet[结果集]"></a>25.4 ResultSet[结果集]</h2><ol><li>表示数据库结果集的数据表，通常通过执行查询数据库的语句生成</li><li>ResultSet对象保持一个光标指向当前的数据行，最初，光标位于第一行</li><li>next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环遍历结果集</li></ol><h2 id="25-5-Statement"><a href="#25-5-Statement" class="headerlink" title="25.5 Statement"></a>25.5 Statement</h2><ol><li>Statement对象用于执行静态SQL语句，并返回其生成的结果的对象</li><li>在建立连接后，需要对数据库进行访问，执行命令或者sql语句，可以通过<ol><li>statement，存在sql注入</li><li>preparedStatement 预处理</li><li>CallableStatement 存储过程</li></ol></li><li>Statement对象执行sql语句，存在sql注入风险</li><li>sql注入是利用某些系统没有对用户输入的数据进行充分检查，而在用户输入数据中注入非法的sql语句段或命令，恶意攻击数据库</li><li>要防范sql注入，只要用preparedStatement取代就可以了</li></ol><h2 id="25-6-PreparedStatement"><a href="#25-6-PreparedStatement" class="headerlink" title="25.6 PreparedStatement"></a>25.6 PreparedStatement</h2><ol><li>PreparedStatement 执行的sql语句中的参数用 (?) 表示，调用PreparedStatement对象的 setXxx()方法来设置这些参数，有两个参数，第一个参数是要设置的sql语句中的参数的索引（从1开始），第二个是设置的sql语句中的参数的值</li><li>调用 excuteQuery() 返回 ResultSet 对象</li><li>调用 excuteUpdate() 执行更新，包括增删改</li><li>预处理好处<ol><li>不再使用 + 拼接 sql 语句，减少语法错误</li><li>有效解决sql注入问题</li><li>减少了编译次数，效率较高<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//3. 得到 PreparedStatement</span><br><span class="hljs-comment">//3.1 组织 SqL , Sql 语句的 ? 就相当于占位符</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select name , pwd from admin where name =? and pwd = ?&quot;</span>;<br><span class="hljs-comment">//String sql = &quot;insert into admin values(?, ?)&quot;;</span><br><span class="hljs-comment">//String sql = &quot;update admin set pwd = ? where name = ?&quot;;</span><br><span class="hljs-comment">//String sql = &quot;delete from admin where name = ?&quot;;</span><br><span class="hljs-comment">//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><span class="hljs-comment">//3.3 给 ? 赋值</span><br>preparedStatement.setString(<span class="hljs-number">1</span>, admin_name);<br>preparedStatement.setString(<span class="hljs-number">2</span>, admin_pwd);<br><span class="hljs-comment">//4. 执行 select 语句使用 executeQuery</span><br><span class="hljs-comment">//</span><br>如果执行的是 dml(update, insert ,delete) executeUpdate()<br><span class="hljs-comment">//</span><br>这里执行 executeQuery ,不要在写 sql<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery(sql);<br><span class="hljs-keyword">if</span> (resultSet.next()) &#123; <span class="hljs-comment">//如果查询到一条记录，则说明该管理存在</span><br>System.out.println(<span class="hljs-string">&quot;恭喜， 登录成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;对不起，登录失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="25-7-JDBC-的相关-API-小结"><a href="#25-7-JDBC-的相关-API-小结" class="headerlink" title="25.7 JDBC 的相关 API 小结"></a>25.7 JDBC 的相关 API 小结</h2><ol><li>DriverManager 驱动管理类<ol><li>getConnection(url, user, pwd) 获取连接</li></ol></li><li>Connection 接口<ol><li>createStatement </li><li>preparedStatement(sql) 生成预处理对象</li></ol></li><li>Statement 接口<ol><li>excuteUpdate(sql)  dml语句，返回影响的行数</li><li>excuteQuery(sql)  执行查询，返回ResultSet对象</li><li>excute(sql) 执行任意sql，返回布尔值</li></ol></li><li>PreparedStatemnet<ol><li>excuteUpdate(sql)</li><li>excuteQuery()</li><li>excute(sql)</li><li>setXxx(占位符索引，占位符的值)  解决sql注入</li><li>setObject(占位符索引，占位符的值)</li></ol></li><li>ResultSet<ol><li>next() 向下移动一行，如果没有下一行，返回false</li><li>previous() 向上移动一行，如果没有上一行，返回false</li><li>getXxx(列的索引|列名) 返回对应列的值，接收类型是Xxx</li><li>getObject(列的索引|列名) 返回对应列的值，接收类型是Object</li></ol></li></ol><h2 id="25-8-封装-JDBCUtils-【关闭连接-得到连接】"><a href="#25-8-封装-JDBCUtils-【关闭连接-得到连接】" class="headerlink" title="25.8 封装 JDBCUtils 【关闭连接, 得到连接】"></a>25.8 封装 JDBCUtils 【关闭连接, 得到连接】</h2><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1151</span><br></code></pre></td></tr></table></figure><h2 id="25-9-事务"><a href="#25-9-事务" class="headerlink" title="25.9 事务"></a>25.9 事务</h2><ol><li>jdbc中当有一个connection对象创建时，默认情况下是自动提交事务，每次执行一个sql语句时，如果执行成功，会向数据库自动提交，不能回滚</li><li>jdbc为了让多个sql语句作为一个整体执行，需要使用事务</li><li>调用connection的setAutoCommit(false) 可以取消自动提交事务</li><li>在所有的sql语句都成功执行成功后，调用Connection的commit()提交事务</li><li>Connection的rollback()回滚事务</li></ol><h2 id="25-10-批处理"><a href="#25-10-批处理" class="headerlink" title="25.10 批处理"></a>25.10 批处理</h2><ol><li>当需要成批插入或者更新记录时，可以采用批处理</li><li>该操作可以一次性提交给数据批量处理，通常比单独提交处理更有效率</li><li>jdbc的批量处理语句包括以下方法<ol><li>addBatch() 添加需要批量处理的sql语句或参数</li><li>excuteBatch() 执行批量处理语句</li><li>clearBatch() 清空批处理语句</li></ol></li><li>jdbc连接mysql时，如果要批处理操作，需要在url参加参数?rewriteBatchedStatement&#x3D;true</li><li>批处理往往和PreparedStatement一起使用</li></ol><h2 id="25-11数据库连接池"><a href="#25-11数据库连接池" class="headerlink" title="25.11数据库连接池"></a>25.11数据库连接池</h2><ol><li>传统的jdbc数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将Connection加载到内存中，再验证ip地址、用户名、密码。需要数据库连接的时候，就要向数据库要求一个，频繁得进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃</li><li>每一次数据库连接，使用完都要断开，如果程序出现异常无法关闭，将导致数据库内存泄露，最终导致重启数据库</li><li>传统获取连接的方式，不能控制创建的连接数量，如果连接过多，导致内存泄露，mysql崩溃</li><li>解决开发中的数据库连接问题，可以采用数据库连接池技术 connection pool</li><li>基本介绍<ol><li>预先在缓冲池放入一定数量的连接，当需要建立数据库连接时，只需从缓冲池中取出一个，使用完毕后再放回去</li><li>数据库连接池负责分配、管理和释放数据库连接，允许应用程序重复使用一个现有数据库连接，而不是重新建立一个</li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中</li></ol></li><li>数据库连接池分类<ol><li>C3P0 速度相对较慢，稳定性不错</li><li>DBCP 速度相对于C3P0较快但不稳定</li><li>Proxool 有监控连接池状态的功能，稳定性较c3p0差一点</li><li>BoneCP 速度快</li><li>Druid 集DBCP、C3P0、Proxool优点于一身</li></ol></li></ol><h3 id="25-11-4-C3P0-应用实例"><a href="#25-11-4-C3P0-应用实例" class="headerlink" title="25.11.4 C3P0 应用实例"></a>25.11.4 C3P0 应用实例</h3><p>&#x2F;&#x2F;方式 1： 相关参数，在程序中指定 user, url , password 等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 创建一个数据源对象</span><br><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br><span class="hljs-comment">//2. 通过配置文件 mysql.properties 获取相关连接的信息</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\mysql.properties&quot;</span>));<br><span class="hljs-comment">//读取相关的属性值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>....<br><span class="hljs-comment">//给数据源 comboPooledDataSource 设置相关的参数</span><br><span class="hljs-comment">//注意：连接管理是由 comboPooledDataSource 来管理</span><br>comboPooledDataSource.setDriverClass(driver);<br>comboPooledDataSource.setJdbcUrl(url);<br>comboPooledDataSource.setUser(user);<br>comboPooledDataSource.setPassword(password);<br><span class="hljs-comment">//设置初始化连接数</span><br>comboPooledDataSource.setInitialPoolSize(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//最大连接数</span><br>comboPooledDataSource.setMaxPoolSize(<span class="hljs-number">50</span>);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection(); <span class="hljs-comment">//这个方法就是从 DataSource 接口实现的</span><br>connection.close();<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;第二种方式 使用配置文件模板来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 将 c3p0 提供的 c3p0.config.xml 拷贝到 src 目录下</span><br><span class="hljs-comment">//2. 该文件指定了连接数据库和连接池的相关参数</span><br><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>(<span class="hljs-string">&quot;hsp_edu&quot;</span>);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection();<br>connection.close();<br></code></pre></td></tr></table></figure><h3 id="25-11-5-Druid-德鲁伊-应用实例"><a href="#25-11-5-Druid-德鲁伊-应用实例" class="headerlink" title="25.11.5 Druid(德鲁伊)应用实例"></a>25.11.5 Druid(德鲁伊)应用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 加入 Druid jar 包</span><br><span class="hljs-comment">//2. 加入 配置文件 druid.properties , 将该文件拷贝项目的 src 目录</span><br><span class="hljs-comment">//3. 创建 Properties 对象, 读取配置文件</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));<br><span class="hljs-comment">//4. 创建一个指定参数的数据库连接池, Druid 连接池</span><br><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>connection.close();<br></code></pre></td></tr></table></figure><h3 id="25-11-6-将-JDBCUtils-工具类改成-Druid-德鲁伊-实现"><a href="#25-11-6-将-JDBCUtils-工具类改成-Druid-德鲁伊-实现" class="headerlink" title="25.11.6 将 JDBCUtils 工具类改成 Druid(德鲁伊)实现"></a>25.11.6 将 JDBCUtils 工具类改成 Druid(德鲁伊)实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds;<br><span class="hljs-comment">//在静态代码块完成 ds 初始化</span><br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><span class="hljs-keyword">try</span> &#123;<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));<br>ds = DruidDataSourceFactory.createDataSource(properties);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">//编写 getConnection 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-keyword">return</span> ds.getConnection();<br>&#125;<br><span class="hljs-comment">//关闭连接, 老师再次强调： 在数据库连接池技术中，close 不是真的断掉连接</span><br><span class="hljs-comment">//而是把使用的 Connection 对象放回连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ResultSet resultSet, Statement statement, Connection connection)</span> &#123;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (resultSet != <span class="hljs-literal">null</span>) &#123;<br>resultSet.close();<br>&#125;<br><span class="hljs-keyword">if</span> (statement != <span class="hljs-literal">null</span>) &#123;<br>statement.close();<br>&#125;<br><span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>connection.close();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 得到连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//2. 组织一个 sql</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from actor where id &gt;= ?&quot;</span>;<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//3. 创建 PreparedStatement 对象</span><br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br>System.out.println(connection.getClass());<span class="hljs-comment">//运行类型 com.alibaba.druid.pool.DruidPooledConnection</span><br>preparedStatement = connection.prepareStatement(sql);<br>preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//给?号赋值</span><br><span class="hljs-comment">//执行, 得到结果集</span><br>set = preparedStatement.executeQuery();<br><span class="hljs-comment">//遍历该结果集</span><br><span class="hljs-keyword">while</span> (set.next()) &#123;...&#125;<br>&#125;<span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//关闭资源</span><br>JDBCUtilsByDruid.close(set, preparedStatement, connection);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-12-Apache—DBUtils"><a href="#25-12-Apache—DBUtils" class="headerlink" title="25.12 Apache—DBUtils"></a>25.12 Apache—DBUtils</h2><ol><li>问题<ol><li>关闭connection后，resultSet结果集无法继续使用</li><li>resultSet不利于数据管理</li></ol></li><li>commons-dbutils是一个开源JDBC工具类库，是对JDBC的封装，极大简化jdbc编码的工作量</li><li>QueryRunner类：封装了SQL的执行，线程安全，可以实现增删改查批处理</li><li>ResultSetHandler接口：将数据按要求转换成另一种形式<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240418145652.png" alt="image.png"></li><li>返回结果是多行的情况<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用 apache-DBUtils 工具类 + druid 完成对表的 crud 操作</span><br><span class="hljs-comment">//1. 得到 连接 (druid)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-comment">//2. 使用 DBUtils 类和接口 , 先引入 DBUtils 相关的 jar , 加入到本 Project</span><br><span class="hljs-comment">//3. 创建 QueryRunner</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//4. 就可以执行相关的方法，返回 ArrayList 结果集</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select id, name from actor where id &gt;= ?&quot;</span>;<br><span class="hljs-comment">//(1) query 方法就是执行 sql 语句，得到 resultset ---封装到 --&gt; ArrayList 集合中</span><br><span class="hljs-comment">//(2) 返回集合</span><br><span class="hljs-comment">//(3) connection: 连接</span><br><span class="hljs-comment">//(4) sql : 执行的 sql 语句</span><br><span class="hljs-comment">//(5) new BeanListHandler&lt;&gt;(Actor.class): 在将 resultset -&gt; Actor 对象 -&gt; 封装到 ArrayList</span><br><span class="hljs-comment">// 底层使用反射机制 去获取 Actor 类的属性，然后进行封装</span><br><span class="hljs-comment">//(6) 1 就是给 sql 语句中的? 赋值，可以有多个值，因为是可变参数 Object... params</span><br><span class="hljs-comment">//(7) 底层得到的 resultset ,会在 query 关闭, 关闭 PreparedStatment</span><br>List&lt;Actor&gt; list = queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(Actor.class), <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (Actor actor : list) &#123;<br>System.out.print(actor);<br>&#125;<br><span class="hljs-comment">//释放资源</span><br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br></code></pre></td></tr></table></figure></li><li>返回的结果是单行记录(单个对象)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 得到 连接 (druid)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-comment">//3. 创建 QueryRunner</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//4. 就可以执行相关的方法，返回单个对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from actor where id = ?&quot;</span>;<br><span class="hljs-comment">// 因为我们返回的单行记录&lt;---&gt;单个对象 , 使用的 Hander 是 BeanHandler</span><br><span class="hljs-type">Actor</span> <span class="hljs-variable">actor</span> <span class="hljs-operator">=</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanHandler</span>&lt;&gt;(Actor.class), <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 释放资源</span><br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br></code></pre></td></tr></table></figure></li><li>查询结果是单行单列-返回的就是 object<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 得到 连接 (druid)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-comment">//3. 创建 QueryRunner</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//4. 就可以执行相关的方法，返回单行单列 , 返回的就是 Object</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select name from actor where id = ?&quot;</span>;<br><span class="hljs-comment">//老师解读： 因为返回的是一个对象, 使用的 handler 就是 ScalarHandler</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScalarHandler</span>(), <span class="hljs-number">4</span>);<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br></code></pre></td></tr></table></figure></li><li>完成 dml (update, insert ,delete)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 得到 连接 (druid)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-comment">//3. 创建 QueryRunner</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//4. 这里组织 sql 完成 update, insert delete</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update actor set name = ? where id = ?&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into actor values(null, ?, ?, ?, ?)&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delete from actor where id = ?&quot;</span>;<br><span class="hljs-comment">//(1) 执行 dml 操作是 queryRunner.update()</span><br><span class="hljs-comment">//(2) 返回的值是受影响的行数 (affected: 受影响)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">affectedRow</span> <span class="hljs-operator">=</span> queryRunner.update(connection, sql, <span class="hljs-string">&quot;林青霞&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;1966-10-10&quot;</span>, <span class="hljs-string">&quot;116&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">affectedRow</span> <span class="hljs-operator">=</span> queryRunner.update(connection, sql, <span class="hljs-number">1000</span> );<br>System.out.println(affectedRow &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;执行成功&quot;</span> : <span class="hljs-string">&quot;执行没有影响到表&quot;</span>);<br><span class="hljs-comment">// 释放资源</span><br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br></code></pre></td></tr></table></figure></li></ol><h2 id="25-13DAO-和增删改查通用方法-BasicDao"><a href="#25-13DAO-和增删改查通用方法-BasicDao" class="headerlink" title="25.13DAO 和增删改查通用方法-BasicDao"></a>25.13DAO 和增删改查通用方法-BasicDao</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240418151438.png" alt="image.png"></p><ol><li>问题<ol><li>sql语句是固定的，不能通过参数传入，通用性不好，需要改进更方便增删改查</li><li>对于select操作，如果有返回值，返回类型不能固定，需要使用泛型</li><li>将来的表很多，业务需求复杂，不能只靠一个java类完成</li></ol></li><li>基本说明<ol><li>DAO：data access object 数据访问对象</li><li>这样的通用类称为BasicDao，是专门和数据库交互的，即完成对数据库的crud操作<ol><li>BasicDao将各个DAO共同操作部分抽象出来</li></ol></li><li>在BasicDao的基础上，实现一张表对应一个DAO，比如Customer表 - Cunstomer.java(javabean) - CustomerDao.java</li></ol></li></ol><h3 id="25-13-3-BasicDAO-应用实例"><a href="#25-13-3-BasicDAO-应用实例" class="headerlink" title="25.13.3 BasicDAO 应用实例"></a>25.13.3 BasicDAO 应用实例</h3><ol><li>utils 工具类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">如上<br></code></pre></td></tr></table></figure></li><li>domain  &#x2F;&#x2F; javabean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Actor对象<br></code></pre></td></tr></table></figure></li><li>dao  &#x2F;&#x2F; 存放XxxDAO和BasicDAO<ol><li>开发 BasicDAO , 是其他 DAO 的父类, 使用到 apache-dbutils<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicDAO</span>&lt;T&gt; &#123; <span class="hljs-comment">//泛型指定具体类型</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">QueryRunner</span> <span class="hljs-variable">qr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-comment">//开发通用的 dml 方法, 针对任意的表，int表示受影响的行数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String sql, Object... parameters)</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br><span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> qr.update(connection, sql, parameters);<br><span class="hljs-keyword">return</span> update;<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); <span class="hljs-comment">//将编译异常-&gt;运行异常 ,抛出</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br>&#125;<br><br><span class="hljs-comment">//返回多个对象(即查询的结果是多行), 针对任意表</span><br><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title function_">queryMulti</span><span class="hljs-params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br><span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;T&gt;(clazz), parameters);<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); <span class="hljs-comment">//将编译异常-&gt;运行异常 ,抛出</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//查询单行结果 的通用方法</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">querySingle</span><span class="hljs-params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br><span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanHandler</span>&lt;T&gt;(clazz), parameters);<br>&#125;<span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); <span class="hljs-comment">//将编译异常-&gt;运行异常 ,抛出</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查询单行单列的方法,即返回单值的方法</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryScalar</span><span class="hljs-params">(String sql, Object... parameters)</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>connection = JDBCUtilsByDruid.getConnection();<br><span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScalarHandler</span>(), parameters);<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); <span class="hljs-comment">//将编译异常-&gt;运行异常 ,抛出</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>ActorDAO<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActorDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicDAO</span>&lt;Actor&gt; &#123;<br><span class="hljs-comment">//1. 就有 BasicDAO 的方法</span><br><span class="hljs-comment">//2. 根据业务需求，可以编写特有的方法.</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li>test &#x2F;&#x2F; 测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDAO</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testActorDAO</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ActorDAO</span> <span class="hljs-variable">actorDAO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActorDAO</span>();<br><span class="hljs-comment">//1. 查询</span><br>List&lt;Actor&gt; actors = actorDAO.queryMulti(<span class="hljs-string">&quot;select * from actor where id &gt;= ?&quot;</span>, Actor.class, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//2. 查询单行记录</span><br><span class="hljs-type">Actor</span> <span class="hljs-variable">actor</span> <span class="hljs-operator">=</span> actorDAO.querySingle(<span class="hljs-string">&quot;select * from actor where id = ?&quot;</span>, Actor.class, <span class="hljs-number">6</span>);<br><span class="hljs-comment">//3. 查询单行单列</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> actorDAO.queryScalar(<span class="hljs-string">&quot;select name from actor where id = ?&quot;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-comment">//4. dml 操作 insert ,update, delete</span><br><span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> actorDAO.update(<span class="hljs-string">&quot;insert into actor values(null, ?, ?, ?, ?)&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;2000-11-11&quot;</span>, <span class="hljs-string">&quot;999&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="27-正则表达式"><a href="#27-正则表达式" class="headerlink" title="27.正则表达式"></a>27.正则表达式</h1><h2 id="27-6-正则表达式语法"><a href="#27-6-正则表达式语法" class="headerlink" title="27.6 正则表达式语法"></a>27.6 正则表达式语法</h2><ol><li>元字符<ol><li>限定符</li><li>选择匹配符</li><li>分组组合和反向引用符</li><li>特殊字符</li><li>字符匹配符</li><li>定位符<br> <a href="https://www.bilibili.com/video/BV1fh411y7R8/?p=880&spm_id_from=pageDriver&vd_source=bca558bb7d969805c4b5b82a858ad6aa">0879_韩顺平Java_正则底层实现1_哔哩哔哩_bilibili</a><br> 1206</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】计算机网络学习日志</title>
    <link href="/2023/04/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <url>/2023/04/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="9-网络安全"><a href="#9-网络安全" class="headerlink" title="9.网络安全"></a>9.网络安全</h1><h2 id="9-1-说说有哪些安全攻击"><a href="#9-1-说说有哪些安全攻击" class="headerlink" title="9.1 说说有哪些安全攻击"></a>9.1 说说有哪些安全攻击</h2><ul><li>被动攻击  截获<ul><li>消息内容泄露攻击</li><li>流量分析攻击</li></ul></li><li>主动攻击<ul><li>篡改</li><li>恶意程序</li><li>DDOS</li></ul></li></ul><h2 id="9-2-DNS劫持，如何避免"><a href="#9-2-DNS劫持，如何避免" class="headerlink" title="9.2 DNS劫持，如何避免"></a>9.2 DNS劫持，如何避免</h2><h2 id="9-3-什么是CSRF攻击，如何避免"><a href="#9-3-什么是CSRF攻击，如何避免" class="headerlink" title="9.3 什么是CSRF攻击，如何避免"></a>9.3 什么是CSRF攻击，如何避免</h2><ul><li>跨站请求伪造</li><li>Refer字段  校验token  敏感操作多重校验</li></ul><h2 id="9-4-什么是DoS、DDoS、DRDoS攻击，如何避免"><a href="#9-4-什么是DoS、DDoS、DRDoS攻击，如何避免" class="headerlink" title="9.4 什么是DoS、DDoS、DRDoS攻击，如何避免"></a>9.4 什么是DoS、DDoS、DRDoS攻击，如何避免</h2><ul><li>拒绝攻击</li><li>分布式拒绝攻击</li><li>分布式反射拒绝服务</li></ul><h2 id="9-5-什么是XSS攻击，如何避免"><a href="#9-5-什么是XSS攻击，如何避免" class="headerlink" title="9.5 什么是XSS攻击，如何避免"></a>9.5 什么是XSS攻击，如何避免</h2><ul><li>跨站脚本攻击</li></ul><h2 id="9-6-对称加密和非对称加密的区别"><a href="#9-6-对称加密和非对称加密的区别" class="headerlink" title="9.6 对称加密和非对称加密的区别"></a>9.6 对称加密和非对称加密的区别</h2><h2 id="9-7-RSA和AES算法有什么区别"><a href="#9-7-RSA和AES算法有什么区别" class="headerlink" title="9.7 RSA和AES算法有什么区别"></a>9.7 RSA和AES算法有什么区别</h2><ul><li>非对称 公钥加密 私钥解密</li></ul><h1 id="8-IP"><a href="#8-IP" class="headerlink" title="8.IP"></a>8.IP</h1><h2 id="8-1-IP协议的定义和作用"><a href="#8-1-IP协议的定义和作用" class="headerlink" title="8.1 IP协议的定义和作用"></a>8.1 IP协议的定义和作用</h2><ul><li>无连接、不可靠、尽力而为</li><li>寻址和路由</li><li>分段和重组</li></ul><h2 id="8-2-传输层协议和网络层协议的区别"><a href="#8-2-传输层协议和网络层协议的区别" class="headerlink" title="8.2 传输层协议和网络层协议的区别"></a>8.2 传输层协议和网络层协议的区别</h2><ul><li>进程间的逻辑通信</li><li>主机间的逻辑通信</li></ul><h2 id="8-3-IP地址有哪些分类"><a href="#8-3-IP地址有哪些分类" class="headerlink" title="8.3 IP地址有哪些分类"></a>8.3 IP地址有哪些分类</h2><ul><li>网络号+主机号</li><li>1-126</li><li>128-191</li><li>192-223</li><li>224-239</li><li>240-255</li></ul><h2 id="8-4-域名和IP的关系，一个IP可以对应多个域名吗"><a href="#8-4-域名和IP的关系，一个IP可以对应多个域名吗" class="headerlink" title="8.4 域名和IP的关系，一个IP可以对应多个域名吗"></a>8.4 域名和IP的关系，一个IP可以对应多个域名吗</h2><h2 id="8-5-IPV4地址不够如何解决"><a href="#8-5-IPV4地址不够如何解决" class="headerlink" title="8.5 IPV4地址不够如何解决"></a>8.5 IPV4地址不够如何解决</h2><ul><li>DHCP</li><li>CIDR</li><li>NAT</li><li>IPV6</li></ul><h2 id="8-6-ARP协议的工作过程"><a href="#8-6-ARP协议的工作过程" class="headerlink" title="8.6 ARP协议的工作过程"></a>8.6 ARP协议的工作过程</h2><ul><li>地址解析协议 IP MAC</li></ul><h2 id="8-7-为什么既有IP地址，又有MAC地址"><a href="#8-7-为什么既有IP地址，又有MAC地址" class="headerlink" title="8.7 为什么既有IP地址，又有MAC地址"></a>8.7 为什么既有IP地址，又有MAC地址</h2><ul><li>数据链路层、物理层，网卡上的地址</li><li>IP 网络层及以上各层的地址，逻辑地址</li></ul><h2 id="8-8-ICMP协议的功能"><a href="#8-8-ICMP协议的功能" class="headerlink" title="8.8 ICMP协议的功能"></a>8.8 ICMP协议的功能</h2><ul><li>网络控制报文协议</li><li>传输出错报告控制信息</li></ul><h2 id="8-9-说下PING的原理"><a href="#8-9-说下PING的原理" class="headerlink" title="8.9 说下PING的原理"></a>8.9 说下PING的原理</h2><ul><li>测试网络连接量</li></ul><h1 id="7-UDP"><a href="#7-UDP" class="headerlink" title="7.UDP"></a>7.UDP</h1><h2 id="7-1-TCP和UDP的区别"><a href="#7-1-TCP和UDP的区别" class="headerlink" title="7.1 TCP和UDP的区别"></a>7.1 TCP和UDP的区别</h2><ul><li>面向连接   无连接</li></ul><h2 id="7-2-为什么QQ采用UDP协议"><a href="#7-2-为什么QQ采用UDP协议" class="headerlink" title="7.2 为什么QQ采用UDP协议"></a>7.2 为什么QQ采用UDP协议</h2><h2 id="7-3-UDP为什么不可靠"><a href="#7-3-UDP为什么不可靠" class="headerlink" title="7.3 UDP为什么不可靠"></a>7.3 UDP为什么不可靠</h2><h2 id="7-4-DNS为什么使用UDP"><a href="#7-4-DNS为什么使用UDP" class="headerlink" title="7.4 DNS为什么使用UDP"></a>7.4 DNS为什么使用UDP</h2><h1 id="6-TCP"><a href="#6-TCP" class="headerlink" title="6.TCP"></a>6.TCP</h1><h2 id="6-1-TCP的三次握手"><a href="#6-1-TCP的三次握手" class="headerlink" title="6.1 TCP的三次握手"></a>6.1 TCP的三次握手</h2><h2 id="6-2-TCP握手为什么是三次，而不是两次或者四次"><a href="#6-2-TCP握手为什么是三次，而不是两次或者四次" class="headerlink" title="6.2 TCP握手为什么是三次，而不是两次或者四次"></a>6.2 TCP握手为什么是三次，而不是两次或者四次</h2><h2 id="6-3-三次握手中每一次没收到报文会发生什么情况"><a href="#6-3-三次握手中每一次没收到报文会发生什么情况" class="headerlink" title="6.3 三次握手中每一次没收到报文会发生什么情况"></a>6.3 三次握手中每一次没收到报文会发生什么情况</h2><h2 id="6-4-第二次握手传回了ACK，为什么还要传回SYN"><a href="#6-4-第二次握手传回了ACK，为什么还要传回SYN" class="headerlink" title="6.4 第二次握手传回了ACK，为什么还要传回SYN"></a>6.4 第二次握手传回了ACK，为什么还要传回SYN</h2><h2 id="6-5-第三次握手可以携带数据吗"><a href="#6-5-第三次握手可以携带数据吗" class="headerlink" title="6.5 第三次握手可以携带数据吗"></a>6.5 第三次握手可以携带数据吗</h2><h2 id="6-6-说说半连接队列和SYN-Flood攻击的关系"><a href="#6-6-说说半连接队列和SYN-Flood攻击的关系" class="headerlink" title="6.6 说说半连接队列和SYN Flood攻击的关系"></a>6.6 说说半连接队列和SYN Flood攻击的关系</h2><h2 id="6-7-TCP的四次挥手"><a href="#6-7-TCP的四次挥手" class="headerlink" title="6.7 TCP的四次挥手"></a>6.7 TCP的四次挥手</h2><h2 id="6-8-TCP挥手为什么需要四次"><a href="#6-8-TCP挥手为什么需要四次" class="headerlink" title="6.8 TCP挥手为什么需要四次"></a>6.8 TCP挥手为什么需要四次</h2><h2 id="6-9-TCP四次挥手为什么需要等待2MSL才进入CLOSED关闭状态"><a href="#6-9-TCP四次挥手为什么需要等待2MSL才进入CLOSED关闭状态" class="headerlink" title="6.9 TCP四次挥手为什么需要等待2MSL才进入CLOSED关闭状态"></a>6.9 TCP四次挥手为什么需要等待2MSL才进入CLOSED关闭状态</h2><h2 id="6-10-保活计时器有什么用"><a href="#6-10-保活计时器有什么用" class="headerlink" title="6.10 保活计时器有什么用"></a>6.10 保活计时器有什么用</h2><ul><li>2小时  75秒</li></ul><h2 id="6-11-CLOSE-WAIT和TIME-WAIT的状态和意义"><a href="#6-11-CLOSE-WAIT和TIME-WAIT的状态和意义" class="headerlink" title="6.11 CLOSE-WAIT和TIME-WAIT的状态和意义"></a>6.11 CLOSE-WAIT和TIME-WAIT的状态和意义</h2><h2 id="6-12-TIME-WAIT状态过多会导致什么问题，怎么解决"><a href="#6-12-TIME-WAIT状态过多会导致什么问题，怎么解决" class="headerlink" title="6.12 TIME_WAIT状态过多会导致什么问题，怎么解决"></a>6.12 TIME_WAIT状态过多会导致什么问题，怎么解决</h2><ul><li>服务端</li><li>内存  端口号</li><li>SO_REUSEDADDR</li><li>长连接</li></ul><h2 id="6-13-TCP报文首部的格式"><a href="#6-13-TCP报文首部的格式" class="headerlink" title="6.13 TCP报文首部的格式"></a>6.13 TCP报文首部的格式</h2><ul><li>端口号  序号  确认号  首部长度  标志位</li><li>URG   ACK   PST   RST   SYN   FIN </li><li>窗口大小  校验和CRC算法  紧急指针</li></ul><h2 id="6-14-TCP如何保证可靠性"><a href="#6-14-TCP如何保证可靠性" class="headerlink" title="6.14 TCP如何保证可靠性"></a>6.14 TCP如何保证可靠性</h2><ul><li>连接管理 三、四</li><li>校验和</li><li>序列号、确认应答</li><li>流量控制</li><li>最大消息长度 MSS</li><li>超时重传</li><li>拥塞控制、慢启动</li></ul><h2 id="6-15-说说TCP的流量控制"><a href="#6-15-说说TCP的流量控制" class="headerlink" title="6.15 说说TCP的流量控制"></a>6.15 说说TCP的流量控制</h2><ul><li>实际接收能力</li><li>滑动窗口</li></ul><h2 id="6-16-说说滑动窗口"><a href="#6-16-说说滑动窗口" class="headerlink" title="6.16 说说滑动窗口"></a>6.16 说说滑动窗口</h2><ul><li>窗口：缓存空间，无需等待确认应答就可以继续发送数据的最大值</li><li>win字段</li></ul><h2 id="6-17-了解Nagle算法和延迟确认吗"><a href="#6-17-了解Nagle算法和延迟确认吗" class="headerlink" title="6.17 了解Nagle算法和延迟确认吗"></a>6.17 了解Nagle算法和延迟确认吗</h2><ul><li>有效报文占比低</li></ul><h2 id="6-18-说说TCP的拥塞控制"><a href="#6-18-说说TCP的拥塞控制" class="headerlink" title="6.18 说说TCP的拥塞控制"></a>6.18 说说TCP的拥塞控制</h2><ul><li>拥塞窗口 cwnd &#x3D; min(cwnd, rwnd)</li><li>发送窗口 swnd 接收窗口 rwnd</li><li>慢启动、拥塞避免、拥塞发生、快速恢复</li><li>慢启动阈值 ssthresh 65535</li><li>RTO超时重传</li></ul><h2 id="6-19-说说TCP的重传机制"><a href="#6-19-说说TCP的重传机制" class="headerlink" title="6.19 说说TCP的重传机制"></a>6.19 说说TCP的重传机制</h2><ul><li>超时重传</li><li>快速重传</li><li>带选择确认的重传 SACK</li><li>重复 SACK</li><li>RTT  RTO</li></ul><h2 id="6-20-说说TCP的粘包和拆包"><a href="#6-20-说说TCP的粘包和拆包" class="headerlink" title="6.20 说说TCP的粘包和拆包"></a>6.20 说说TCP的粘包和拆包</h2><h1 id="5-HTTP"><a href="#5-HTTP" class="headerlink" title="5.HTTP"></a>5.HTTP</h1><h2 id="5-1-常用状态码和含义"><a href="#5-1-常用状态码和含义" class="headerlink" title="5.1 常用状态码和含义"></a>5.1 常用状态码和含义</h2><ul><li>101    200     301    302    400    401     403    500</li></ul><h3 id="5-1-1-301和302的区别"><a href="#5-1-1-301和302的区别" class="headerlink" title="5.1.1 301和302的区别"></a>5.1.1 301和302的区别</h3><h2 id="5-2-HTTP有哪些请求方式"><a href="#5-2-HTTP有哪些请求方式" class="headerlink" title="5.2 HTTP有哪些请求方式"></a>5.2 HTTP有哪些请求方式</h2><ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>TRANCE</li><li>OPTIONS</li><li>HEAD</li></ul><h3 id="5-2-1-GET和POST的区别"><a href="#5-2-1-GET和POST的区别" class="headerlink" title="5.2.1 GET和POST的区别"></a>5.2.1 GET和POST的区别</h3><ul><li>传参方式</li><li>幂等性、安全性</li><li>缓存</li></ul><h3 id="5-2-2-GET长度的限制"><a href="#5-2-2-GET长度的限制" class="headerlink" title="5.2.2 GET长度的限制"></a>5.2.2 GET长度的限制</h3><h2 id="5-3-HTTP请求的过程与原理"><a href="#5-3-HTTP请求的过程与原理" class="headerlink" title="5.3 HTTP请求的过程与原理"></a>5.3 HTTP请求的过程与原理</h2><h2 id="5-4-HTTP的报文结构"><a href="#5-4-HTTP的报文结构" class="headerlink" title="5.4 HTTP的报文结构"></a>5.4 HTTP的报文结构</h2><ul><li>请求报文<ul><li>请求行<ul><li>方法字段</li><li>URL字段</li><li>HTTP版本字段</li></ul></li><li>首部行<ul><li>请求首部</li><li>响应首部</li><li>通用首部</li><li>实体首部</li></ul></li></ul></li><li>响应报文<ul><li>状态行<ul><li>协议版本字段</li><li>状态码</li><li>相应的状态信息</li></ul></li></ul></li></ul><h2 id="5-5-URL和URI-的区别"><a href="#5-5-URL和URI-的区别" class="headerlink" title="5.5 URL和URI 的区别"></a>5.5 URL和URI 的区别</h2><h2 id="5-6-HTTP-1-0-1-1-2-0的区别"><a href="#5-6-HTTP-1-0-1-1-2-0的区别" class="headerlink" title="5.6 HTTP&#x2F;1.0 1.1 2.0的区别"></a>5.6 HTTP&#x2F;1.0 1.1 2.0的区别</h2><ul><li>1.0<ul><li>Connection: keep-alive</li></ul></li><li>2.0<ul><li>头信息</li><li>数据体</li><li>多路复用</li><li>报头压缩</li><li>服务端推送</li></ul></li></ul><h2 id="5-7-HTTP3"><a href="#5-7-HTTP3" class="headerlink" title="5.7 HTTP3"></a>5.7 HTTP3</h2><ul><li>UDP</li><li>QUIC</li></ul><h2 id="5-8-HTTP如何实现长链接，在什么时候会超时"><a href="#5-8-HTTP如何实现长链接，在什么时候会超时" class="headerlink" title="5.8 HTTP如何实现长链接，在什么时候会超时"></a>5.8 HTTP如何实现长链接，在什么时候会超时</h2><h2 id="5-9-HTTP和HTTPS的区别"><a href="#5-9-HTTP和HTTPS的区别" class="headerlink" title="5.9 HTTP和HTTPS的区别"></a>5.9 HTTP和HTTPS的区别</h2><ul><li>明文传输、加密传输</li><li>三次握手、6次握手</li><li>80&#x2F;443</li><li>CA</li><li>HTTPS &#x3D; HTTP+SSL&#x2F;TLS</li></ul><h2 id="5-10-HTTPS解决了哪些问题"><a href="#5-10-HTTPS解决了哪些问题" class="headerlink" title="5.10 HTTPS解决了哪些问题"></a>5.10 HTTPS解决了哪些问题</h2><ul><li>信息加密</li><li>校验机制</li><li>身份证书</li></ul><h2 id="5-11-HTTPS的工作流程是怎么样的"><a href="#5-11-HTTPS的工作流程是怎么样的" class="headerlink" title="5.11 HTTPS的工作流程是怎么样的"></a>5.11 HTTPS的工作流程是怎么样的</h2><ul><li>数字证书</li><li>公钥加密</li><li>私钥非对称解密</li><li>对称加密</li></ul><h3 id="5-11-1-客户端如何校验证书的合法性"><a href="#5-11-1-客户端如何校验证书的合法性" class="headerlink" title="5.11.1 客户端如何校验证书的合法性"></a>5.11.1 客户端如何校验证书的合法性</h3><h2 id="5-12-如何理解HTTP协议是无状态的"><a href="#5-12-如何理解HTTP协议是无状态的" class="headerlink" title="5.12 如何理解HTTP协议是无状态的"></a>5.12 如何理解HTTP协议是无状态的</h2><h3 id="5-12-1-Seesion和Cookie的区别和联系"><a href="#5-12-1-Seesion和Cookie的区别和联系" class="headerlink" title="5.12.1 Seesion和Cookie的区别和联系"></a>5.12.1 Seesion和Cookie的区别和联系</h3><ul><li>储存位置</li><li>数据类型</li><li>有效期</li><li>隐私策略</li><li>存储大小</li></ul><h1 id="4-端口及对应的服务"><a href="#4-端口及对应的服务" class="headerlink" title="4.端口及对应的服务"></a>4.端口及对应的服务</h1><ul><li>21</li><li>22</li><li>23</li><li>53</li><li>80</li><li>443</li><li>1080</li><li>3306</li></ul><h1 id="3-WebSocket和Socket的区别"><a href="#3-WebSocket和Socket的区别" class="headerlink" title="3.WebSocket和Socket的区别"></a>3.WebSocket和Socket的区别</h1><h1 id="2-从浏览器地址栏输入url到显示主页的过程"><a href="#2-从浏览器地址栏输入url到显示主页的过程" class="headerlink" title="2.从浏览器地址栏输入url到显示主页的过程"></a>2.从浏览器地址栏输入url到显示主页的过程</h1><ul><li>DNS</li><li>TCP三次握手</li><li>HTTP</li><li>TCP四次挥手</li></ul><h2 id="2-2-各个过程都使用了哪些协议"><a href="#2-2-各个过程都使用了哪些协议" class="headerlink" title="2.2 各个过程都使用了哪些协议"></a>2.2 各个过程都使用了哪些协议</h2><ul><li>ARP</li><li>OPSF</li></ul><h2 id="2-3-DNS的解析过程"><a href="#2-3-DNS的解析过程" class="headerlink" title="2.3 DNS的解析过程"></a>2.3 DNS的解析过程</h2><h1 id="1-网络体系结构"><a href="#1-网络体系结构" class="headerlink" title="1.网络体系结构"></a>1.网络体系结构</h1><h2 id="1-1-OSI七层模型"><a href="#1-1-OSI七层模型" class="headerlink" title="1.1 OSI七层模型"></a>1.1 OSI七层模型</h2><h2 id="1-2-TCP-IP-四层模型"><a href="#1-2-TCP-IP-四层模型" class="headerlink" title="1.2 TCP&#x2F;IP 四层模型"></a>1.2 TCP&#x2F;IP 四层模型</h2><h2 id="1-3-每一层对应的网络协议有哪些"><a href="#1-3-每一层对应的网络协议有哪些" class="headerlink" title="1.3 每一层对应的网络协议有哪些"></a>1.3 每一层对应的网络协议有哪些</h2><ul><li>HTTP</li><li>DNS</li><li>FTP</li><li>SMIP</li><li>GIF</li><li>JPEG</li><li>TIFF</li><li>RPC</li><li>SQL</li><li>TCP</li><li>UDP</li><li>IP</li></ul><h2 id="1-4-数据在各层之间如何传输"><a href="#1-4-数据在各层之间如何传输" class="headerlink" title="1.4 数据在各层之间如何传输"></a>1.4 数据在各层之间如何传输</h2>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】扩散模型缩减版</title>
    <link href="/2023/01/02/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E7%BC%A9%E5%87%8F%E7%89%88/"/>
    <url>/2023/01/02/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E7%BC%A9%E5%87%8F%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="DPM"><a href="#DPM" class="headerlink" title="DPM"></a>DPM</h1><h2 id="前向-后向"><a href="#前向-后向" class="headerlink" title="前向-后向"></a>前向-后向</h2><p>$x_0$是模型的起点变量，代表真实图像的分布。<br>设定系数$\alpha_{t}$，令$\alpha_t&#x3D;1-\beta_t$。<br>$q(x_t|x_{t-1})&#x3D;\mathcal{N}(\sqrt{\alpha_t}\mathrm{<del>}x_{t-1},(1-\alpha_t)I)$<br>按照线性高斯的特征，也可以看作是在$\sqrt{\alpha_t}x_{t-1}$的基础上加上一个$\mathcal{N}(0,(1-\alpha_t)I)$的随机高斯噪声。<br>$$\begin{aligned}<br>x_{t}&amp; &#x3D;\sqrt{\alpha_t}\left.x_{t-1}+\mathcal{N}(0,(1-\alpha_t)I)\right.  \<br>&amp;&#x3D;\sqrt{\alpha_t}\left.x_{t-1}+\sqrt{1-\alpha_t}\right.\epsilon\quad,\epsilon\sim\mathcal{N}(0,I)<br>\end{aligned}$$<br>将以上公式展开，通过推导我们可以直接得到从$x_0$到$x_t$的变换：<br>$$\begin{aligned}<br>&amp;x_t&#x3D;\sqrt{\bar{\alpha}_t}\left.x_0+\sqrt{1-\bar{\alpha}<em>t}\right.\epsilon\quad,\bar{\alpha}&#x3D;\prod</em>{i&#x3D;1}^t\alpha_i,</del>\epsilon\sim\mathcal{N}(0,I) \<br>&amp;\sim\mathcal{N}(\sqrt{\bar{\alpha}<em>t}\left.x_0,(1-\bar{\alpha}<em>t)I\right)<br>\end{aligned}$$<br>逆向过程是从$x_T$开始，逐步解码成一个有意义的数据，比如图片。<br>逆向过程，联合概率$p(x</em>{0:T})$分解为：$p(x</em>{0:T})&#x3D;p(x_T)\prod_{t&#x3D;T-1}^0p(x_t|x_{t+1})$。<br><span style="background:#d3f8b6">目标是想要用一个神经网络去拟合条件概率分布</span>$p_\theta(x_t|x_{t+1})$。</p><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>通过推导，可以得到：ln$p(x_0)\geq 以下三个部分之和$<br>$\underbrace{\mathbb{E}<em>{q(x_1|x_0)}\left[\ln p_\theta(x_0|x_1)\right]}</em>{}-\underbrace{D_{\mathrm{KL}}\left(q(x_T|x_0)|p(x_T)\right)}<em>{}-\sum</em>{t&#x3D;2}^T\underbrace{\mathbb{E}<em>{q(x_t|x_0)}\left[D</em>{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t))\right]\right]}$<br>第一项没有变化。<br>第二项有变化，但是没有影响。<br>第三项，需要采样的变量只剩下一个了。$q(x_{t-1}|x_t,x_0)$表示解码器的真实分布，$p_\theta(x_{t-1}|x_t)$表示参数化的模型。<br><strong>此时的结果就是我们想要的 ELBO 结果。</strong><br>要极大化 ELBO，需要其中每一项展开成具体的参数化公式。<br><strong>第二项</strong>不包含参数$\theta$，直接忽略。<br><strong>第一项</strong><br>$$\begin{aligned}<br>&amp;\arg\max_\theta\mathbb{E}<em>{q(x_1|x_0)}\left[\ln p_\theta(x_0|x_1)\right] \<br>&amp;\Leftrightarrow\arg\max_\theta\mathbb{E}</em>{q(x_1|x_0)}\left[-\frac12\left|x_0-\hat{x}<em>0(x_1,t&#x3D;1)\right|<em>2^2\right] \<br>&amp;\Leftrightarrow\arg\min_\theta\mathbb{E}</em>{q(x_1|x_0)}\left[\left|x_0-\hat{x}<em>0(x_1,t&#x3D;1)\right|<em>2^2\right]<br>\end{aligned}$$<br><strong>第三项</strong>是一个 KL 散度，两项都是高斯分布。<br>找到这两个高斯分布的均值和方差就可以计算 KL 散度了。<br>先看真实分布：<br>$q(x</em>{t-1}|x_t,x_0)\propto\mathcal{N}(x</em>{t-1};\underbrace{\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}<em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}}</em>{\mu_q(x_t,x_0)},\underbrace{\frac{(1-\alpha_t)(1-\bar{\alpha}</em>{t-1})}{1-\bar{\alpha}<em>t}I)}</em>{\Sigma_q(t)}$<br>$q(x_{t-1}|x_t,x_0)$的均值是关于$x_t、x_0$的函数；方差仅与$\alpha$有关。<br>$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}<em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}$<br>$\Sigma_q(t)&#x3D;\frac{(1-\alpha_t)(1-\bar{\alpha}</em>{t-1})}{1-\bar{\alpha}<em>t}I&#x3D;\sigma_q^2(t)I$<br>对于参数化模型分布$p_\theta(x</em>{t-1}|x_t)$要尽可能接近$q(x_{t-1}|x_t,x_0)$，用$\mu_{\theta}$表示均值，$\Sigma_{\theta}$表示方差。<br>DDPM 中，直接让$\Sigma_\theta&#x3D;\Sigma_q(t)$。<br>极大化 ELBO，等同于极小化$D_{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t)\right)$，又等同于极小化$\left[\left|\mu_\theta-\mu_q\right|<em>2^2\right]$。<br>$\mu_\theta$是模型需要预测的值，输入是$x_t$，所以$\mu_\theta$是$x_t$的一个函数。<br>前面已经推导了$\mu_q$，$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}<em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}$。<br>看出$\mu_q$也是一个关于$x_t$的函数。<br>目标是让$\mu_\theta$和$\mu_q$尽可能接近，那么完全可以人为定义成类似$\mu_q$的计算方式：<br>$\mu_\theta&#x3D;\mu_\theta(x_t,t)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)\hat{x}<em>\theta(x_t,t)}{1-\bar{\alpha}<em>t}$<br>模型不再预测$\mu_\theta$，而是预测输出$\hat{x}<em>\theta(x_t,t)$。<br>简化$\left|\mu_\theta-\mu_q\right|<em>2^2&#x3D;\frac{\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)}{1-\bar{\alpha}<em>t}\left|(\hat{x}<em>\theta(x_t,t)-x_0)\right|<em>2^2$。<br>$$\begin{aligned}<br>&amp;\arg\max_\theta\text{ ELBO} \<br>&amp;\Leftrightarrow\arg\max_\theta\left[\mathbb{E}</em>{q(x_1|x_0)}\left[\ln p_\theta(x_0|x_1)\right]-\sum</em>{t&#x3D;2}^T\mathbb{E}</em>{q(x_t|x_0)}\left[D</em>{\mathrm{KL}}\left(q(x</em>{t-1}|x_t,x_0)|p_\theta(x</em>{t-1}|x_t))\right)\right]\right] \<br>&amp;\Leftrightarrow\arg\min_\theta\left[\mathbb{E}_{q(x_1|x_0)}\left[\left|x_0-\hat{x}<em>0(x_1,t&#x3D;1)\right|<em>2^2\right]\right]+\left[\sum</em>{t&#x3D;2}^T\mathbb{E}</em>{q(x_t|x_0)}\left[\left|(\hat{x}<em>\theta(x_t,t)-x_0)\right|<em>2^2\right]\right] \<br>&amp;\Leftrightarrow\arg\min_\theta\sum</em>{t&#x3D;1}^T\mathbb{E}</em>{q(x_t|x_0)}\left[\left|(\hat{x}_\theta(x_t,t)-x_0)\right|_2^2\right]<br>\end{aligned}$$<br><strong>以上就是最终的目标函数。</strong><br><strong>对于任意</strong>$t\in[1,T]$<strong>，参数化模型输入</strong>$x_t$<strong>和</strong>$t$<strong>，输出</strong>$\hat{x}_\theta(x_t,t)$<strong>。</strong><br><strong>模型的目标是优化</strong>$\hat{x}<em>\theta(x_t,t)$<strong>和真实值</strong>$x_0$<strong>之间的平方误差。</strong><br><strong>公式中</strong>$\mathbb{E}</em>{q(x_t|x_0)}$<strong>与 VAE 一样，随机采样</strong>$x_t$<strong>即可，采样次数记为</strong>$L$<strong>次，经验上</strong>$L&#x3D;1$<strong>就可以了。</strong><br><strong>模型训练阶段前向过程和逆向过程都需要计算。</strong><br><strong>模型推理阶段，不需要前向过程，只需要逆向过程。</strong></p><h2 id="图片生成-采样-过程"><a href="#图片生成-采样-过程" class="headerlink" title="图片生成 (采样) 过程"></a>图片生成 (采样) 过程</h2><p>训练完成的神经网络模型为$\hat{x}<em>\theta(x_t,t)$<strong>，</strong>输入$x_t$和$t$，输出是对$x_0$的预测值。<br>通过模型就可以得到$p(x</em>{t-1}|x_t)$的近似表示：$p(x_{t-1}|x_t)\sim\mathcal{N}(x_{t-1};\mu_q(x_t,x_0),\Sigma_q(t))$。<br>其中，<br>$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}<em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)\hat{x}<em>\theta(x_t,t)}{1-\bar{\alpha}<em>t}$，<br>$\Sigma_q(t)&#x3D;\frac{(1-\alpha_t)(1-\bar{\alpha}</em>{t-1})}{1-\bar{\alpha}<em>t}I&#x3D;\sigma_q^2(t)I$。<br>逆向过程（采样过程）可以简述为：<br>1.设定$T&#x3D;1000$。<br>2.从一个标准高斯分布中采样得到$x_T$。<br>3.利用神经网络模型计算$\hat{x}<em>\theta(x_t,t)$。<br>4.计算$p(x</em>{t-1}|x_t)$的均值和方差。<br>5.从$p(x</em>{t-1}|x_t)$随机采样得到$x</em>{t-1}$。<br>6.重复 3~5 步，直到$t&#x3D;1$。</p><h1 id="DDPM"><a href="#DDPM" class="headerlink" title="DDPM"></a>DDPM</h1><p>DDPM 对 DPM 做的关键改进就是参数化模型预测的内容做了调整：<br>不是预测原始的$x_0$，而是预测每一$t$添加的噪声。</p><p>在 DPM 中有$D_{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t)\right)&#x3D;\frac1{2\sigma_q^2(t)}\left[|\mu_\theta-\mu_q|<em>2^2\right]$，$\mu_q$代表逆过程真实分布$q(x</em>{t-1}|x_t,x_0)$的均值，$\mu_\theta$表示需要学习的近似逆过程分布$p_\theta(x_{t-1}|x_t)$的均值。<br><strong>根据上面由</strong>$x_t$<strong>反推</strong>$x_0$<strong>的式子重新对</strong>$\mu_q$<strong>进行推导：</strong><br>$\mu_q&#x3D;\frac1{\sqrt{\alpha_t}}x_t-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\epsilon$</p><p><strong>按照这个形式人为定义模型的预测输出</strong>$\mu_\theta$<strong>：</strong><br>$\mu_\theta&#x3D;\mu_\theta(x_t,t)&#x3D;\frac1{\sqrt{\alpha_t}}x_t-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}<em>t}\sqrt{\alpha_t}}\hat{\epsilon}<em>\theta(x_t,t)$<br>在此基础上，重新计算$D</em>{\mathrm{KL}}\left(q(x</em>{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t)\right)&#x3D;\frac1{2\sigma_q^2(t)}\frac{(1-\alpha_t)^2}{(1-\bar{\alpha}_t)\alpha_t}\left[\left|\epsilon-\hat{\epsilon}_\theta(x_t,t)\right|_2^2\right]$。</p><p>$\hat{\epsilon}<em>\theta(x_t,t)$表示模型的预测输出。<br>$\mathbb{\epsilon}$表示从$t-1$到$t$过程中，添加到$x</em>{t-1}$的高斯噪声。<br>** 训练过程中，对于每一个时刻**$t$<strong>：</strong><br>**1.从标准高斯分布 **$\mathbb{\epsilon}$<strong>中随机采样一个噪声，不同</strong>$t$<strong>对应的</strong>$\mathbb{\epsilon}$<strong>是不同的。</strong><br><strong>2.代入</strong>$x_t&#x3D;\sqrt{\bar{\alpha}_t}\left.x_0+\sqrt{1-\bar{\alpha}_t}\right.\epsilon$<strong>计算得到</strong>$x_t$<strong>。</strong><br><strong>3.对神经网络模型输入</strong>$x_t$<strong>和</strong>$t$<strong>，模型输出</strong>$\hat{\epsilon}<em>\theta(x_t,t)$<strong>作为预测噪声。</strong><br><strong>4.最小化</strong>$\hat{\epsilon}<em>\theta(x_t,t)$<strong>与</strong>$\mathbb{\epsilon}$<strong>的平方误差。</strong><br><strong>有了</strong>$\hat{\epsilon}<em>\theta(x_t,t)$<strong>就可以求得</strong>$\mu_\theta$<strong>，从而求得</strong>$p_\theta(x</em>{t-1}|x_t)$<strong>。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/webp/35710960/1694614255390-3e4d4fcd-b60d-4019-bb04-222e7367533d.webp#averageHue=%23f3f3f3&clientId=ub7b9eba7-83be-4&from=paste&height=281&id=u4b5ffa74&originHeight=722&originWidth=2620&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4be45c9b-7c84-4ec9-ac26-1851b4d01f6&title=&width=1018"><img src="https://cdn.nlark.com/yuque/0/2023/webp/35710960/1694614264503-da915ac3-6573-4721-994f-01b48b6c8953.webp#averageHue=%23f3f3f3&clientId=ub7b9eba7-83be-4&from=paste&height=356&id=uf4edbeba&originHeight=495&originWidth=1400&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u92d41d6f-aa4b-48f6-a739-124af0e1681&title=&width=1008"><br><strong>其中，</strong>$\beta_t&#x3D;1-\alpha_t$<strong>，</strong>$\sigma</em>{t}$<strong>是逆向过程分布</strong>$q(x</em>{t-1}|x_t,x_0)$<strong>的标准差。</strong></p><h1 id="DDIM"><a href="#DDIM" class="headerlink" title="DDIM"></a>DDIM</h1><p>DDPM 中，生成过程被定义为马尔科夫扩散过程的反向过程，逆向过程的每一步都预测噪声。<br>DDIM 中，重新定义扩散过程和逆向过程。扩散过程不是完全遵循马尔科夫链，采用新的采样技巧，大幅减少采样步骤。代价是牺牲了一定的多样性和质量。</p><h2 id="非马尔科夫前向过程"><a href="#非马尔科夫前向过程" class="headerlink" title="非马尔科夫前向过程"></a>非马尔科夫前向过程</h2><p>$q(x_{t-1}|x_t,x_0)$是条件概率分布，条件变量是$x_t$和$x_0$。<br>训练过程中，<br>$x_0$本身就是已知的。<br>$x_t$是利用线性高斯的特性，直接通过$q(x_t|x_0)$计算，而没有使用$q(x_t|x_{t-1})$，意味着$x_t$可以不依赖$x_{t-1}$。<br>那么$q(x_t|x_0)$是如何得到的，是在联合概率$q(x_{1:t}|x_0)$的基础上边际化（消除变量$x_{1:t-1}$）得到的：<br>$q(x_t|x_0)&#x3D;\int q(x_{1:t}|x_0)dx_{1:t-1}$<br>在 DDPM 中，对联合概率$q(x_{1:t})$的进一步分解是按照马尔科夫链的形式分解的，即：<br>$$\begin{aligned}<br>q(x_t|x_0)&amp; &#x3D;\int q(x_{1:t}|x_0)dx_{1:t-1}  \<br>&amp;&#x3D;\int\prod_{i&#x3D;1}^tq(x_i|x_{i-1})dx_{1:t-1}<br>\end{aligned}$$</p><p><strong>引入一个人为定义的自由参数</strong>$\sigma^2$，表示$q(x_{t-1}|x_t,x_0)$的方差。<br><strong>重新定义</strong>$q(x_{1:T}|x_0)$<strong>的分解方式：</strong><br>$q_\sigma(x_{1:T}|x_0):&#x3D;q_\sigma(x_T|x_0)\prod_{t&#x3D;2}^Tq_\sigma(x_{t-1}|x_t,x_0)$<br>其中$q_\sigma(x_T|x_0)$与 DDPM 维持一致：<br>$q_\sigma(x_T|x_0)\sim\mathcal{N}(\sqrt{\bar{\alpha}<em>T}\left.x_0,(1-\bar{\alpha}<em>T)I\right)$<br>对任意$t&gt;1$，定义$q_\sigma(x</em>{t-1}|x_t,x_0)$分布为：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694666100971-b9a5a9e7-0304-404a-8863-e7d48937afbe.png#averageHue=%23f7f6f6&clientId=u46e69163-a816-4&from=paste&height=157&id=u54bb05a0&originHeight=196&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19610&status=done&style=none&taskId=ud7a95a21-6f36-4c0a-8858-cdb54e22c2a&title=&width=741" alt="image.png|775"><br>看出，$q_\sigma(x</em>{t-1}|x_t,x_0)$仍是逆过程的转换核，$x_{t-1}$同时依赖$x_t$和$x_0$。<br>为什么要这么定义，这和 DDPM 中的形式也不一样，期望项中多了方差DPM<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694666524794-1dbf95be-936a-4ad8-8e6d-00e460c7472f.png#averageHue=%23f9f9f9&clientId=u46e69163-a816-4&from=paste&height=189&id=uc9e4fa1e&originHeight=189&originWidth=938&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27534&status=done&style=none&taskId=uadda1221-85fa-416c-b7b9-95d7c35b570&title=&width=938" alt="image.png|800"><br>DDPM<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694666539854-2a0801ca-d045-4588-8364-dd58477ccf1c.png#averageHue=%23f6f6f6&clientId=u46e69163-a816-4&from=paste&height=77&id=ua96b3c76&originHeight=77&originWidth=336&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5418&status=done&style=none&taskId=u5eba644a-31fb-47b0-9791-436058172c8&title=&width=336" alt="image.png|336"><br>DDIM<br>论文中有推导，附录 B<br>在 DPM 中，模型直接预测$x_0$进而得到了$q_\sigma(x_{t-1}|x_t,x_0)$的近似表示。<br>在 DDPM 中，利用$x_0&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}<em>t}\epsilon_t}{\sqrt{\bar{\alpha}<em>t}},\quad\epsilon_t\sim\mathcal{N}(0,I)$，让$x_t ，\epsilon</em>{t}$替代$x_0$，进而令模型预测$\epsilon_t$。<br>在 DDIM 中，$q_\sigma(x</em>{t-1}|x_t,x_0)$的期望又直接依赖$x_0$。<br><strong>为了能用上 DDPM 的模型（预测噪声</strong>$\hat{\epsilon}_t(x_t,t)$<strong>的模型），</strong>利用$x_0&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}_t}\epsilon_t}{\sqrt{\bar{\alpha}_t}}$得到预测的$\hat{x}<em>0$:<br>$\hat{x}<em>0&#x3D;f_\theta^{(t)}(x_t)&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}<em>t}\hat{\epsilon}<em>t(x_t,t)}{\sqrt{\bar{\alpha}<em>t}}$<br>由此，我们可以利用上已经训练好的 DDPM 模型$\hat{\epsilon}<em>t(x_t,t)$，不需要重新训练一个模型。<br>得到$\hat{x}<em>0$，再利用$q_\sigma(x</em>{t-1}|x_t,x_0)\sim\mathcal{N}\left(\sqrt{\bar{\alpha}</em>{t-1}}\left.x_0+\sqrt{1-\bar{\alpha}</em>{t-1}-\sigma_t^2}\cdot\frac{x_t-\sqrt{\bar{\alpha}<em>t}\left.x_0\right.}{\sqrt{1-\bar{\alpha}<em>t}},{\sigma_t^2I}\right)\right.$得到$q_\sigma(x</em>{t-1}|x_t,x_0)$的近似分布：<br>$$\begin{aligned}<br>p</em>{\theta,\sigma}(x</em>{t-1}|x_t)&amp; \sim\mathcal{N}\left(\sqrt{\bar{\alpha}</em>{t-1}}\left.\hat{x}<em>0+\sqrt{1-\bar{\alpha}</em>{t-1}-\sigma_t^2}\cdot\frac{x_t-\sqrt{\bar{\alpha}<em>t}\left.\hat{x}<em>0\right.}{\sqrt{1-\bar{\alpha}<em>t}},\sigma_t^2I\right)\right.   \<br>&amp;\approx q_\sigma(x</em>{t-1}|x_t,x_0)<br>\end{aligned}$$<br><strong>整理以上整个逆过程：</strong><br><strong>对于</strong>$x_T$<strong>:</strong><br>$p(x_T)&#x3D;\mathcal{N}(0,I)$<br><strong>对于</strong>$p(x</em>{t-1}|x_t)$<strong>：</strong><br>$p(x</em>{t-1}|x_t)&#x3D;\left{\begin{array}{ccc}&amp;\mathcal{N}(\hat{x}<em>0(x_1,t&#x3D;1),\sigma_1^2I<del>)&amp;\mathrm{</del>if~}&amp;t&#x3D;1\&amp;q_\sigma(x</em>{t-1}|x_t,\hat{x}<em>0(x_t,t))&amp;\mathrm{<del>if</del>}&amp;1&lt;t\leq T\end{array}\right.$<br><strong>根据</strong>$p</em>{\theta,\sigma}(x</em>{t-1}|x_t)\sim\mathcal{N}\left(\sqrt{\bar{\alpha}</em>{t-1}}\left.\hat{x}<em>0+\sqrt{1-\bar{\alpha}</em>{t-1}-\sigma_t^2}\cdot\frac{x_t-\sqrt{\bar{\alpha}_t}\left.\hat{x}_0\right.}{\sqrt{1-\bar{\alpha}<em>t}},\sigma_t^2I\right)\right.$<strong>，</strong>$x</em>{t-1}$<strong>具体采样公式：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694670854027-8de1efea-f3e5-4648-b4f6-525080f2bc80.png#averageHue=%23f7f6f6&clientId=u46e69163-a816-4&from=paste&height=224&id=u6ef58cf8&originHeight=278&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40564&status=done&style=none&taskId=u5fd0f062-aace-4dfc-9725-eb4a864e1e3&title=&width=811" alt="image.png|775"></p><h2 id="加速采样"><a href="#加速采样" class="headerlink" title="加速采样"></a>加速采样</h2><p>在 DDPM 中，方差是直接贝叶斯推导出来的：$\sigma^2&#x3D;\frac{(1-\alpha_t)(1-\bar{\alpha}<em>{t-1})}{1-\bar{\alpha}<em>t}$。<br>在 DDIM 中，方差是超参数，通过调整$\sigma^{2}$从而达到不一样的效果。<br>如果将$\sigma^{2}$调整为与 DDPM 一样的形式，那么 DDIM 就退化为 DDPM。<br><strong>DDIM 可以看作是 DDPM 的拓展，DDPM 是 DDIM 的特例。</strong><br>$\sigma^{2}$另一个特例是令$\sigma^{2}&#x3D;0$。<br>直接导致$x</em>{t-1}&#x3D;\sqrt{\bar{\alpha}</em>{t-1}}\underbrace{\left(\frac{x_t-\sqrt{1-\bar{\alpha}<em>t}\hat{\epsilon}<em>t(x_t,t)}{\sqrt{\bar{\alpha}<em>t}}\right)}</em>{\text{predict }x_0}+\underbrace{\sqrt{1-\bar{\alpha}</em>{t-1}-\sigma_t^2}\quad\hat{\epsilon}<em>t(x_t,t)}</em>{\text{direction pointing to }x_t}+\underbrace{\sigma_t\epsilon_t^*}</em>{\text{random noise}}$中的随机噪声$\sigma_t\epsilon_t^*$没了，$x_{t-1}$直接等于$q_\sigma(x_{t-1}|x_t,x_0)$的期望。<br><strong>从随机采样的角度，</strong>$x_{t-1}$不再是从$q_\sigma(x_{t-1}|x_t,x_0)$随机采样，而是直接选择其期望。<br>又由于$q_\sigma(x_{t-1}|x_t,x_0)$是高斯分布，其期望是概率密度的最大点。<br>相当于$x_{t-1}$每次都选取的$q_\sigma(x_{t-1}|x_t,x_0)$的最大值点，即最大概率采样。<br><strong>从数值计算角度，</strong>没了随机项，成了确定性计算，不再具有随机性。<br><strong>加速的原因：</strong><br><strong>当方差不是 0 的时候</strong>，$x_t$到$x_{t-1}$的每一步都是随机性采样。<br>相当于从$x_T$到$x_0$的每一步都不好好走，总在这个方向上加一个随机量，因此会走很多弯路，从而到达$x_0$的步数就变长了。<br><strong>方差为 0 时，</strong>$x_T$<strong>到</strong>$x_0$<strong>的每一步，都是沿着期望方向笔直前进，因此就快多了。</strong></p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>如果$\sigma_t\neq0$，意味着保留了随机性，生成的多样性更好，但是收敛速度会下降。<br>反之，去掉随机项，收敛速度会加快，但是会损失多样性。<br>如果要兼顾速度和多样性，可以设计一个动态自适应的调度算法。<br>开始的一段时间，令$\sigma_t&#x3D;0$加快收敛速度。<br>最后一段时间，令$\sigma_t\neq0$增加多样性。可以线性控制也可以余弦控制。、</p><h1 id="Score-based-DDPM"><a href="#Score-based-DDPM" class="headerlink" title="Score-based DDPM"></a>Score-based DDPM</h1><p><strong>Tweedie 公式。</strong><br>在统计学中，经常需要根据观察样本估计概率分布的未知参数，比如最大似然估计、贝叶斯估计等。<br>Tweedie 公式就可以用来估计高斯分布的均值参数。<br>假设有一个（多元）高斯随机变量$z\sim(\mathcal{N}z;\mu_z,\Sigma_z)$。<br><strong>Tweedie 公式可以写成</strong>：$\mathbb{E}[\mu_z|z]&#x3D;z+\Sigma_z\underbrace{\nabla_z\log p(z)}_{\mathrm{score}}$。<br>$\mathbb{E}[\mu_z|z]$表示有$z$样本条件下，$\mu_z$的期望，直观理解就是用$z$的样本估计$\mu_z$。<br>$\log p(z)$是观测样本的对数似然，$\nabla_z\log p(z)$是观测样本的对数似然的一阶导数，也可以称为梯度、Stein 分数。<br><strong>在前向过程中，</strong>$q(x_t|x_0)&#x3D;\mathcal{N}(x_t;\sqrt{\bar{\alpha}_t}x_0,(1-\bar{\alpha}_t)I)$<strong>。</strong><br>$q(x_t|x_0)$是高斯分布，均值是$\sqrt{\bar{\alpha}<em>t}x_0$。<br>可以利用 Tweedie 公式估计这个均值参数：$\sqrt{\bar{\alpha}<em>t}x_0&#x3D;\mathbb{E}\left[\mu</em>{x_t}|x_t\right]&#x3D;x_t+(1-\bar{\alpha}<em>t)\nabla</em>{x_t}\log p(x_t)$。<br>上面公式移项得到<strong>用分数表达</strong>$x_0$：$x_0&#x3D;\frac{x_t+(1-\bar{\alpha}<em>t)\nabla\log p(x_t)}{\sqrt{\bar{\alpha}<em>t}}$。<br><strong>逆过程中有真实分布</strong>$q(x</em>{t-1}|x_t,x_0)$<strong>的均值</strong>$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}_t}$<strong>。</strong><br><strong>替换</strong>$x_0$<strong>得到：</strong>$\mu_q(x_t,x_0)&#x3D;\frac1{\sqrt{\alpha_t}}x_t+\frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla\log p(x_t)$<strong>。</strong></p><p><strong>按照这个形式重新设定参数化分布</strong>$p_\theta(x_{t-1}|x_t)$<strong>的均值表达式：</strong>$\mu_\theta(x_t,t)&#x3D;\frac1{\sqrt{\alpha_t}}x_t+\frac{1-\alpha_t}{\sqrt{\alpha_t}}s_\theta(x_t,t)$<strong>。</strong><br><strong>现在</strong>$s_\theta(x_t,t)$<strong>是模型学习预测的内容，相当于模型预测的是分数</strong>$\nabla_{x_t}\log p(x_t)$<strong>。</strong><br><strong>重新推导 ELBO 函数中的 KL 散度：</strong><br>$\arg\min_\theta D_{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t)\right)&#x3D;\arg\min_\theta\frac{1}{2\sigma_q^2(t)}\frac{(1-\alpha_t)^2}{\alpha_t}\Big[\left|s_\theta(x_t,t)-\nabla\log p(x_t)\right|_2^2\Big]$</p><p>最后的目标函数依旧是均方误差的形式，和 DPM、DDPM 一致。<br>$\nabla\log p(x_t)$是梯度的真实值，可以直接通过 pytorch 计算得到。<br>$s_\theta(x_t,t)$代表神经网络模型，去学习和预测$\nabla\log p(x_t)$。<br>结合$x_0&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}_t}\left.\epsilon_t\right.}{\sqrt{\bar{\alpha}_t}}$和$x_0&#x3D;\frac{x_t+(1-\bar{\alpha}_t)\nabla\log p(x_t)}{\sqrt{\bar{\alpha}_t}}$可以得到$\nabla\log p(x_t)&#x3D;-\frac1{\sqrt{1-\bar{\alpha}_t}}\epsilon_t$。</p><h1 id="扩散模型的三种形式"><a href="#扩散模型的三种形式" class="headerlink" title="扩散模型的三种形式"></a>扩散模型的三种形式</h1><p><strong>扩散模型有三种形式：</strong><br><strong>1.直接预测初始样本</strong><br><strong>2.预测噪声</strong><br><strong>3.预测分数</strong><br>逆过程中真实后验分布为$q(x_{t-1}|x_t,x_0)$。<br>这是一个高斯分布，$q(x_{t-1}|x_t,x_0)\sim\mathcal{N}(x_{t-1},\mu_q,\Sigma_{q(t)})$，均值记为$\mu_q$，方差记为$\Sigma_{q(t)}$。<br>方差看做已知的常量：$\Sigma_q(t)&#x3D;\frac{(1-\alpha_t)(1-\bar{\alpha}<em>{t-1})}{1-\bar{\alpha}<em>t}I&#x3D;\sigma_q^2(t)I$。<br>参数化模型学习的分布记为$p_\theta(x</em>{t-1}|x_t)$。<br>要令$p_\theta(x</em>{t-1}|x_t)$尽量近似真实分布$q(x_{t-1}|x_t,x_0)$，那么模型学习拟合的均值$\mu_q$可以推导出三种形式，对应三种学习方式。</p><h2 id="学习初始样本"><a href="#学习初始样本" class="headerlink" title="学习初始样本"></a>学习初始样本</h2><p>$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}<em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}$<br>$\mu_\theta&#x3D;\mu_\theta(x_t,t)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\hat{x}_\theta(x_t,t)}{1-\bar{\alpha}_t}$<br>这种方式学习的是初始样本$x_0$，对模型来说难度较大，效果不突出。</p><h2 id="学习噪声"><a href="#学习噪声" class="headerlink" title="学习噪声"></a>学习噪声</h2><p>$\mu_q(x_t,x_0)&#x3D;\frac1{\sqrt{\alpha_t}}x_t-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\epsilon$<br>按照这个形式设定参数化分布的均值$\mu_\theta$：<br>$\mu_\theta&#x3D;\mu_\theta(x_t,t)&#x3D;\frac1{\sqrt{\alpha_t}}x_t-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\hat{\epsilon}_\theta(x_t,t)$<br>这种方式预测的是噪声$\epsilon$，模型效果提升很大。</p><h2 id="学习分数"><a href="#学习分数" class="headerlink" title="学习分数"></a>学习分数</h2><p>$\mu_q(x_t,x_0)&#x3D;\frac1{\sqrt{\alpha_t}}x_t+\frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla\log p(x_t)$<br>按照这个形式设定参数化分布的均值$\mu_\theta$：<br>$\mu_q(x_t,x_0)&#x3D;\frac1{\sqrt{\alpha_t}}x_t+\frac{1-\alpha_t}{\sqrt{\alpha_t}}s_\theta(x_t,t)$<br>这种方式预测的是分数（梯度）$\nabla\log p(x_t)$。<br>相比于学习噪声，可以在逆过程采样图片时采用基于分数的采样算法，基于分数的采样算法种类很多，从而增大了算法灵活性。</p><h1 id="Guided-Diffusion"><a href="#Guided-Diffusion" class="headerlink" title="Guided Diffusion"></a>Guided Diffusion</h1><p>DDPM 和 DDIM 生成图片时，都是输入一个随机高斯噪声，然后逐步生成真实图片。<br>这个过程中的每一步都是随机的，所以生成的图片多样性很好。<br>缺点就是生成图像不可控，无法控制生成过程。<br>直觉上讲，可以在扩散过程中<strong>引入额外的信息来指导扩散模型</strong>。<br>假设这个额外的信息为$y$，可以是文本、图片、标签等。<br><strong>引入</strong>$y$<strong>后，模型就变成了一个以</strong>$y$<strong>为条件的概率分布：</strong>$p(x_{1:T}|y,x_0)$<strong>。</strong><br><strong>接下来需要分析引入</strong>$y$<strong>后对扩散过程和逆向过程有什么影响，需要做什么调整。</strong><br><strong>对于扩散过程，引入</strong>$y$<strong>没有产生任何影响。</strong><br><strong>那么，重点将是</strong>$y$<strong>对逆向过程的影响。</strong><br>原始的无条件扩散模型的逆向过程联合概率分布为：$p(x_{0:T})&#x3D;p(x_T)\prod_{t&#x3D;1}^Tp_\theta(x_{t-1}|x_t)$。<br>添加$y$后，逆向联合概率分布为：$p(x_{0:T}|y)&#x3D;p(x_T)\prod_{t&#x3D;1}^Tp_\theta(x_{t-1}|x_t,y)$。</p><h2 id="Classifier-Guidance"><a href="#Classifier-Guidance" class="headerlink" title="Classifier Guidance"></a>Classifier Guidance</h2><p>扩散模型的降噪过程可以从三种角度理解。<br>其中一种是神经网络去预测$x_t$的对数梯度：$\hat{s}<em>\theta(x_t,t)\approx\nabla</em>{x_t}\log p(x_t)$。<br>引入条件$y$后，由原来的$\nabla_{x_t}\log p(x_t)$变成$\nabla_{x_t}\log p(x_t|y)$。<br>推导出：$\nabla_{x_t}\log p(x_t|y)&#x3D;\underbrace{\nabla_{x_t}\log p(x_t)}<em>\text{unconditional score}+\underbrace{\nabla</em>{x_t}\log p(y|x_t)}_\text{adversarial gradient}$</p><p><strong>第一项</strong>$\nabla_{x_t}\log p(x_t)$<strong>是无条件扩散模型的梯度，称为无条件分数。</strong><br><strong>第二项</strong>$\nabla_{x_t}\log p(y|x_t)$<strong>称为对抗梯度。</strong><br>其中，$p(y|x_t)$代表一个<strong>分类器，</strong>$x_t$<strong>是分类器的输入，</strong>$y$<strong>是分类器预测的标签。</strong><br><strong>综合一下，条件扩散模型的分数就是在非条件扩散模型分数的基础上加了一项分类器的对抗梯度。</strong><br><strong>分类器</strong>$p(y|x_t)$<strong>的输入不是初始图像</strong>$x_0$<strong>，而是加了噪声的</strong>$x_t$<strong>。</strong><br><strong>分类器需要在训练条件扩散模型前，独立训练好。</strong><br>在训练分类器时，需要用扩散模型的前向加噪过程得到$x_t$作为分类器的输入，在实现时：<br>1.预训练好一个噪声分类器$p(y|x_t)$<br>2.在原来非条件扩散模型的每一时刻$t$的采样过程中：<br>1.把模型的预测输出$\hat{s}<em>\theta(x_t,t)$<br>2.同时把$x_t$输入到预训练好的噪声分类器$p(y|x_t)$，并计算出梯度$\nabla</em>{x_t}\log p(y|x_t)$<strong>。</strong><br>3.计算$\hat{s}<em>\theta(x_t,t,y)&#x3D;\hat{s}<em>\theta(x_t,t)+\nabla</em>{x_t}\log p(y|x_t)$。<br>4.继续原来的处理<br>噪声分类器的对抗梯度$\nabla</em>{x_t}\log p(y|x_t)$影响采样降噪过程，让采样向着类别标签$y$的方向前进，进而得到贴近标签$y$的图像。<br><strong>classifier guidance 会让生成图像质量提高，但是会降低其多样性。</strong><br><strong>为了更灵活控制生成内容的方向，增加了一个超参数</strong>$\text{λ}$<strong>，作为权重项。</strong><br>这个权重可以调节类别引导的作用大小：$\nabla_{x_t}\log p(x_t|y)&#x3D;\nabla_{x_t}\log p(x_t)+\lambda\nabla_{x_t}\log p(y|x_t)$。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694711233805-fffa8380-cd45-4d7f-b84d-d9ffe4b0ea55.png#averageHue=%23f6f5f4&clientId=u44e270e5-ffc9-4&from=paste&height=961&id=u0fb10426&originHeight=961&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&size=214862&status=done&style=none&taskId=uc3059a0d-6c9c-4bda-a1d1-da4738bfbf2&title=&width=1611" alt="image.png"><br><strong>classifier guidance 缺点明显：</strong><br>1.需要额外一个分类器模型，极大增加了成本，包括训练成本和采样成本。<br>2.分类器的类别毕竟是有限集，不能涵盖全部情况，对于没有覆盖的标签类别会很不友好。<br>3.分类器和扩散模型是分开训练的，不利于进一步扩展模型的规模。<br>4.输入$x_t$中大多信息与$y$无关。</p><h2 id="Classifier-free-guidance"><a href="#Classifier-free-guidance" class="headerlink" title="Classifier-free guidance"></a>Classifier-free guidance</h2><p>Classifier Guidance 使用显式的分类器引导条件生成。<br>Classifier-free Guidance 的核心是使用隐式分类器，无需直接计算显示分类器及其梯度。<br>在Classifier Guidance $\nabla_{x_t}\log p(x_t|y)&#x3D;\underbrace{\nabla_{x_t}\log p(x_t)}<em>\text{unconditional score}+\underbrace{\nabla</em>{x_t}\log p(y|x_t)}<em>\text{adversarial gradient}$基础上稍微变换一下：<br>$\nabla</em>{x_t}\log p(y|x_t)&#x3D;\nabla_{x_t}\log p(x_t|y)-\nabla_{x_t}\log p(x_t)$。<br><strong>根据贝叶斯公式，分类器的梯度可以用条件生成概率和无条件生成概率表示：</strong><br>$$\begin{aligned}<br>\nabla_{\mathbf{x}<em>{t}}\log p\left(y\mid\mathbf{x}</em>{t}\right)&amp; &#x3D;\nabla_{\mathbf{x}_t}\log p\left(\mathbf{x}<em>t\mid y\right)-\nabla</em>{\mathbf{x}_t}\log p\left(\mathbf{x}_t\right)  \<br>&amp;&#x3D;-\frac1{\sqrt{1-\bar{\alpha}_t}}(\boldsymbol{\epsilon}_\theta\left(\mathbf{x}_t,t,y\right)-\boldsymbol{\epsilon}_\theta\left(\mathbf{x}_t,t\right))<br>\end{aligned}$$<br><strong>在Classifier Guidance：</strong>$\begin{aligned}\hat{\epsilon}_\theta(x_t|y)&#x3D;\epsilon_\theta(x_t|\emptyset)-\sqrt{1-\bar{\alpha}<em>t}\nabla</em>{x_t}\log p_\phi(y|x_t)\end{aligned}$<strong>。</strong><br><strong>代入其中得到classifier-free guidance：</strong>$\hat{\epsilon}_\theta(x_t|y)&#x3D;\epsilon_\theta\left(\mathbf{x_t}\mid\emptyset\right)+\gamma\cdot\left(\epsilon_\theta\left(\mathbf{x_t}\mid\mathbf{y}\right)-\epsilon_\theta\left(\mathbf{x_t}\mid\emptyset\right)\right)$<br>为了在 classifier-free guidance 中使用通用文本 prompts，在训练中有时会将文本替换成空序列$\emptyset$。<br>$\gamma&#x3D;0$时为无条件模型，$\gamma&#x3D;1$时为标准的条件概率模型。<br><strong>看出，新的生成过程不再依赖显式的分类器 classifier。</strong><br><strong>训练时，classifier-free guidance 需要训练两个模型，一个是无条件生成，一个是条件生成。</strong><br><strong>通过以一定概率将条件置空即可在一个模型中表示。</strong><br><strong>推理时，最终结果可以由条件生成和无条件生成的线性外推获得。</strong><br><strong>生成效果可以引导系数可以调节，控制生成样本的逼真性和多样性的平衡。</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/huggingface/diffusers">https://github.com/huggingface/diffusers</a> 开源代码</li><li><a href="https://www.zhangzhenhu.com/aigc/%E6%89%A9%E6%95%A3%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B.html">张振虎 - DPM DDPM</a></li><li><a href="https://www.zhangzhenhu.com/aigc/ddim.html">张振虎 - DDIM</a></li><li><a href="https://www.zhangzhenhu.com/aigc/Guidance.html">张振虎 - 条件控制扩散模型</a></li><li><a href="https://www.zhangzhenhu.com/aigc/Score-Based_Generative_Models.html">张振虎 - 基于分数的生成模型</a></li><li><a href="https://zhuanlan.zhihu.com/p/569700320">知乎 - 扩散模型笔记5 classifier-free guidance</a></li><li><a href="https://sunlin-ai.github.io/2022/06/01/Classifier-Free-Diffusion.html">[论文理解] Classifier-Free Diffusion Guidance</a></li><li><a href="https://zhuanlan.zhihu.com/p/640631667">知乎 - 通俗理解Classifier Guidance 和 Classifier-Free Guidance 的扩散模型</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】扩散模型详细版</title>
    <link href="/2023/01/02/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E8%AF%A6%E7%BB%86%E7%89%88/"/>
    <url>/2023/01/02/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E8%AF%A6%E7%BB%86%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="DPM"><a href="#DPM" class="headerlink" title="DPM"></a>DPM</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694585894967-5cba6b4a-f5f7-4a27-ba8f-4a7c26dd2967.png#averageHue=%23070606&clientId=ub7b9eba7-83be-4&from=paste&id=u728d1934&originHeight=2175&originWidth=5542&originalType=url&ratio=1&rotation=0&showTitle=false&size=1530358&status=done&style=none&taskId=uc81b66f3-0e96-4c1b-b5a6-e517733445d&title=" alt="image.png"></p><h2 id="前向-后向"><a href="#前向-后向" class="headerlink" title="前向-后向"></a>前向-后向</h2><p>$x_0$是模型的起点变量，代表真实图像的分布。<br><strong>前向过程</strong>又称<strong>扩散过程</strong>，是从$x_0$开始按照链式结构逐步演变成一个标准的高斯分布$x_T$。<br>整个网络的联合概率分布可以表示为$p(x_{0:T})$，从左往右链式拆解：$p(x_{0:T})&#x3D;q(x_0)\prod_{t&#x3D;1}^Tq(x_t|x_{t-1})$。<br>从右往左称为<strong>逆过程</strong>又称<strong>生成过程</strong>或<strong>采样过程</strong>，是从标准的高斯噪声$x_T$逐步演变成真实图片$x_0$。同理也可以进行链式分解：$p(x_{0:T})&#x3D;p(x_T)\prod_{t&#x3D;T}^1p(x_{t-1}|x_t)$。</p><h3 id="前向过程-扩散过程"><a href="#前向过程-扩散过程" class="headerlink" title="前向过程 (扩散过程)"></a>前向过程 (扩散过程)</h3><p>前向过程的目的是向$x_{t-1}$加入高斯噪声，让$x_t$渐进趋近于标准正态分布，也就是均值趋近于$0$，方差趋近于$I$，并且$x_t$之和$x_{t-1}$有关。<br>前向过程中，每一个 $x_t$都是高斯变量，每一个步骤的编码器$q(x_t|x_{t-1})$固定为一个线性高斯变换。所谓线性高斯变换是指** <strong>$x_t$<strong>的均值和</strong>$x_{t-1}$<strong>的值是线性关系</strong>。<br>什么是线性高斯变换假设我们有两个高斯变量$x_t$和$x_{t-1}$，我们想要用一个线性高斯变换来描述它们之间的关系。<br>线性高斯变换可以表示为：$x_t &#x3D; A * x_{t-1} + b + N(0, Q)$。<br>其中，$A$是一个矩阵，$b$是一个向量，$N(0, Q)$表示一个均值为$0$，协方差矩阵为$Q$的高斯噪声。<br>$μ_t&#x3D; A * μ_{t-1} + b$<br>$Σ_t&#x3D; A * Σ_{t-1} * A^T + Q$<br>文章中，</strong>定义**$q(x_t|x_{t-1})$<strong>的方差是与</strong>$x_{t-1}$<strong>独立的</strong>，为$\beta_{t}I$，DDPM 中是作为一个超参数存在，当然也可以作为一个可学习的参数。<br>并且$0&lt;\beta_1&lt;\beta_2&lt;\ldots\beta_T&lt;1$，意义是前期方差较小，添加的噪声少，扩散速度慢；后面加入的方差逐渐变大，噪声也越来越多，扩散速度也越来越快。<br>设定系数$\alpha_{t}$，令$\alpha_t&#x3D;1-\beta_t$。<br>$\mu_{x_t}$与 $x_{t-1}$的关系定义为：$\mu_{x_t}&#x3D;\sqrt{\alpha_t}x_{t-1}$。<br>$x_t$的方差定义为：$\Sigma_{x_t}&#x3D;\beta_tI&#x3D;(1-\alpha_t)I$。<br>$q(x_t|x_{t-1})$可以看作是一个以$\sqrt{\alpha_t}x_{t-1}$为均值、以$(1-\alpha_t)I$为方差的高斯分布。<br>$q(x_t|x_{t-1})&#x3D;\mathcal{N}(\sqrt{\alpha_t}\mathrm{~}x_{t-1},(1-\alpha_t)I)$<br>按照线性高斯的特征，也可以看作是在$\sqrt{\alpha_t}x_{t-1}$的基础上加上一个$\mathcal{N}(0,(1-\alpha_t)I)$的随机高斯噪声。<br>$$\begin{aligned}<br>x_{t}&amp; &#x3D;\sqrt{\alpha_t}\left.x_{t-1}+\mathcal{N}(0,(1-\alpha_t)I)\right.  \<br>&amp;&#x3D;\sqrt{\alpha_t}\left.x_{t-1}+\sqrt{1-\alpha_t}\right.\epsilon\quad,\epsilon\sim\mathcal{N}(0,I)<br>\end{aligned}$$<br><strong>这里不是很明白，为什么高斯噪声&#x3D;一个值+高斯噪声。或者说</strong>$\sqrt{\alpha_t}x_{t-1}$<strong>就是一个高斯噪声，那么</strong>$\mu_{x_t}&#x3D;\sqrt{\alpha_t}x_{t-1}$<strong>中，均值肯定是个值吧。所以这里不是很懂。</strong></p><p>将以上公式展开，通过推导我们可以直接得到从$x_0$到$x_t$的变换：<br>$$\begin{aligned}<br>&amp;x_t&#x3D;\sqrt{\bar{\alpha}_t}\left.x_0+\sqrt{1-\bar{\alpha}<em>t}\right.\epsilon\quad,\bar{\alpha}&#x3D;\prod</em>{i&#x3D;1}^t\alpha_i,~\epsilon\sim\mathcal{N}(0,I) \<br>&amp;\sim\mathcal{N}(\sqrt{\bar{\alpha}_t}\left.x_0,(1-\bar{\alpha}<em>t)I\right)<br>\end{aligned}$$<br>由 x_0 到 x_t 的推导过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694595859627-0c5c5d37-13ad-4cfc-ae35-d3675aea3881.png#averageHue=%23f6f6f5&clientId=ub7b9eba7-83be-4&from=paste&height=611&id=u2c7b1e9b&originHeight=611&originWidth=727&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54644&status=done&style=none&taskId=uaab02e79-30e2-4a19-a50b-4d68efd50a5&title=&width=727" alt="image.png"><br>在前向过程中，只需要设置超参数$\alpha</em>{0:T}$的值就可以完成整个过程，没有未知参数，所以就不需要模型学习。</p><h3 id="逆向过程-采样过程、生成过程"><a href="#逆向过程-采样过程、生成过程" class="headerlink" title="逆向过程 (采样过程、生成过程)"></a>逆向过程 (采样过程、生成过程)</h3><p>逆向过程是从$x_T$开始，逐步解码成一个有意义的数据，比如图片。<br>逆向过程，联合概率$p(x_{0:T})$分解为：$p(x_{0:T})&#x3D;p(x_T)\prod_{t&#x3D;T-1}^0p(x_t|x_{t+1})$。<br>$p(x_T)\sim\mathcal{N}(0,I)$，这是明确的，所以如果知道$p(x_t|x_{t+1})$就好办了。但是这里是很难计算的。<br>因此，想到用一个神经网络去拟合条件概率分布$p_\theta(x_t|x_{t+1})$。<br>其中，$\theta$表示模型学习的参数，不带$\theta$的$p(x_t|x_{t+1})$表示解码器的真实分布。<br><strong>接下来问题变成了如何去学习这个神经网络</strong>$p_\theta(x_t|x_{t+1})$<strong>。</strong><br><strong>图片是如何看做成概率分布的？</strong>最后生成的是 $x_0$，是涨图片，但是从$p(x_0|x_1)$这个过程中，是从$x_1$到$x_0$，还是从$p(x_1)$到$p(x_0)$，如果是后者，那么如何再从$p(x_0)$变成$x_0$。<br>我们可以通随机变量$x_0$表示真实的图像，但是不知道真实分布$q(x_0)$是什么。如果知道$q(x_0)$的形式，那么就可以从$q(x_0)$采样生成$x_0$。<br>但是我们有很多$x_0$样本，基于大量的$x_0$样本，我们可以用统计学或者机器学习的算法估计出$q(x_0)$的近似表示，可以是参数化的概率密度函数也可以是高斯混合模型、VAE 等。<br>一旦我们有了$q(x_0)$的近似表示，就可以从这个近似表示中采样生成新的样本，通过生成方法迭代训练使生成样本的分布逐渐接近真实样本的分布</p><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>学习一个概率分布的未知参数常用的算法是极大似然估计，即通过极大化观测数据的对数概率(似然)来实现的。<br>整个网络的联合概率分布是$p(x_{0:T})$，现在只有$x_0$的观测数据，也就是样本，没有$x_{0:T}$的观测样本。<br>因此，极大化的是边缘分布$p(x_0)$，而不是联合分布$p(x_{0:T})$。<br>边缘分布$p(x_0)$可以通过边际化得到：$p(x_0)&#x3D;\int p(x_{0:T})dx_{1:T}$。<br>其中包含积分操作，如果直接$lnp(x_0)$是无法直接极大化的，需要同下界函数(ELBO)进行替代。<br>ELBO 推导过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694598967025-738001df-a711-4302-b84e-7ea681d69600.png#averageHue=%23f4f4f4&clientId=ub7b9eba7-83be-4&from=paste&height=1203&id=ud82d0c13&originHeight=1203&originWidth=1147&originalType=binary&ratio=1&rotation=0&showTitle=false&size=227837&status=done&style=none&taskId=u8958c4f0-ba85-4435-9111-48031256500&title=&width=1147" alt="image.png"><br>通过推导，可以得到：ln$p(x_0)\geq 以下三个部分之和$<br>$\underbrace{\mathbb{E}<em>{q(x_1|x_0)}\left[\ln p_\theta(x_0|x_1)\right]}</em>{\text{reconstruction term}}-\underbrace{\mathbb{E}<em>{q(x</em>{T-1}|x_0)}\left[D_{\text{KL}}\left(q(x_T|x_{T-1})|p(x_T)\right)\right]}<em>{\text{prior matching term}}-\sum</em>{t&#x3D;1}^{T-1}\underbrace{\mathbb{E}<em>{q(x</em>{t-1},x_{t+1}|x_0)}\left[D_{\mathrm{KL}}\left(q(x_t|x_{t-1})||p_\theta(x_t|x_{t+1})\right)\right]}<em>{\mathrm{consistency~term}}$<br>第一部分是重建项，从第一步的隐变量$x_1$重建成初始数据$x_0$。<br>第二部分是先验匹配项，在这项中没有可学习的参数。<br>第三部分是一致项。KL 散度表示在$t$时刻，让解码器$p_\theta(x_t|x</em>{t+1})$得到的$x_t$尽量和编码器$q(x_t|x_{t-1})$生成的内容$x_t$保持一致。<br>其实到这里已经找到目标了，但是第三项中是关于两个变量$(x_{t-1},x_t)$，同时对两个随机变量进行采样会导致更大的方差，使得优化过程不稳定，不容易收敛，因此直接优化这个公式并不是最佳选择。<br>需要进行改进。<br><strong>根据条件独立性原则，</strong>有$q(x_t|x_{t-1})&#x3D;q(x_t|x_{t-1},x_0)$。<br>条件独立性<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694603499919-4adffa3b-2be8-42b9-b106-8002232d78b7.png#averageHue=%23deeaf4&clientId=ub7b9eba7-83be-4&from=paste&height=126&id=u9b0e6816&originHeight=126&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47311&status=done&style=none&taskId=uff3f0566-9397-4bf3-9d4d-a2e991acdb9&title=&width=1008" alt="image.png"><br><strong>根据贝叶斯定理，</strong>有$q(x_t|x_{t-1},x_0)&#x3D;\frac{q(x_{t-1}\mid x_t,x_0)q(x_t\mid x_0)}{q(x_{t-1}\mid x_0)}$。<br><strong>再重新推导 ELBO。</strong><br>ELBO 推导过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694604880785-e7b7138d-e0a8-45a8-bc05-0e8b3bb664ef.png#averageHue=%23f7f6f5&clientId=ub7b9eba7-83be-4&from=paste&height=1229&id=u463521a2&originHeight=1229&originWidth=1136&originalType=binary&ratio=1&rotation=0&showTitle=false&size=220957&status=done&style=none&taskId=u1919b151-e64b-4b8b-871e-02948aa1da6&title=&width=1136" alt="image.png"><br>$\underbrace{\mathbb{E}<em>{q(x_1|x_0)}\left[\ln p_\theta(x_0|x_1)\right]}</em>{}-\underbrace{D_{\mathrm{KL}}\left(q(x_T|x_0)|p(x_T)\right)}<em>{}-\sum</em>{t&#x3D;2}^T\underbrace{\mathbb{E}<em>{q(x_t|x_0)}\left[D</em>{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t))\right]\right]}$<br>第一项没有变化。<br>第二项有变化，但是没有影响。<br>第三项，需要采样的变量只剩下一个了。$q(x_{t-1}|x_t,x_0)$表示解码器的真实分布，$p_\theta(x_{t-1}|x_t)$表示参数化的模型。<br><strong>此时的结果就是我们想要的 ELBO 结果。</strong><br>要极大化 ELBO，需要其中每一项展开成具体的参数化公式。<br><strong>第二项</strong>不包含参数$\theta$，直接忽略。<br><strong>第一项</strong>是一个依赖$x_1$的条件高斯分布，假设均值$\mu_\theta$是关于$x_1$和$t&#x3D;1$的参数化函数，记作$\mu_\theta(x_1,t&#x3D;1)$；假设方差是一个常量，记作$\mathbf{\Sigma}$。<br>那么我们可以用一个参数化的神经网络去拟合均值，即模型输入$x_1$和$t&#x3D;1$，输出$\mu_\theta(x_1,t&#x3D;1)$。<br><strong>根据高斯分布的概率密度函数，</strong>对 ln$p(x_0|x_1)$展开：<br>高斯分布的概率密度函数<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694607984971-8c40843b-676a-49b3-b53b-80fc7b000a72.png#averageHue=%23f9f8f7&clientId=ub7b9eba7-83be-4&from=paste&height=219&id=ud0adf132&originHeight=219&originWidth=1001&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25492&status=done&style=none&taskId=u04222f9e-2d29-4168-811e-fd1e72d67e8&title=&width=1001" alt="image.png"><br>$lnp(x_0|x_1)&#x3D;-\frac12\left|x_0-\mu_\theta(x_1,t&#x3D;1)\right|<em>2^2$。<br>由此可以看出，极大化 ln$p(x_0|x_1)$就等价于极小化模型输出$\mu_\theta(x_1,t&#x3D;1)$和$x_0$的平方误差，实际就是在预测$x_0$的值，用$\hat{x}<em>0(x_1,t&#x3D;1)$表示。<br>$$\begin{aligned}<br>&amp;\arg\max_\theta\mathbb{E}</em>{q(x_1|x_0)}\left[\ln p_\theta(x_0|x_1)\right] \<br>&amp;\Leftrightarrow\arg\max_\theta\mathbb{E}</em>{q(x_1|x_0)}\left[-\frac12\left|x_0-\hat{x}<em>0(x_1,t&#x3D;1)\right|<em>2^2\right] \<br>&amp;\Leftrightarrow\arg\min_\theta\mathbb{E}</em>{q(x_1|x_0)}\left[\left|x_0-\hat{x}<em>0(x_1,t&#x3D;1)\right|<em>2^2\right]<br>\end{aligned}$$<br><strong>第三项</strong>是一个 KL 散度，两项都是高斯分布。<br>找到这两个高斯分布的均值和方差就可以计算 KL 散度了。<br>先看真实分布$q(x</em>{t-1}|x_t,x_0)$，在$q(x</em>{t-1}|x_t,x_0)&#x3D;\frac{q(x_t|x</em>{t-1},x_0)q(x_{t-1}|x_0)}{q(x_t|x_0)}$的基础上继续推导：<br>$q(x_{t-1}|x_t,x_0)\propto\mathcal{N}(x_{t-1};\underbrace{\frac{\sqrt{\alpha_t}(1-\bar{\alpha}<em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}}</em>{\mu_q(x_t,x_0)},\underbrace{\frac{(1-\alpha_t)(1-\bar{\alpha}<em>{t-1})}{1-\bar{\alpha}<em>t}I)}</em>{\Sigma_q(t)}$<br>推导过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694608616332-949f9355-22a0-4fcb-89c0-e17305cf92a0.png#averageHue=%23f3f3f3&clientId=ub7b9eba7-83be-4&from=paste&height=1011&id=u0bd3fe54&originHeight=1011&originWidth=1268&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210418&status=done&style=none&taskId=u165b8b53-3a30-4c2f-8cf7-12d6e993b5f&title=&width=1268" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694608665098-fee26987-b84d-4824-b269-e5a16217246e.png#averageHue=%23f3f3f3&clientId=ub7b9eba7-83be-4&from=paste&height=353&id=u6bf6fd5f&originHeight=353&originWidth=1268&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68338&status=done&style=none&taskId=uf14a724f-b5f4-46b5-b216-1b34b99545e&title=&width=1268" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694608695857-05dc87e3-ad5b-41c3-a4b7-8373d967ced1.png#averageHue=%23efecea&clientId=ub7b9eba7-83be-4&from=paste&height=146&id=u60ce96d2&originHeight=146&originWidth=1068&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63943&status=done&style=none&taskId=u7f28daba-ef1b-4e35-9e71-5d5172a99f2&title=&width=1068" alt="image.png"><br>$q(x</em>{t-1}|x_t,x_0)$的均值是关于$x_t、x_0$的函数；方差仅与$\alpha$有关。<br>$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}<em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}$<br>$\Sigma_q(t)&#x3D;\frac{(1-\alpha_t)(1-\bar{\alpha}</em>{t-1})}{1-\bar{\alpha}<em>t}I&#x3D;\sigma_q^2(t)I$<br>对于参数化模型分布$p_\theta(x</em>{t-1}|x_t)$要尽可能接近$q(x_{t-1}|x_t,x_0)$，用$\mu_{\theta}$表示均值，$\Sigma_{\theta}$表示方差。<br>DDPM 中，直接让$\Sigma_\theta&#x3D;\Sigma_q(t)$。<br>高斯分布 KL 散度计算公式<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694609060066-f3eda6c5-2b06-4ae0-82a8-ebeab9454666.png#averageHue=%23f8f7f6&clientId=ub7b9eba7-83be-4&from=paste&height=102&id=u5c5cc774&originHeight=102&originWidth=1124&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16956&status=done&style=none&taskId=u8d407d57-dc57-43e3-acbd-a26f540de1b&title=&width=1124" alt="image.png"><br><strong>根据高斯分布 KL 计算公式</strong>，$D_{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t)\right)&#x3D;\frac1{2\sigma_q^2(t)}\Big[\left|\mu_\theta-\mu_q\right|<em>2^2\Big]$。<br>计算过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694609164033-0ba11571-1b99-4595-8654-3de6ed86301f.png#averageHue=%23f8f7f6&clientId=ub7b9eba7-83be-4&from=paste&height=432&id=u4da8bd8a&originHeight=432&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60689&status=done&style=none&taskId=ud9c9da13-b038-445e-863c-0aa56347344&title=&width=878" alt="image.png"><br>极大化 ELBO，等同于极小化$D</em>{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t)\right)$，又等同于极小化$\left[\left|\mu_\theta-\mu_q\right|<em>2^2\right]$。<br>$\mu_\theta$是模型需要预测的值，输入是$x_t$，所以$\mu_\theta$是$x_t$的一个函数。<br>前面已经推导了$\mu_q$，$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}<em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}$。<br>看出$\mu_q$也是一个关于$x_t$的函数。<br>目标是让$\mu_\theta$和$\mu_q$尽可能接近，那么完全可以人为定义成类似$\mu_q$的计算方式：<br>$\mu_\theta&#x3D;\mu_\theta(x_t,t)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)\hat{x}<em>\theta(x_t,t)}{1-\bar{\alpha}<em>t}$<br>模型不再预测$\mu_\theta$，而是预测输出$\hat{x}<em>\theta(x_t,t)$。<br>简化$\left|\mu_\theta-\mu_q\right|<em>2^2&#x3D;\frac{\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)}{1-\bar{\alpha}<em>t}\left|(\hat{x}<em>\theta(x_t,t)-x_0)\right|<em>2^2$。<br>简化过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694609776381-52aea482-82bd-4f57-a016-2bf1c3519d7c.png#averageHue=%23f8f8f7&clientId=ub7b9eba7-83be-4&from=paste&height=419&id=u60aaba3f&originHeight=419&originWidth=1097&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47572&status=done&style=none&taskId=u58a84791-ff1c-43e5-a136-7a73c81feb8&title=&width=1097" alt="image.png"><br>对于$2\leq t\leq T$的每一时刻$t$，参数化模型的输入是$x_t、t$，输出是$\hat{x}<em>\theta(x_t,t)$，最小化$\hat{x}<em>\theta(x_t,t)$和$x_0$的平方误差。<br>$$\begin{aligned}<br>&amp;\arg\max_\theta\left[-\sum</em>{t&#x3D;2}^T\mathbb{E}</em>{q(x_t|x_0)}\left[D</em>{\text{KL }(q(x</em>{t-1}|x_t,x_0)|p_\theta(x</em>{t-1}|x_t))]}\right]\right.  \<br>&amp;\Leftrightarrow\arg\min_\theta\left[\sum</em>{t&#x3D;2}^T\frac1{2\sigma_q^2(t)}\frac{\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)}{1-\bar{\alpha}<em>t}\mathbb{E}</em>{q(x_t|x_0)}\left[\left|(\hat{x}<em>\theta(x_t,t)-x_0)\right|<em>2^2\right]\right] \<br>&amp;\Leftrightarrow\arg\min_\theta\left[\sum</em>{t&#x3D;2}^T\mathbb{E}</em>{q(x_t|x_0)}\left[\left|(\hat{x}<em>\theta(x_t,t)-x_0)\right|<em>2^2\right]\right]<br>\end{aligned}$$<br>与第一项$t&#x3D;1$的情况合并：<br>$$\begin{aligned}<br>&amp;\arg\max_\theta\text{ ELBO} \<br>&amp;\Leftrightarrow\arg\max_\theta\left[\mathbb{E}</em>{q(x_1|x_0)}\left[\ln p_\theta(x_0|x_1)\right]-\sum</em>{t&#x3D;2}^T\mathbb{E}</em>{q(x_t|x_0)}\left[D_{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t))\right)\right]\right] \<br>&amp;\Leftrightarrow\arg\min_\theta\left[\mathbb{E}_{q(x_1|x_0)}\left[\left|x_0-\hat{x}<em>0(x_1,t&#x3D;1)\right|<em>2^2\right]\right]+\left[\sum</em>{t&#x3D;2}^T\mathbb{E}</em>{q(x_t|x_0)}\left[\left|(\hat{x}<em>\theta(x_t,t)-x_0)\right|<em>2^2\right]\right] \<br>&amp;\Leftrightarrow\arg\min_\theta\sum</em>{t&#x3D;1}^T\mathbb{E}</em>{q(x_t|x_0)}\left[\left|(\hat{x}_\theta(x_t,t)-x_0)\right|_2^2\right]<br>\end{aligned}$$<br><strong>以上就是最终的目标函数。</strong><br><strong>对于任意</strong>$t\in[1,T]$<strong>，参数化模型输入</strong>$x_t$<strong>和</strong>$t$<strong>，输出</strong>$\hat{x}_\theta(x_t,t)$<strong>。</strong><br><strong>模型的目标是优化</strong>$\hat{x}<em>\theta(x_t,t)$<strong>和真实值</strong>$x_0$<strong>之间的平方误差。</strong><br><strong>公式中</strong>$\mathbb{E}</em>{q(x_t|x_0)}$<strong>与 VAE 一样，随机采样</strong>$x_t$<strong>即可，采样次数记为</strong>$L$<strong>次，经验上</strong>$L&#x3D;1$<strong>就可以了。</strong><br><strong>模型训练阶段前向过程和逆向过程都需要计算。</strong><br><strong>模型推理阶段，不需要前向过程，只需要逆向过程。</strong></p><h2 id="图片生成-采样-过程"><a href="#图片生成-采样-过程" class="headerlink" title="图片生成 (采样) 过程"></a>图片生成 (采样) 过程</h2><p>训练完成的神经网络模型为$\hat{x}<em>\theta(x_t,t)$<strong>，</strong>输入$x_t$和$t$，输出是对$x_0$的预测值。<br>通过模型就可以得到$p(x</em>{t-1}|x_t)$的近似表示：$p(x_{t-1}|x_t)\sim\mathcal{N}(x_{t-1};\mu_q(x_t,x_0),\Sigma_q(t))$。<br>其中，<br>$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}<em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)\hat{x}<em>\theta(x_t,t)}{1-\bar{\alpha}<em>t}$，<br>$\Sigma_q(t)&#x3D;\frac{(1-\alpha_t)(1-\bar{\alpha}</em>{t-1})}{1-\bar{\alpha}<em>t}I&#x3D;\sigma_q^2(t)I$。<br>逆向过程（采样过程）可以简述为：<br>1.设定$T&#x3D;1000$。<br>2.从一个标准高斯分布中采样得到$x_T$。<br>3.利用神经网络模型计算$\hat{x}<em>\theta(x_t,t)$。<br>4.计算$p(x</em>{t-1}|x_t)$的均值和方差。<br>5.从$p(x</em>{t-1}|x_t)$随机采样得到$x</em>{t-1}$。<br>6.重复 3~5 步，直到$t&#x3D;1$。</p><h1 id="DDPM"><a href="#DDPM" class="headerlink" title="DDPM"></a>DDPM</h1><p>DDPM 对 DPM 做的关键改进就是参数化模型预测的内容做了调整：<br>不是预测原始的$x_0$，而是预测每一$t$添加的噪声。<br>前向过程中，$q(x_t|x_0)\sim\mathcal{N}(x_t;\sqrt{\bar{\alpha}_t}x_0,(1-\bar{\alpha}_t)I)$。<br>$x_t$的采样过程为：$x_t&#x3D;\sqrt{\bar{\alpha}<em>t}x_0+\sqrt{1-\bar{\alpha}<em>t}\epsilon_t\quad,\bar{\alpha}<em>t&#x3D;\prod</em>{i&#x3D;1}^t\alpha_i,\epsilon_t\sim\mathcal{N}(0,I)$。<br>上面这个式子表达了从$x_0$计算得到$x_t$的关系，反过来可以用$x_t$得到$x_0$：<br>$x_0&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}<em>t}\epsilon_t}{\sqrt{\bar{\alpha}<em>t}},\quad\epsilon_t\sim\mathcal{N}(0,I)$<br>在 DPM 中有$D</em>{\mathrm{KL}}\left(q(x</em>{t-1}|x_t,x_0)|p_\theta(x</em>{t-1}|x_t)\right)&#x3D;\frac1{2\sigma_q^2(t)}\left[|\mu_\theta-\mu_q|<em>2^2\right]$，$\mu_q$代表逆过程真实分布$q(x</em>{t-1}|x_t,x_0)$的均值，$\mu_\theta$表示需要学习的近似逆过程分布$p_\theta(x</em>{t-1}|x_t)$的均值。<br><strong>根据上面由</strong>$x_t$<strong>反推</strong>$x_0$<strong>的式子重新对</strong>$\mu_q$<strong>进行推导：</strong><br>$\mu_q&#x3D;\frac1{\sqrt{\alpha_t}}x_t-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}<em>t}\sqrt{\alpha_t}}\epsilon$<br>推导过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694613231922-46a6607e-7de9-4c6a-9041-235232f849da.png#averageHue=%23f7f6f6&clientId=ub7b9eba7-83be-4&from=paste&height=733&id=u56ede5ab&originHeight=733&originWidth=802&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89500&status=done&style=none&taskId=u972c3538-7846-46a1-9c59-f3d91765b14&title=&width=802" alt="image.png"><br><strong>按照这个形式人为定义模型的预测输出</strong>$\mu_\theta$<strong>：</strong><br>$\mu_\theta&#x3D;\mu_\theta(x_t,t)&#x3D;\frac1{\sqrt{\alpha_t}}x_t-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}<em>t}\sqrt{\alpha_t}}\hat{\epsilon}<em>\theta(x_t,t)$<br>在此基础上，重新计算$D</em>{\mathrm{KL}}\left(q(x</em>{t-1}|x_t,x_0)|p_\theta(x</em>{t-1}|x_t)\right)&#x3D;\frac1{2\sigma_q^2(t)}\frac{(1-\alpha_t)^2}{(1-\bar{\alpha}_t)\alpha_t}\left[\left|\epsilon-\hat{\epsilon}_\theta(x_t,t)\right|_2^2\right]$。<br>计算过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694613492749-f22213c8-00ff-4849-b122-2707bd531898.png#averageHue=%23f8f7f6&clientId=ub7b9eba7-83be-4&from=paste&height=498&id=u2871cd49&originHeight=498&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62725&status=done&style=none&taskId=u19bef810-41d5-45c4-b5ec-3fb07567eab&title=&width=955" alt="image.png"><br>$\hat{\epsilon}<em>\theta(x_t,t)$表示模型的预测输出。<br>$\mathbb{\epsilon}$表示从$t-1$到$t$过程中，添加到$x</em>{t-1}$的高斯噪声。<br>** 训练过程中，对于每一个时刻**$t$<strong>：</strong><br>**1.从标准高斯分布 **$\mathbb{\epsilon}$<strong>中随机采样一个噪声，不同</strong>$t$<strong>对应的</strong>$\mathbb{\epsilon}$<strong>是不同的。</strong><br><strong>2.代入</strong>$x_t&#x3D;\sqrt{\bar{\alpha}_t}\left.x_0+\sqrt{1-\bar{\alpha}_t}\right.\epsilon$<strong>计算得到</strong>$x_t$<strong>。</strong><br><strong>3.对神经网络模型输入</strong>$x_t$<strong>和</strong>$t$<strong>，模型输出</strong>$\hat{\epsilon}<em>\theta(x_t,t)$<strong>作为预测噪声。</strong><br><strong>4.最小化</strong>$\hat{\epsilon}<em>\theta(x_t,t)$<strong>与</strong>$\mathbb{\epsilon}$<strong>的平方误差。</strong><br><strong>有了</strong>$\hat{\epsilon}<em>\theta(x_t,t)$<strong>就可以求得</strong>$\mu_\theta$<strong>，从而求得</strong>$p_\theta(x</em>{t-1}|x_t)$<strong>。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/webp/35710960/1694614255390-3e4d4fcd-b60d-4019-bb04-222e7367533d.webp#averageHue=%23f3f3f3&clientId=ub7b9eba7-83be-4&from=paste&height=281&id=u4b5ffa74&originHeight=722&originWidth=2620&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4be45c9b-7c84-4ec9-ac26-1851b4d01f6&title=&width=1018"><img src="https://cdn.nlark.com/yuque/0/2023/webp/35710960/1694614264503-da915ac3-6573-4721-994f-01b48b6c8953.webp#averageHue=%23f3f3f3&clientId=ub7b9eba7-83be-4&from=paste&height=356&id=uf4edbeba&originHeight=495&originWidth=1400&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u92d41d6f-aa4b-48f6-a739-124af0e1681&title=&width=1008"><br><strong>其中，</strong>$\beta_t&#x3D;1-\alpha_t$<strong>，</strong>$\sigma</em>{t}$<strong>是逆向过程分布</strong>$q(x</em>{t-1}|x_t,x_0)$<strong>的标准差。</strong></p><h1 id="DDIM"><a href="#DDIM" class="headerlink" title="DDIM"></a>DDIM</h1><p>DDPM 中，生成过程被定义为马尔科夫扩散过程的反向过程，逆向过程的每一步都预测噪声。<br>DDIM 中，重新定义扩散过程和逆向过程。扩散过程不是完全遵循马尔科夫链，采用新的采样技巧，大幅减少采样步骤。代价是牺牲了一定的多样性和质量。</p><h2 id="DDPM-1"><a href="#DDPM-1" class="headerlink" title="DDPM"></a>DDPM</h2><p><strong>根据联合概率的链式法则，</strong>前向扩散过程可以链式分解：$p(x_{0:T})&#x3D;q(x_0)\prod_{t&#x3D;1}^Tq(x_t|x_{t-1})$。<br>但是$q(x_0)$的具体形式未知，我们有$x_0$的观测样本，已知。<br>可以写成已知$x_0$的条件概率分布：$q(x_{1:T}|x_0)&#x3D;q(x_1|x_0)\prod_{t&#x3D;2}^Tq(x_t|x_{t-1})&#x3D;\prod_{t&#x3D;1}^Tq(x_t|x_{t-1})$。<br>前向过程中，$q(x_t|x_{t-1})&#x3D;\mathcal{N}(\sqrt{\alpha_t}x_{t-1},(1-\alpha_t)I)$。<br><strong>展开再合并可以得到直接从</strong>$x_0$<strong>到</strong>$x_t$<strong>的公式：</strong>$x_t&#x3D;\sqrt{\bar{\alpha}<em>t}x_0+\sqrt{1-\bar{\alpha}<em>t}\epsilon_t\quad,\bar{\alpha}<em>t&#x3D;\prod</em>{i&#x3D;1}^t\alpha_i,\epsilon_t\sim\mathcal{N}(0,I)$<strong>。</strong><br>逆过程中，链式分解：$p(x</em>{0:T})&#x3D;p(x_T)\prod</em>{t&#x3D;T}^1p(x_{t-1}|x_t)$。<br>$p(x_T)\sim\mathcal{N}(0,I)$是标准正态分布，$p(x_{t-1}|x_t)$很难计算，关键就是去估计它的一个近似表示。<br><strong>根据最大化似然估计理论，</strong>需要极大化观测数据（样本）的对数似然 ln$p(x)$。<br>整个网络中随机变量有$T$个，可是只有$x_0$可以观测。<br>因此需要$T$变量的联合概率$p(x_{0:T})$进行边际化而得到$x_0$的边缘概率$p(x_0)$：$\ln p(x_0)&#x3D;\ln\int p(x_{0:T})dx_{1:T}$。<br>没有观测样本的变量$x_{1:T}$称为隐变量，这是<strong>典型的含有隐变量模型的估计问题</strong>。<br>隐变量的存在需要边际化消除，导致对数似然函数存在积分操作，无法分解成简单的形式，进而难以求解其梯度就无法直接极大化。<br>这时可以用** Jensen 不等式，<strong>得到对数似然函数的一个</strong>下界函数（ELBO），**当满足一定条件时，极大化这个下界函数是和极大化对数似然等价的。<br>$$\begin{aligned}<br>\mathbb{E}<em>{q</em>{x_0}}\left[\ln p(x_0)\right]&amp; \geq\mathbb{E}<em>{q(x</em>{1:T}|x_0)}\left[\ln\frac{p(x_{0:T})}{q(x_{1:T}|x_0)}\right]  \<br>&amp;\Rightarrow\mathbb{E}<em>{q(x_1|x_0)}\left[\ln p_\theta(x_0|x_1)\right]-\sum</em>{t&#x3D;2}^T\mathbb{E}<em>{q(x_t|x_0)}\left[D</em>{\mathrm{KL}}\left(q(x_{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t))\right]\right.<br>\end{aligned}$$<br>目标函数中最重要的是 KL 散度项，$q(x_{t-1}|x_t,x_0)$和$p_\theta(x_{t-1}|x_t)$的 KL 散度。<br>$q(x_{t-1}|x_t,x_0)$是逆过程的核心，有了它就可以完成生成过程。<br>$p_\theta(x_{t-1}|x_t)$代表模型，目标就是训练一个$p_\theta(x_{t-1}|x_t)$尽量与$q(x_{t-1}|x_t,x_0)$相似，作为$q(x_{t-1}|x_t,x_0)$的近似解。<br><strong>最终的目标函数是一个均方误差，记作</strong>$L_{\gamma}$<strong>，</strong>$\gamma_{t}$表示常数项，不影响极大化结果。<br>$L_\gamma:&#x3D;\sum_{t&#x3D;1}^T\gamma_t\mathbb{E}_{q(x_t|x_0)}\left[\left|\epsilon_t-\hat{\epsilon}_\theta(x_t,t)\right|_2^2\right],\epsilon_t\sim\mathcal{N}(0,I)$</p><h2 id="非马尔科夫前向过程"><a href="#非马尔科夫前向过程" class="headerlink" title="非马尔科夫前向过程"></a>非马尔科夫前向过程</h2><p>$q(x_{t-1}|x_t,x_0)$是条件概率分布，条件变量是$x_t$和$x_0$。<br>训练过程中，<br>$x_0$本身就是已知的。<br>$x_t$是利用线性高斯的特性，直接通过$q(x_t|x_0)$计算，而没有使用$q(x_t|x_{t-1})$，意味着$x_t$可以不依赖$x_{t-1}$。<br>那么$q(x_t|x_0)$是如何得到的，是在联合概率$q(x_{1:t}|x_0)$的基础上边际化（消除变量$x_{1:t-1}$）得到的：<br>$q(x_t|x_0)&#x3D;\int q(x_{1:t}|x_0)dx_{1:t-1}$<br>在 DDPM 中，对联合概率$q(x_{1:t})$的进一步分解是按照马尔科夫链的形式分解的，即：<br>$$\begin{aligned}<br>q(x_t|x_0)&amp; &#x3D;\int q(x_{1:t}|x_0)dx_{1:t-1}  \<br>&amp;&#x3D;\int\prod_{i&#x3D;1}^tq(x_i|x_{i-1})dx_{1:t-1}<br>\end{aligned}$$<br><strong>从概率计算规则上讲，</strong>不管$q(x_{1:t})$以何种形式分解，最终都要把它通过积分消除掉，最终的$q(x_t|x_0)$的结果都是一样的。<br>也就是说，马尔科夫链分解的方式不是必须的，如果采用其他方式就得到了一个<strong>非马尔科夫的前向模型</strong>。<br>如果不采用马尔科夫链的方式，还想得到和 DDPM 等价的模型，即不改变 DDPM 的目标函数，只需要确保$q(x_t|x_0)$和$q(x_{t-1}|x_t,x_0)$的表达式和 DDPM 一致就可以了。<br><strong>引入一个人为定义的自由参数</strong>$\sigma^2$<strong>，</strong>表示$q(x_{t-1}|x_t,x_0)$的方差。<br><strong>重新定义</strong>$q(x_{1:T}|x_0)$<strong>的分解方式：</strong><br>$q_\sigma(x_{1:T}|x_0):&#x3D;q_\sigma(x_T|x_0)\prod_{t&#x3D;2}^Tq_\sigma(x_{t-1}|x_t,x_0)$<br>其中$q_\sigma(x_T|x_0)$与 DDPM 维持一致：<br>$q_\sigma(x_T|x_0)\sim\mathcal{N}(\sqrt{\bar{\alpha}<em>T}\left.x_0,(1-\bar{\alpha}<em>T)I\right)$<br>对任意$t&gt;1$，定义$q_\sigma(x</em>{t-1}|x_t,x_0)$分布为：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694666100971-b9a5a9e7-0304-404a-8863-e7d48937afbe.png#averageHue=%23f7f6f6&clientId=u46e69163-a816-4&from=paste&height=157&id=u54bb05a0&originHeight=196&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19610&status=done&style=none&taskId=ud7a95a21-6f36-4c0a-8858-cdb54e22c2a&title=&width=741" alt="image.png"><br>看出，$q_\sigma(x</em>{t-1}|x_t,x_0)$仍是逆过程的转换核，$x_{t-1}$同时依赖$x_t$和$x_0$。<br>为什么要这么定义，这和 DDPM 中的形式也不一样，期望项中多了方差DPM<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694666524794-1dbf95be-936a-4ad8-8e6d-00e460c7472f.png#averageHue=%23f9f9f9&clientId=u46e69163-a816-4&from=paste&height=189&id=uc9e4fa1e&originHeight=189&originWidth=938&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27534&status=done&style=none&taskId=uadda1221-85fa-416c-b7b9-95d7c35b570&title=&width=938" alt="image.png"><br>DDPM<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694666539854-2a0801ca-d045-4588-8364-dd58477ccf1c.png#averageHue=%23f6f6f6&clientId=u46e69163-a816-4&from=paste&height=77&id=ua96b3c76&originHeight=77&originWidth=336&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5418&status=done&style=none&taskId=u5eba644a-31fb-47b0-9791-436058172c8&title=&width=336" alt="image.png"><br>DDIM<br>论文中有推导，附录 B<br>在 DPM 中，模型直接预测$x_0$进而得到了$q_\sigma(x_{t-1}|x_t,x_0)$的近似表示。<br>在 DDPM 中，利用$x_0&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}<em>t}\epsilon_t}{\sqrt{\bar{\alpha}<em>t}},\quad\epsilon_t\sim\mathcal{N}(0,I)$，让$x_t ，\epsilon</em>{t}$替代$x_0$，进而令模型预测$\epsilon_t$。<br>在 DDIM 中，$q_\sigma(x</em>{t-1}|x_t,x_0)$的期望又直接依赖$x_0$。<br><strong>为了能用上 DDPM 的模型（预测噪声</strong>$\hat{\epsilon}_t(x_t,t)$<strong>的模型），</strong>利用$x_0&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}_t}\epsilon_t}{\sqrt{\bar{\alpha}_t}}$得到预测的$\hat{x}<em>0$:<br>$\hat{x}<em>0&#x3D;f_\theta^{(t)}(x_t)&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}<em>t}\hat{\epsilon}<em>t(x_t,t)}{\sqrt{\bar{\alpha}<em>t}}$<br>由此，我们可以利用上已经训练好的 DDPM 模型$\hat{\epsilon}<em>t(x_t,t)$，不需要重新训练一个模型。<br>得到$\hat{x}<em>0$，再利用$q_\sigma(x</em>{t-1}|x_t,x_0)\sim\mathcal{N}\left(\sqrt{\bar{\alpha}</em>{t-1}}\left.x_0+\sqrt{1-\bar{\alpha}</em>{t-1}-\sigma_t^2}\cdot\frac{x_t-\sqrt{\bar{\alpha}<em>t}\left.x_0\right.}{\sqrt{1-\bar{\alpha}<em>t}},{\sigma_t^2I}\right)\right.$得到$q_\sigma(x</em>{t-1}|x_t,x_0)$的近似分布：<br>$$\begin{aligned}<br>p</em>{\theta,\sigma}(x</em>{t-1}|x_t)&amp; \sim\mathcal{N}\left(\sqrt{\bar{\alpha}</em>{t-1}}\left.\hat{x}<em>0+\sqrt{1-\bar{\alpha}</em>{t-1}-\sigma_t^2}\cdot\frac{x_t-\sqrt{\bar{\alpha}<em>t}\left.\hat{x}<em>0\right.}{\sqrt{1-\bar{\alpha}<em>t}},\sigma_t^2I\right)\right.   \<br>&amp;\approx q_\sigma(x</em>{t-1}|x_t,x_0)<br>\end{aligned}$$<br><strong>整理以上整个逆过程：</strong><br><strong>对于</strong>$x_T$<strong>:</strong><br>$p(x_T)&#x3D;\mathcal{N}(0,I)$<br><strong>对于</strong>$p(x</em>{t-1}|x_t)$<strong>：</strong><br>$p(x</em>{t-1}|x_t)&#x3D;\left{\begin{array}{ccc}&amp;\mathcal{N}(\hat{x}<em>0(x_1,t&#x3D;1),\sigma_1^2I<del>)&amp;\mathrm{</del>if~}&amp;t&#x3D;1\&amp;q_\sigma(x</em>{t-1}|x_t,\hat{x}<em>0(x_t,t))&amp;\mathrm{<del>if</del>}&amp;1&lt;t\leq T\end{array}\right.$<br><strong>根据</strong>$p</em>{\theta,\sigma}(x</em>{t-1}|x_t)\sim\mathcal{N}\left(\sqrt{\bar{\alpha}</em>{t-1}}\left.\hat{x}<em>0+\sqrt{1-\bar{\alpha}</em>{t-1}-\sigma_t^2}\cdot\frac{x_t-\sqrt{\bar{\alpha}_t}\left.\hat{x}_0\right.}{\sqrt{1-\bar{\alpha}<em>t}},\sigma_t^2I\right)\right.$<strong>，</strong>$x</em>{t-1}$<strong>具体采样公式：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694670854027-8de1efea-f3e5-4648-b4f6-525080f2bc80.png#averageHue=%23f7f6f6&clientId=u46e69163-a816-4&from=paste&height=224&id=u6ef58cf8&originHeight=278&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40564&status=done&style=none&taskId=u5fd0f062-aace-4dfc-9725-eb4a864e1e3&title=&width=811" alt="image.png"></p><h2 id="加速采样"><a href="#加速采样" class="headerlink" title="加速采样"></a>加速采样</h2><p>在 DDPM 中，方差是直接贝叶斯推导出来的：$\sigma^2&#x3D;\frac{(1-\alpha_t)(1-\bar{\alpha}<em>{t-1})}{1-\bar{\alpha}<em>t}$。<br>在 DDIM 中，方差是超参数，通过调整$\sigma^{2}$从而达到不一样的效果。<br>如果将$\sigma^{2}$调整为与 DDPM 一样的形式，那么 DDIM 就退化为 DDPM。<br><strong>DDIM 可以看作是 DDPM 的拓展，DDPM 是 DDIM 的特例。</strong><br>$\sigma^{2}$另一个特例是令$\sigma^{2}&#x3D;0$。<br>直接导致$x</em>{t-1}&#x3D;\sqrt{\bar{\alpha}</em>{t-1}}\underbrace{\left(\frac{x_t-\sqrt{1-\bar{\alpha}<em>t}\hat{\epsilon}<em>t(x_t,t)}{\sqrt{\bar{\alpha}<em>t}}\right)}</em>{\text{predict }x_0}+\underbrace{\sqrt{1-\bar{\alpha}</em>{t-1}-\sigma_t^2}\quad\hat{\epsilon}<em>t(x_t,t)}</em>{\text{direction pointing to }x_t}+\underbrace{\sigma_t\epsilon_t^*}</em>{\text{random noise}}$中的随机噪声$\sigma_t\epsilon_t^*$没了，$x_{t-1}$直接等于$q_\sigma(x_{t-1}|x_t,x_0)$的期望。<br><strong>从随机采样的角度，</strong>$x_{t-1}$不再是从$q_\sigma(x_{t-1}|x_t,x_0)$随机采样，而是直接选择其期望。<br>又由于$q_\sigma(x_{t-1}|x_t,x_0)$是高斯分布，其期望是概率密度的最大点。<br>相当于$x_{t-1}$每次都选取的$q_\sigma(x_{t-1}|x_t,x_0)$的最大值点，即最大概率采样。<br><strong>从数值计算角度，</strong>没了随机项，成了确定性计算，不再具有随机性。<br><strong>加速的原因：</strong><br><strong>当方差不是 0 的时候</strong>，$x_t$到$x_{t-1}$的每一步都是随机性采样。<br>相当于从$x_T$到$x_0$的每一步都不好好走，总在这个方向上加一个随机量，因此会走很多弯路，从而到达$x_0$的步数就变长了。<br><strong>方差为 0 时，</strong>$x_T$<strong>到</strong>$x_0$<strong>的每一步，都是沿着期望方向笔直前进，因此就快多了。</strong></p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>如果$\sigma_t\neq0$，意味着保留了随机性，生成的多样性更好，但是收敛速度会下降。<br>反之，去掉随机项，收敛速度会加快，但是会损失多样性。<br>如果要兼顾速度和多样性，可以设计一个动态自适应的调度算法。<br>开始的一段时间，令$\sigma_t&#x3D;0$加快收敛速度。<br>最后一段时间，令$\sigma_t\neq0$增加多样性。可以线性控制也可以余弦控制。、</p><h1 id="Score-based-DDPM"><a href="#Score-based-DDPM" class="headerlink" title="Score-based DDPM"></a>Score-based DDPM</h1><p><strong>Tweedie 公式。</strong><br>在统计学中，经常需要根据观察样本估计概率分布的未知参数，比如最大似然估计、贝叶斯估计等。<br>Tweedie 公式就可以用来估计高斯分布的均值参数。<br>假设有一个（多元）高斯随机变量$z\sim(\mathcal{N}z;\mu_z,\Sigma_z)$。<br><strong>Tweedie 公式可以写成</strong>：$\mathbb{E}[\mu_z|z]&#x3D;z+\Sigma_z\underbrace{\nabla_z\log p(z)}<em>{\mathrm{score}}$。<br>$\mathbb{E}[\mu_z|z]$表示有$z$样本条件下，$\mu_z$的期望，直观理解就是用$z$的样本估计$\mu_z$。<br>$\log p(z)$是观测样本的对数似然，$\nabla_z\log p(z)$是观测样本的对数似然的一阶导数，也可以称为梯度、Stein 分数。<br><strong>在前向过程中，</strong>$q(x_t|x_0)&#x3D;\mathcal{N}(x_t;\sqrt{\bar{\alpha}<em>t}x_0,(1-\bar{\alpha}<em>t)I)$<strong>。</strong><br>$q(x_t|x_0)$是高斯分布，均值是$\sqrt{\bar{\alpha}<em>t}x_0$。<br>可以利用 Tweedie 公式估计这个均值参数：$\sqrt{\bar{\alpha}<em>t}x_0&#x3D;\mathbb{E}\left[\mu</em>{x_t}|x_t\right]&#x3D;x_t+(1-\bar{\alpha}<em>t)\nabla</em>{x_t}\log p(x_t)$。<br>上面公式移项得到<strong>用分数表达</strong>$x_0$：$x_0&#x3D;\frac{x_t+(1-\bar{\alpha}<em>t)\nabla\log p(x_t)}{\sqrt{\bar{\alpha}<em>t}}$。<br><strong>逆过程中有真实分布</strong>$q(x</em>{t-1}|x_t,x_0)$<strong>的均值</strong>$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}$<strong>。</strong><br><strong>替换</strong>$x_0$<strong>得到：</strong>$\mu_q(x_t,x_0)&#x3D;\frac1{\sqrt{\alpha_t}}x_t+\frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla\log p(x_t)$<strong>。</strong><br>推导过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694703583819-a03de1ec-4155-4ff8-a648-096aeaea90de.png#averageHue=%23f7f7f6&clientId=u44e270e5-ffc9-4&from=paste&height=741&id=uf2588dab&originHeight=741&originWidth=935&originalType=binary&ratio=1&rotation=0&showTitle=false&size=101050&status=done&style=none&taskId=u42cdb7a6-ba67-404e-961f-bcf0f4ae229&title=&width=935" alt="image.png"><br><strong>按照这个形式重新设定参数化分布</strong>$p_\theta(x</em>{t-1}|x_t)$<strong>的均值表达式：</strong>$\mu_\theta(x_t,t)&#x3D;\frac1{\sqrt{\alpha_t}}x_t+\frac{1-\alpha_t}{\sqrt{\alpha_t}}s_\theta(x_t,t)$<strong>。</strong><br><strong>现在</strong>$s_\theta(x_t,t)$<strong>是模型学习预测的内容，相当于模型预测的是分数</strong>$\nabla</em>{x_t}\log p(x_t)$<strong>。</strong><br><strong>重新推导 ELBO 函数中的 KL 散度：</strong><br>$\arg\min_\theta D</em>{\mathrm{KL}}\left(q(x</em>{t-1}|x_t,x_0)|p_\theta(x_{t-1}|x_t)\right)&#x3D;\arg\min_\theta\frac{1}{2\sigma_q^2(t)}\frac{(1-\alpha_t)^2}{\alpha_t}\Big[\left|s_\theta(x_t,t)-\nabla\log p(x_t)\right|_2^2\Big]$<br>推导过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694703862813-f5389ffa-fe8a-40dd-9f13-f317314c4410.png#averageHue=%23f7f6f5&clientId=u44e270e5-ffc9-4&from=paste&height=447&id=ubc78eb4c&originHeight=447&originWidth=971&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80782&status=done&style=none&taskId=ue2313c64-9ab4-4446-9177-ee713d97763&title=&width=971" alt="image.png"><br>最后的目标函数依旧是均方误差的形式，和 DPM、DDPM 一致。<br>$\nabla\log p(x_t)$是梯度的真实值，可以直接通过 pytorch 计算得到。<br>$s_\theta(x_t,t)$代表神经网络模型，去学习和预测$\nabla\log p(x_t)$。<br>结合$x_0&#x3D;\frac{x_t-\sqrt{1-\bar{\alpha}_t}\left.\epsilon_t\right.}{\sqrt{\bar{\alpha}_t}}$和$x_0&#x3D;\frac{x_t+(1-\bar{\alpha}_t)\nabla\log p(x_t)}{\sqrt{\bar{\alpha}_t}}$可以得到$\nabla\log p(x_t)&#x3D;-\frac1{\sqrt{1-\bar{\alpha}_t}}\epsilon_t$。</p><h1 id="扩散模型的三种形式"><a href="#扩散模型的三种形式" class="headerlink" title="扩散模型的三种形式"></a>扩散模型的三种形式</h1><p><strong>扩散模型有三种形式：</strong><br><strong>1.直接预测初始样本</strong><br><strong>2.预测噪声</strong><br><strong>3.预测分数</strong><br>逆过程中真实后验分布为$q(x_{t-1}|x_t,x_0)$。<br>这是一个高斯分布，$q(x_{t-1}|x_t,x_0)\sim\mathcal{N}(x_{t-1},\mu_q,\Sigma_{q(t)})$，均值记为$\mu_q$，方差记为$\Sigma_{q(t)}$。<br>方差看做已知的常量：$\Sigma_q(t)&#x3D;\frac{(1-\alpha_t)(1-\bar{\alpha}<em>{t-1})}{1-\bar{\alpha}<em>t}I&#x3D;\sigma_q^2(t)I$。<br>参数化模型学习的分布记为$p_\theta(x</em>{t-1}|x_t)$。<br>要令$p_\theta(x</em>{t-1}|x_t)$尽量近似真实分布$q(x_{t-1}|x_t,x_0)$，那么模型学习拟合的均值$\mu_q$可以推导出三种形式，对应三种学习方式。</p><h2 id="学习初始样本"><a href="#学习初始样本" class="headerlink" title="学习初始样本"></a>学习初始样本</h2><p>$\mu_q(x_t,x_0)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}<em>{t-1})x_t+\sqrt{\bar{\alpha}</em>{t-1}}(1-\alpha_t)x_0}{1-\bar{\alpha}<em>t}$<br>按照这个形式设定参数化分布的均值$\mu_\theta$：<br>$\mu_\theta&#x3D;\mu_\theta(x_t,t)&#x3D;\frac{\sqrt{\alpha_t}(1-\bar{\alpha}</em>{t-1})x_t+\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\hat{x}_\theta(x_t,t)}{1-\bar{\alpha}_t}$<br>这种方式学习的是初始样本$x_0$，对模型来说难度较大，效果不突出。</p><h2 id="学习噪声"><a href="#学习噪声" class="headerlink" title="学习噪声"></a>学习噪声</h2><p>$\mu_q(x_t,x_0)&#x3D;\frac1{\sqrt{\alpha_t}}x_t-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\epsilon$<br>按照这个形式设定参数化分布的均值$\mu_\theta$：<br>$\mu_\theta&#x3D;\mu_\theta(x_t,t)&#x3D;\frac1{\sqrt{\alpha_t}}x_t-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\hat{\epsilon}_\theta(x_t,t)$<br>这种方式预测的是噪声$\epsilon$，模型效果提升很大。</p><h2 id="学习分数"><a href="#学习分数" class="headerlink" title="学习分数"></a>学习分数</h2><p>$\mu_q(x_t,x_0)&#x3D;\frac1{\sqrt{\alpha_t}}x_t+\frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla\log p(x_t)$<br>按照这个形式设定参数化分布的均值$\mu_\theta$：<br>$\mu_q(x_t,x_0)&#x3D;\frac1{\sqrt{\alpha_t}}x_t+\frac{1-\alpha_t}{\sqrt{\alpha_t}}s_\theta(x_t,t)$<br>这种方式预测的是分数（梯度）$\nabla\log p(x_t)$。<br>相比于学习噪声，可以在逆过程采样图片时采用基于分数的采样算法，基于分数的采样算法种类很多，从而增大了算法灵活性。</p><h1 id="Guided-Diffusion"><a href="#Guided-Diffusion" class="headerlink" title="Guided Diffusion"></a>Guided Diffusion</h1><p>DDPM 和 DDIM 生成图片时，都是输入一个随机高斯噪声，然后逐步生成真实图片。<br>这个过程中的每一步都是随机的，所以生成的图片多样性很好。<br>缺点就是生成图像不可控，无法控制生成过程。<br>直觉上讲，可以在扩散过程中<strong>引入额外的信息来指导扩散模型</strong>。<br>假设这个额外的信息为$y$，可以是文本、图片、标签等。<br><strong>引入</strong>$y$<strong>后，模型就变成了一个以</strong>$y$<strong>为条件的概率分布：</strong>$p(x_{1:T}|y,x_0)$<strong>。</strong><br><strong>接下来需要分析引入</strong>$y$<strong>后对扩散过程和逆向过程有什么影响，需要做什么调整。</strong><br><strong>对于扩散过程，引入</strong>$y$<strong>没有产生任何影响。</strong><br><strong>那么，重点将是</strong>$y$<strong>对逆向过程的影响。</strong><br>原始的无条件扩散模型的逆向过程联合概率分布为：$p(x_{0:T})&#x3D;p(x_T)\prod_{t&#x3D;1}^Tp_\theta(x_{t-1}|x_t)$。<br>添加$y$后，逆向联合概率分布为：$p(x_{0:T}|y)&#x3D;p(x_T)\prod_{t&#x3D;1}^Tp_\theta(x_{t-1}|x_t,y)$。</p><h2 id="Classifier-Guidance"><a href="#Classifier-Guidance" class="headerlink" title="Classifier Guidance"></a>Classifier Guidance</h2><p>扩散模型的降噪过程可以从三种角度理解。<br>其中一种是神经网络去预测$x_t$的对数梯度：$\hat{s}<em>\theta(x_t,t)\approx\nabla</em>{x_t}\log p(x_t)$。<br>引入条件$y$后，由原来的$\nabla_{x_t}\log p(x_t)$变成$\nabla_{x_t}\log p(x_t|y)$。<br>推导出：$\nabla_{x_t}\log p(x_t|y)&#x3D;\underbrace{\nabla_{x_t}\log p(x_t)}<em>\text{unconditional score}+\underbrace{\nabla</em>{x_t}\log p(y|x_t)}<em>\text{adversarial gradient}$<br>推导过程<img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694707096124-f2c14069-2528-438b-9019-7998bfddb400.png#averageHue=%23f6f5f4&clientId=u44e270e5-ffc9-4&from=paste&height=253&id=uf0fde2f6&originHeight=253&originWidth=813&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39398&status=done&style=none&taskId=u24ca6309-140b-49ca-ba94-22b44c19a15&title=&width=813" alt="image.png"><br><strong>第一项</strong>$\nabla</em>{x_t}\log p(x_t)$<strong>是无条件扩散模型的梯度，称为无条件分数。</strong><br><strong>第二项</strong>$\nabla_{x_t}\log p(y|x_t)$<strong>称为对抗梯度。</strong><br>其中，$p(y|x_t)$代表一个<strong>分类器，</strong>$x_t$<strong>是分类器的输入，</strong>$y$<strong>是分类器预测的标签。</strong><br><strong>综合一下，条件扩散模型的分数就是在非条件扩散模型分数的基础上加了一项分类器的对抗梯度。</strong><br><strong>分类器</strong>$p(y|x_t)$<strong>的输入不是初始图像</strong>$x_0$<strong>，而是加了噪声的</strong>$x_t$<strong>。</strong><br><strong>分类器需要在训练条件扩散模型前，独立训练好。</strong><br>在训练分类器时，需要用扩散模型的前向加噪过程得到$x_t$作为分类器的输入，在实现时：<br>1.预训练好一个噪声分类器$p(y|x_t)$<br>2.在原来非条件扩散模型的每一时刻$t$的采样过程中：<br>1.把模型的预测输出$\hat{s}<em>\theta(x_t,t)$<br>2.同时把$x_t$输入到预训练好的噪声分类器$p(y|x_t)$，并计算出梯度$\nabla</em>{x_t}\log p(y|x_t)$<strong>。</strong><br>3.计算$\hat{s}<em>\theta(x_t,t,y)&#x3D;\hat{s}<em>\theta(x_t,t)+\nabla</em>{x_t}\log p(y|x_t)$。<br>4.继续原来的处理<br>噪声分类器的对抗梯度$\nabla</em>{x_t}\log p(y|x_t)$影响采样降噪过程，让采样向着类别标签$y$的方向前进，进而得到贴近标签$y$的图像。<br><strong>classifier guidance 会让生成图像质量提高，但是会降低其多样性。</strong><br><strong>为了更灵活控制生成内容的方向，增加了一个超参数</strong>$\text{λ}$<strong>，作为权重项。</strong><br>这个权重可以调节类别引导的作用大小：$\nabla_{x_t}\log p(x_t|y)&#x3D;\nabla_{x_t}\log p(x_t)+\lambda\nabla_{x_t}\log p(y|x_t)$。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35710960/1694711233805-fffa8380-cd45-4d7f-b84d-d9ffe4b0ea55.png#averageHue=%23f6f5f4&clientId=u44e270e5-ffc9-4&from=paste&height=961&id=u0fb10426&originHeight=961&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&size=214862&status=done&style=none&taskId=uc3059a0d-6c9c-4bda-a1d1-da4738bfbf2&title=&width=1611" alt="image.png"><br><strong>classifier guidance 缺点明显：</strong><br>1.需要额外一个分类器模型，极大增加了成本，包括训练成本和采样成本。<br>2.分类器的类别毕竟是有限集，不能涵盖全部情况，对于没有覆盖的标签类别会很不友好。<br>3.分类器和扩散模型是分开训练的，不利于进一步扩展模型的规模。<br>4.输入$x_t$中大多信息与$y$无关。</p><h2 id="Classifier-free-guidance"><a href="#Classifier-free-guidance" class="headerlink" title="Classifier-free guidance"></a>Classifier-free guidance</h2><p>Classifier Guidance 使用显式的分类器引导条件生成。<br>Classifier-free Guidance 的核心是使用隐式分类器，无需直接计算显示分类器及其梯度。<br>在Classifier Guidance $\nabla_{x_t}\log p(x_t|y)&#x3D;\underbrace{\nabla_{x_t}\log p(x_t)}<em>\text{unconditional score}+\underbrace{\nabla</em>{x_t}\log p(y|x_t)}<em>\text{adversarial gradient}$基础上稍微变换一下：<br>$\nabla</em>{x_t}\log p(y|x_t)&#x3D;\nabla_{x_t}\log p(x_t|y)-\nabla_{x_t}\log p(x_t)$。<br><strong>根据贝叶斯公式，分类器的梯度可以用条件生成概率和无条件生成概率表示：</strong><br>$$\begin{aligned}<br>\nabla_{\mathbf{x}<em>{t}}\log p\left(y\mid\mathbf{x}</em>{t}\right)&amp; &#x3D;\nabla_{\mathbf{x}_t}\log p\left(\mathbf{x}<em>t\mid y\right)-\nabla</em>{\mathbf{x}_t}\log p\left(\mathbf{x}_t\right)  \<br>&amp;&#x3D;-\frac1{\sqrt{1-\bar{\alpha}_t}}(\boldsymbol{\epsilon}_\theta\left(\mathbf{x}_t,t,y\right)-\boldsymbol{\epsilon}_\theta\left(\mathbf{x}_t,t\right))<br>\end{aligned}$$<br><strong>在Classifier Guidance：</strong>$\begin{aligned}\hat{\epsilon}_\theta(x_t|y)&#x3D;\epsilon_\theta(x_t|\emptyset)-\sqrt{1-\bar{\alpha}<em>t}\nabla</em>{x_t}\log p_\phi(y|x_t)\end{aligned}$<strong>。</strong><br><strong>代入其中得到classifier-free guidance：</strong>$\hat{\epsilon}_\theta(x_t|y)&#x3D;\epsilon_\theta\left(\mathbf{x_t}\mid\emptyset\right)+\gamma\cdot\left(\epsilon_\theta\left(\mathbf{x_t}\mid\mathbf{y}\right)-\epsilon_\theta\left(\mathbf{x_t}\mid\emptyset\right)\right)$<br>为了在 classifier-free guidance 中使用通用文本 prompts，在训练中有时会将文本替换成空序列$\emptyset$。<br>$\gamma&#x3D;0$时为无条件模型，$\gamma&#x3D;1$时为标准的条件概率模型。<br><strong>看出，新的生成过程不再依赖显式的分类器 classifier。</strong><br><strong>训练时，classifier-free guidance 需要训练两个模型，一个是无条件生成，一个是条件生成。</strong><br><strong>通过以一定概率将条件置空即可在一个模型中表示。</strong><br><strong>推理时，最终结果可以由条件生成和无条件生成的线性外推获得。</strong><br><strong>生成效果可以引导系数可以调节，控制生成样本的逼真性和多样性的平衡。</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/huggingface/diffusers">https://github.com/huggingface/diffusers</a> 开源代码</li><li><a href="https://www.zhangzhenhu.com/aigc/%E6%89%A9%E6%95%A3%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B.html">张振虎 - DPM DDPM</a></li><li><a href="https://www.zhangzhenhu.com/aigc/ddim.html">张振虎 - DDIM</a></li><li><a href="https://www.zhangzhenhu.com/aigc/Guidance.html">张振虎 - 条件控制扩散模型</a></li><li><a href="https://www.zhangzhenhu.com/aigc/Score-Based_Generative_Models.html">张振虎 - 基于分数的生成模型</a></li><li><a href="https://zhuanlan.zhihu.com/p/569700320">知乎 - 扩散模型笔记5 classifier-free guidance</a></li><li><a href="https://sunlin-ai.github.io/2022/06/01/Classifier-Free-Diffusion.html">[论文理解] Classifier-Free Diffusion Guidance</a></li><li><a href="https://zhuanlan.zhihu.com/p/640631667">知乎 - 通俗理解Classifier Guidance 和 Classifier-Free Guidance 的扩散模型</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【读书】长得好看能当饭吃吗</title>
    <link href="/2022/12/26/%E3%80%90%E8%AF%BB%E4%B9%A6%E3%80%91%E9%95%BF%E5%BE%97%E5%A5%BD%E7%9C%8B%E8%83%BD%E5%BD%93%E9%A5%AD%E5%90%83%E5%90%97%EF%BC%9A%E6%8F%90%E5%8D%87%E8%AE%A4%E7%9F%A5%E7%9A%8433%E4%B8%AA%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%B8%B8%E8%AF%86/"/>
    <url>/2022/12/26/%E3%80%90%E8%AF%BB%E4%B9%A6%E3%80%91%E9%95%BF%E5%BE%97%E5%A5%BD%E7%9C%8B%E8%83%BD%E5%BD%93%E9%A5%AD%E5%90%83%E5%90%97%EF%BC%9A%E6%8F%90%E5%8D%87%E8%AE%A4%E7%9F%A5%E7%9A%8433%E4%B8%AA%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%B8%B8%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 长得好看能当饭吃吗：提升认知的33个经济学常识</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/63/cpPlatform_xqUDh8Yhgiz5xypk5RBAph/t7_cpPlatform_xqUDh8Yhgiz5xypk5RBAph.jpg" alt=" 长得好看能当饭吃吗：提升认知的33个经济学常识|200"></li><li>书名： 长得好看能当饭吃吗：提升认知的33个经济学常识</li><li>作者： 谢宗博</li><li>简介： 水是必需品都这么便宜，钻石没什么用为啥那么贵？<br>为什么男朋友会在虚拟游戏中花费巨资买道具？<br>我这么优秀，为什么还是剩下了？<br>餐厅为什么会有“饮料无限续杯”的服务，不怕被喝破产吗？<br>我年轻力壮还需要买保险吗？<br>……<br>在生活中，我们常常会面临一些疑问和困惑。其实，生活中的一切问题都可以在经济学中找到答案。本书提出了生活中经常遇到的33个问题，通过讲故事的手法，结合现实生活中的实例，从经济学角度进行分析，你会发现，所有的问题都能用经济学进行解答。掌握经济学思维，能帮你更通透的认清人生中各种事件背后的逻辑，从而更好地做好人生抉择。</li><li>出版时间 2022-04-01 00:00:00</li><li>ISBN： 9787510474750</li><li>分类： 经济理财-理财</li><li>出版社： 新世界出版社</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="01-坎蒂隆效应-为什么收入越来越多，却感觉越来越穷？"><a href="#01-坎蒂隆效应-为什么收入越来越多，却感觉越来越穷？" class="headerlink" title="01 坎蒂隆效应 为什么收入越来越多，却感觉越来越穷？"></a>01 坎蒂隆效应 为什么收入越来越多，却感觉越来越穷？</h2><ul><li>📌 财富分化带给我们的直观感受，并不是收入更高了就变富了，而是在财富中的位置靠前了，才是变富了。 ^3300025230-5-8874-8920<ul><li>⏱ 2023-06-13 15:24:37</li></ul></li></ul><h2 id="04-价格陷阱-买前冲动，买完后悔，怎么走出商家的套路？"><a href="#04-价格陷阱-买前冲动，买完后悔，怎么走出商家的套路？" class="headerlink" title="04 价格陷阱 买前冲动，买完后悔，怎么走出商家的套路？"></a>04 价格陷阱 买前冲动，买完后悔，怎么走出商家的套路？</h2><ul><li><p>📌 诱饵效应（decoy effect），是指人们对两个不相上下的选项进行选择时，因为第三个新选项（诱饵）的加入，会使某个旧选项显得更有吸引力。 ^3300025230-8-4868-4938</p><ul><li>⏱ 2023-06-17 10:13:38</li></ul></li><li><p>📌 人往往会对未来有过高的期望和认知，即使预期的金钱收入尚未真实兑现，人们往往会认为肯定会兑现，并当作已经兑现开始消费，一旦这笔预期收入无法兑现，那么已经消费掉的金钱就被“夸张贴现”了。 ^3300025230-8-7657-7748</p><ul><li>⏱ 2023-06-17 10:16:24</li></ul></li><li><p>📌 世界上没有免费的午餐。正如那句名言所说：所有命运的馈赠，早已在暗中标好了价格。 ^3300025230-8-9691-9730</p><ul><li>⏱ 2023-06-17 10:18:53</li></ul></li></ul><h2 id="05-理性人假设-总是做不到理性消费，我该怎么改？"><a href="#05-理性人假设-总是做不到理性消费，我该怎么改？" class="headerlink" title="05 理性人假设 总是做不到理性消费，我该怎么改？"></a>05 理性人假设 总是做不到理性消费，我该怎么改？</h2><ul><li><p>📌 主流经济学假设我们都有爱因斯坦一样的智商，计算机一样的记忆力，甘地一样的意志力。 ^3300025230-9-1105-1145</p><ul><li>⏱ 2023-06-17 10:20:48</li></ul></li><li><p>📌 人在面临获利时不愿冒风险；而在面临损失时，人人都成了冒险家。 ^3300025230-9-3859-3889</p><ul><li>⏱ 2023-06-17 10:24:54</li></ul></li><li><p>📌 在涉及收益时，我们是风险的喜好者；在涉及损失时，我们又是风险厌恶者。 ^3300025230-9-6922-6956</p><ul><li>⏱ 2023-06-17 13:35:42</li></ul></li><li><p>📌 归根结底，人们真正憎恨的是损失，而不是风险。 ^3300025230-9-7072-7094</p><ul><li>⏱ 2023-06-17 13:35:59</li></ul></li><li><p>📌 禀赋效应（endowment effect），是指我们一旦拥有某件物品，那么自然而然就会对该物品价值的评价比没有拥有之前大大增加，这实际上可以理解为我们常说的“敝帚自珍”。 ^3300025230-9-7959-8045</p><ul><li>⏱ 2023-06-17 13:36:53</li></ul></li><li><p>📌 会高估多少呢？行为经济学认为，通常这个价格会高估到没有那件物品的人认定价格的两倍。一旦这个东西属于我们之后，我们就会高估它的价值，特别是如果这个东西丢了或者损失了，就会感觉非常难受，这实际上是很多人都存在的心理。 ^3300025230-9-8074-8180</p><ul><li>⏱ 2023-06-17 13:37:12</li></ul></li></ul><h2 id="06-经济学偏差-我为什么不是理性经济人？"><a href="#06-经济学偏差-我为什么不是理性经济人？" class="headerlink" title="06 经济学偏差 我为什么不是理性经济人？"></a>06 经济学偏差 我为什么不是理性经济人？</h2><ul><li><p>📌 实际上，这恰恰忽略了医生的职业特点，每天他都在接触大量病人，对各种各样的痛苦已经习以为常，而且他的责任在于准确地做出诊断，并不是对患者的病情表示同情。 ^3300025230-10-3956-4031</p><ul><li>⏱ 2023-06-18 13:05:11</li></ul></li><li><p>📌 所谓利己主义归因偏差是指人们一般对良好的行为或成功归因于自身，而将不良的行为或失败归因于外部情境或他人。 ^3300025230-10-4150-4202</p><ul><li>⏱ 2023-06-18 13:05:20</li></ul></li><li><p>📌 证实性偏差是指当人确立了某一个信念或观念时，在收集信息和分析信息的过程中，会产生一种寻找支持这个信念的证据的倾向。也就是说他们会很容易接受“支持这个信念”的信息，而忽略“否定这个信念”的信息，甚至还会花费更多的时间和认知资源贬低与他们看法相左的观点。 ^3300025230-10-9149-9274</p><ul><li>⏱ 2023-06-19 16:14:44</li></ul></li><li><p>📌 证实性偏差主要来源于预设立场。人们常常根据自己对特定事件的代表性观点，选择性地回忆、搜集有利细节，忽略不利或矛盾的资讯，来支持自己已有的想法的片面诠释。 ^3300025230-10-9592-9668</p><ul><li>⏱ 2023-06-19 16:15:17</li></ul></li></ul><h2 id="07-信息不对称-为什么掌握的资讯越多，这个世界的信息鸿沟就越深？"><a href="#07-信息不对称-为什么掌握的资讯越多，这个世界的信息鸿沟就越深？" class="headerlink" title="07 信息不对称 为什么掌握的资讯越多，这个世界的信息鸿沟就越深？"></a>07 信息不对称 为什么掌握的资讯越多，这个世界的信息鸿沟就越深？</h2><ul><li><p>📌 公众的信息需求并非全方位的，公众只注意使自己愉悦的领域，久而久之，会将自身桎梏于像蚕茧一般的茧房中。 ^3300025230-11-4306-4356</p><ul><li>⏱ 2023-06-19 16:19:18</li></ul></li><li><p>📌 能够向下兼容的人是能包容不同阶层的人，即便别人的认知水平有限，他们也能理解，即便别人的思维逻辑有错，也能够包容。 ^3300025230-11-7884-7940</p><ul><li>⏱ 2023-06-19 16:29:12</li></ul></li><li><p>📌 看起来唾手可得的月亮，大部分人却永远无法企及。 ^3300025230-11-8402-8425</p><ul><li>⏱ 2023-06-19 16:30:45</li></ul></li></ul><h2 id="08-机会成本-是在小城市岁月静好，还是到大城市策马奔腾？"><a href="#08-机会成本-是在小城市岁月静好，还是到大城市策马奔腾？" class="headerlink" title="08 机会成本 是在小城市岁月静好，还是到大城市策马奔腾？"></a>08 机会成本 是在小城市岁月静好，还是到大城市策马奔腾？</h2><ul><li><p>📌 失去了选择，也就不存在机会成本。 ^3300025230-13-3649-3665</p><ul><li>⏱ 2023-06-25 13:08:49</li></ul></li><li><p>📌 当资源可以覆盖所有机会，不需要做出选择的时候，机会成本也就不复存在。 ^3300025230-13-3807-3841</p><ul><li>⏱ 2023-06-25 13:09:10</li></ul></li><li><p>📌 我们总是需要在有限的能力范围内选择最好的机会。 ^3300025230-13-3976-3999</p><ul><li>⏱ 2023-06-25 13:09:30</li></ul></li><li><p>📌 选择的意义不仅仅在于你选择的东西，更在于你放弃的东西。你放弃的每一个机会都没有真正地放弃，而是变成了机会成本，作为日后衡量利益得失的基石。 ^3300025230-13-5709-5778</p><ul><li>⏱ 2023-06-25 13:11:13</li></ul></li><li><p>📌 扪心自问，选择闯荡江湖时的你会后悔错过了现世安稳吗？岁月静好时的你会后悔没有策马奔腾吗？ ^3300025230-13-7239-7283</p><ul><li>⏱ 2023-06-25 13:12:54</li></ul></li><li><p>📌 正如东野圭吾的《解忧杂货店》一书里写道：“其实所有纠结做选择的人，心里早就有了答案，咨询只是想得到内心所倾向的选择。最终的所谓命运，还是自己一步步走出来的。” ^3300025230-13-7742-7821</p><ul><li>⏱ 2023-06-25 13:13:36</li></ul></li></ul><h2 id="09-幸存者偏差-为什么别人家的孩子都那么优秀？"><a href="#09-幸存者偏差-为什么别人家的孩子都那么优秀？" class="headerlink" title="09 幸存者偏差 为什么别人家的孩子都那么优秀？"></a>09 幸存者偏差 为什么别人家的孩子都那么优秀？</h2><ul><li><p>📌 妈妈为什么不挑食？因为她买菜的时候已经挑过了！ ^3300025230-14-1627-1650</p><ul><li>⏱ 2023-06-25 13:15:00</li></ul></li><li><p>📌 幸存者偏差，总结成一句话，就是越认真观察眼前的真相，你离真相往往越远。 ^3300025230-14-3880-3915</p><ul><li>⏱ 2023-06-25 13:18:48</li></ul></li><li><p>📌 爱笑的女孩，运气都不会太差——没错，因为运气差的女孩，根本笑不出来。 ^3300025230-14-9843-9877</p><ul><li>⏱ 2023-06-25 13:36:59</li></ul></li></ul><h2 id="10-价值判断-为什么男朋友会在虚拟游戏中花费巨资买道具？"><a href="#10-价值判断-为什么男朋友会在虚拟游戏中花费巨资买道具？" class="headerlink" title="10 价值判断 为什么男朋友会在虚拟游戏中花费巨资买道具？"></a>10 价值判断 为什么男朋友会在虚拟游戏中花费巨资买道具？</h2><ul><li><p>📌 汝之蜜糖，我之砒霜 ^3300025230-15-1059-1068</p><ul><li>⏱ 2023-06-25 13:37:55</li></ul></li><li><p>📌 人们以什么样的价格接受一件物品，并不是基于这个物品的客观价值，而是基于自己对这个物品的主观价值判断。 ^3300025230-15-2183-2233</p><ul><li>⏱ 2023-06-25 13:41:17</li></ul></li><li><p>📌 自愿交换的参与者会相互受益 ^3300025230-15-3369-3382</p><ul><li>⏱ 2023-06-25 13:43:32</li></ul></li><li><p>📌 生命诚可贵，爱情价更高。若为自由故，两者皆可抛。 ^3300025230-15-11035-11059</p><ul><li>⏱ 2023-06-26 08:13:19</li></ul></li></ul><h2 id="11-概率与风险-为什么别人的人生开了挂，我却处处碰壁？"><a href="#11-概率与风险-为什么别人的人生开了挂，我却处处碰壁？" class="headerlink" title="11 概率与风险 为什么别人的人生开了挂，我却处处碰壁？"></a>11 概率与风险 为什么别人的人生开了挂，我却处处碰壁？</h2><ul><li><p>📌 命运确实不公平。历史的曲折不会均匀地分布在每一个参与者的身上，在跌宕起伏的过程中，很多人的人生都被随机裹挟着前行。对个人而言，时代的一粒尘埃，砸在自己身上都是一座山。我们无法改变历史的进程，但是也无法改变自己身上的这座山吗？ ^3300025230-16-1612-1724</p><ul><li>⏱ 2023-06-26 08:20:29</li></ul></li><li><p>📌 事情的发展过程是一个个事件组成的链条，每一个事件的发生都是随机的，都有着各自不同的发生概率，单看每一个事件都是独立的，但是组成的链条却又错综复杂互相关联。 ^3300025230-16-4755-4832</p><ul><li>⏱ 2023-06-26 08:25:45</li></ul></li><li><p>📌 ，高收益是对承担高风险的补偿。 ^3300025230-16-9025-9040</p><ul><li>⏱ 2023-06-26 09:51:57</li></ul></li><li><p>📌 “自主经营、自负盈亏”，正是区别老板与员工的本质。 ^3300025230-16-9194-9219</p><ul><li>⏱ 2023-06-26 09:52:16</li></ul></li><li><p>📌 我们衡量风险时考量的因素，不仅仅只是概率，更应该包括风险发生所造成的损失。 ^3300025230-16-12059-12096</p><ul><li>⏱ 2023-06-26 09:57:14</li></ul></li><li><p>📌 保险公司收取的利润是“割韭菜”吗？正如我们所说，高收益来自承担的高风险，保险公司替我们承担了厄运发生的影响，等于是我们将厄运发生的风险转移给了保险公司，保险公司因为替我们承担风险而收取一定的利润，不也是应该的吗？ ^3300025230-16-12699-12805</p><ul><li>⏱ 2023-06-26 09:58:40</li></ul></li></ul><h2 id="12-博弈论-作为一个“弱鸡”，我如何在这个弱肉强食的世界活下去？"><a href="#12-博弈论-作为一个“弱鸡”，我如何在这个弱肉强食的世界活下去？" class="headerlink" title="12 博弈论 作为一个“弱鸡”，我如何在这个弱肉强食的世界活下去？"></a>12 博弈论 作为一个“弱鸡”，我如何在这个弱肉强食的世界活下去？</h2><ul><li><p>📌 捷径只是求之不得的人对别人暗自努力的误解，以及为自己的不努力画的一个大饼。 ^3300025230-17-8862-8899</p><ul><li>⏱ 2023-06-28 19:53:17</li></ul></li><li><p>📌 知识的积累未必能立即得到应用，但是知识会给你应对一切变化的底气，你不会再怕被淘汰，因为你有让自己变强的能力；不会怕所处的行业被颠覆，因为你有学习新知的能力；不用忍受不喜欢的老板的压榨，因为你有随时再就业的能力；不用依附于任何体系和个人，因为你有独立而自由的灵魂。 ^3300025230-17-9630-9761</p><ul><li>⏱ 2023-06-28 19:54:05</li></ul></li></ul><h2 id="13-锚定效应-为什么总是找不到比初恋更好的男朋友呢？"><a href="#13-锚定效应-为什么总是找不到比初恋更好的男朋友呢？" class="headerlink" title="13 锚定效应 为什么总是找不到比初恋更好的男朋友呢？"></a>13 锚定效应 为什么总是找不到比初恋更好的男朋友呢？</h2><ul><li><p>📌 锚定效应在情感上也同样适用，当一个女生的初恋男友非常优秀的时候，她大概率会晚婚。因为她对男性的判断往往来自初恋男友，初恋男友变成了她找男朋友的锚定效应。 ^3300025230-19-3907-3983</p><ul><li>⏱ 2023-06-29 09:19:41</li></ul></li><li><p>📌 期望是对自己或他人的一种判断，希望自己或他人达到某种目标或满足某种行为预期。由期望而产生的行为结果就是期望效应，又称“皮格马利翁效应”。一定程度上，人的预期就相当于锚沉没的深度，预期越高，锚沉得越深，锚定效应也会越明显。 ^3300025230-19-7041-7151</p><ul><li>⏱ 2023-06-29 09:23:01</li></ul></li></ul><h2 id="14-损失厌恶-有了美满的婚姻，却一直放不下前任，怎么办？"><a href="#14-损失厌恶-有了美满的婚姻，却一直放不下前任，怎么办？" class="headerlink" title="14 损失厌恶 有了美满的婚姻，却一直放不下前任，怎么办？"></a>14 损失厌恶 有了美满的婚姻，却一直放不下前任，怎么办？</h2><ul><li>📌 这就叫损失厌恶（loss aversion），是指人们面对同样数量的收益和损失时，认为损失更加令他们难以忍受。同量的损失带来的负效用为同量收益的正效用的2.5倍。 ^3300025230-20-1773-1854<ul><li>⏱ 2023-06-29 09:24:39</li></ul></li></ul><h2 id="15-柠檬市场-我这么优秀，为什么还是剩下了？"><a href="#15-柠檬市场-我这么优秀，为什么还是剩下了？" class="headerlink" title="15 柠檬市场 我这么优秀，为什么还是剩下了？"></a>15 柠檬市场 我这么优秀，为什么还是剩下了？</h2><ul><li><p>📌 情感专家分析，婚姻择偶中，女性普遍有一个“45度”向上择偶的要求，就是希望男性对象无论从年龄、学历还是收入都高出女性一个阶梯。这就带来了信息的错位，最终优秀的女生反而无法找到符合自己期望的男性。 ^3300025230-21-6129-6226</p><ul><li>⏱ 2023-07-07 16:46:18</li></ul></li><li><p>📌 城市是女生的堡垒 ^3300025230-21-6587-6595</p><ul><li>⏱ 2023-07-07 16:46:45</li></ul></li></ul><h2 id="16-次优选择-等了30年，只想找到最完美的心灵伴侣，我错了吗？"><a href="#16-次优选择-等了30年，只想找到最完美的心灵伴侣，我错了吗？" class="headerlink" title="16 次优选择 等了30年，只想找到最完美的心灵伴侣，我错了吗？"></a>16 次优选择 等了30年，只想找到最完美的心灵伴侣，我错了吗？</h2><ul><li><p>📌 诗人徐志摩说的：我将于茫茫人海中，访我唯一灵魂之伴侣。 ^3300025230-22-1363-1390</p><ul><li>⏱ 2023-07-07 16:49:11</li></ul></li><li><p>📌 “人无千日好，花无百日红” ^3300025230-22-5832-5845</p><ul><li>⏱ 2023-07-10 10:44:34</li></ul></li><li><p>📌 生活犹如小径交叉的花园，究竟哪条路最终能通向芬芳的玫瑰圃，没有走过的人谁也不知道答案。 ^3300025230-22-9182-9225</p><ul><li>⏱ 2023-07-25 22:45:54</li></ul></li></ul><h2 id="18-幸福经济学-金钱能买到幸福吗？"><a href="#18-幸福经济学-金钱能买到幸福吗？" class="headerlink" title="18 幸福经济学 金钱能买到幸福吗？"></a>18 幸福经济学 金钱能买到幸福吗？</h2><ul><li>📌 简单讲，当收入低于一定水平，无法覆盖生活费用时，无论怎样喝“心灵鸡汤”，人们都会感受到强烈的不安全和焦虑感。而在这种负面情绪下，人们不可能感受到幸福。 ^3300025230-25-2597-2672<ul><li>⏱ 2023-07-25 23:55:23</li></ul></li></ul><h2 id="19-美貌经济学-长得好看能当饭吃吗？"><a href="#19-美貌经济学-长得好看能当饭吃吗？" class="headerlink" title="19 美貌经济学 长得好看能当饭吃吗？"></a>19 美貌经济学 长得好看能当饭吃吗？</h2><ul><li>📌 雇用一个员工所付出的成本不仅仅取决于支付给这个员工的工资（显性成本），还和同事的幸福程度有关（隐性成本）。新员工越难相处，工作环境越差，同事的幸福程度就越低。相应地，公司就需要提高工资来抵消员工的不满意，以留住人才，从而间接地提高了雇用新员工的成本。 ^3300025230-26-5919-6044<ul><li>⏱ 2023-07-26 11:20:07</li></ul></li></ul><h2 id="20-叙事经济学-倾家荡产疯狂追星是不是特别无理性？"><a href="#20-叙事经济学-倾家荡产疯狂追星是不是特别无理性？" class="headerlink" title="20 叙事经济学 倾家荡产疯狂追星是不是特别无理性？"></a>20 叙事经济学 倾家荡产疯狂追星是不是特别无理性？</h2><ul><li><p>📌 这种观念在第二次世界大战后的经济复兴运动中又被新的“消费主义”宣传所取代，目的是促进更多的消费和就业，从而达到战后迅速复苏经济的目标。 ^3300025230-27-7935-8002</p><ul><li>⏱ 2023-08-01 22:41:18</li></ul></li><li><p>📌 如果你想造一艘船，你先要做的不是催促人们去收集木材，也不是忙着分配工作和发布命令，而是激起他们对浩瀚无垠的大海的向往。 ^3300025230-27-9485-9544</p><ul><li>⏱ 2023-08-01 22:42:37</li></ul></li></ul><h2 id="26-投资之入门理论-想学投资发现理论都看不懂怎么办？"><a href="#26-投资之入门理论-想学投资发现理论都看不懂怎么办？" class="headerlink" title="26 投资之入门理论 想学投资发现理论都看不懂怎么办？"></a>26 投资之入门理论 想学投资发现理论都看不懂怎么办？</h2><ul><li>📌 从事着高风险的投资，没有遇到过风险，还获得了不菲的收益，这固然是好事，只是不要把这个当作理所当然，更不要把运气当作能力，因为绝大多数情况下，你只是被概率所选中，恰巧坐上这条未翻的船。 ^3300025230-35-10126-10217<ul><li>⏱ 2023-08-07 22:54:04</li></ul></li></ul><h2 id="27-风口-埋头走路与抬头看天，哪个更重要？"><a href="#27-风口-埋头走路与抬头看天，哪个更重要？" class="headerlink" title="27 风口 埋头走路与抬头看天，哪个更重要？"></a>27 风口 埋头走路与抬头看天，哪个更重要？</h2><ul><li>📌 过于相信自己的“眼见为实”，执着于通过自己的“眼见为实”得出结论性的意见，这不叫学习能力强，这叫偏见能力强。 ^3300025230-36-9144-9198<ul><li>⏱ 2023-08-08 16:12:56</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>经济理财-理财</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【教程】Obsidian使用及插件推荐</title>
    <link href="/2022/10/30/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Obsidian%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <url>/2022/10/30/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Obsidian%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h1 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h1><h2 id="文件设置"><a href="#文件设置" class="headerlink" title="文件设置"></a>文件设置</h2><p>仓库“记录”存放在e:&#x2F;notes&#x2F;obsidian文件夹中<br>在.obsidian子文件夹中，有三个文件夹：<img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917003658.png" alt="image.png|122"><br>    1.  plugins存放插件<br>        1. 官方第三方插件库下载的插件存放于此<br>        2. 自己下载的插件文件夹放在此文件夹就可以在Obsidian中打开<br>            1. 需要有以下三个文件<img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917003936.png" alt="image.png|143"><br>    2.  snippets存放.css文件，用于自己diy<br>        1. code-block.css：设置代码块的字体大小及行间距<br>        2. code-lines.css：设置代码块显示行数<br>    3.   themes存放主题文件</p><h2 id="设置图床"><a href="#设置图床" class="headerlink" title="设置图床"></a>设置图床</h2><ol><li>腾讯云设置cos对象存储</li><li>新建存储桶<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917005433.png" alt="image.png|900"></li><li>访问权限设置成“公有读私有写”<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917005556.png" alt="image.png|625"></li><li>剩下的高级可选配置和确认配置不需要动，默认即可<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917005643.png" alt="image.png|600"></li><li>在“存储桶列表”中，确定存储桶名称<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917005737.png" alt="image.png|245"></li><li>下载PicGo软件，进行设置<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917010026.png" alt="image.png|700"><ol><li>COS版本选择“V5”</li><li>腾讯云右上用户-访问管理<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917010221.png" alt="image.png|220"></li><li>访问密钥-API密钥管理<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917010310.png" alt="image.png|214"></li><li>确定APPID、SecretId、SecretKey<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917010400.png" alt="image.png|500"></li><li>Bucket是存储桶名称</li><li>存储区域是ap-地区</li><li>存储路径在腾讯云COS对应存储桶中设置文件列表<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917010559.png" alt="image.png|675"><br> 需要注意是如果设置了文件夹，后面需要加&#x2F;符号</li></ol></li><li>PicGo设置好后，在Obsidian安装Image auto upload Plugin<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917010823.png" alt="image.png|252"><br> 选项-设置-PicGo(app)就好</li></ol><h2 id="设置云同步"><a href="#设置云同步" class="headerlink" title="设置云同步"></a>设置云同步</h2><p><a href="https://zhuanlan.zhihu.com/p/479961754">【ios福音】obsidian第三方同步方案(remotely插件+腾讯云cos)-保姆级教程 - 知乎</a> </p><h2 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h2><p>安装字体<br>1.<a href="https://fonts.alibabagroup.com/#/font">阿里巴巴普惠体</a><br>2.<a href="https://github.com/lxgw/LxgwWenKai">GitHub - lxgw&#x2F;LxgwWenKai: An open-source Chinese font derived from Fontworks’ Klee One. 一款开源中文字体，基于 FONTWORKS 出品字体 Klee One 衍生。</a><br>如果设置-外观-字体，找不到想要换的字体，可以手动输入</p><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><ol><li>在文件中新建链接，使用两个[]符号，自动弹出选项[[]]<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917004413.png" alt="image.png|325"></li></ol><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ol><li>open in new tab<ol><li>插件功能：点击链接在新页面打开，obsidian默认是在原标签页下打开</li></ol></li><li>advanced tables<ol><li>插件功能：创建表格及其操作</li><li>|+tab键新建表格</li><li>表内换行使用</br></li></ol></li><li>task <ol><li>插件功能：新建任务列表</li></ol></li><li>remember cursor position<ol><li>插件功能：记住上次鼠标在文件的位置</li></ol></li><li>editing toolbar<ol><li>插件功能：新增菜单栏，快速设置文本样式<img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917004537.png" alt="image.png"></li></ol></li><li>auto link title<ol><li>插件功能：自动获取url的title</li></ol></li><li>excalidraw<ol><li>插件功能：手绘风格画板</li><li>设置：<ol><li>下载中文手写字体 <a href="https://www.fonts.net.cn/font-35068393713.html">沐瑶软笔手写体字体免费下载和在线预览-字体天下</a> </li><li>将字体文件放在文件目录下，ob_setting&#x2F;fonts<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/Pasted%20image%2020230915151426.png" alt="Pasted image 20230915151426|500"></li><li>在插件设置中选择本地字体文件，可以自定义画笔数量</li><li>新建画布，在文本输入模型下，左下角设置字体字号</li></ol></li><li><a href="https://www.uncoverman.com/excalidraw-plguin-in-obsidian-support-font-custom.html">Obsidian 的 Excalidraw 插件自定义中文字体</a></li></ol></li><li>Image auto upload Plugin<ol><li>插件功能：与PicGo配合自动上传图片</li><li>使用：<ol><li>一般默认自动上传</li><li>手动的话是：Ctrl+P，输入auto<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20230917011030.png" alt="image.png|500"></li></ol></li></ol></li><li>File Explorer Note Count<ol><li>插件功能：统计文件夹里的笔记数目</li></ol></li><li>enchance editing<ol><li>插件功能：增加很多方便的快捷键设置</li><li>需要自己手动安装 <a href="https://github.com/obsidian-canzi/Enhanced-Editing-legacy-version">GitHub - obsidian-canzi&#x2F;Enhanced-Editing-legacy-version: A plugin for Obsidian.md (ZH增强编辑插件)</a></li></ol></li><li>Minimal Theme Settings<ol><li>插件功能：自己调Minimal主题</li></ol></li><li>Mousewheel Image Zoom<ol><li>插件功能：按shift加滚轮调整图片大小，shift是自己设置的</li></ol></li><li>Enhancing Mindmap<ol><li>插件功能：右键可以新建思维导图</li></ol></li><li>full calendar<ol><li>插件功能：新建日志log方便</li></ol></li><li>weread plugin<ol><li>插件功能：同步微信读书数据</li></ol></li><li>remotely save<ol><li>插件功能：云同步</li></ol></li><li>RSS reader<ol><li>插件功能：RSS 订阅</li></ol></li><li>kanban<ol><li>插件功能：看板</li></ol></li><li>dataview</li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习】JavaWeb学习日志</title>
    <link href="/2022/06/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9F%A9%E9%A1%BA%E5%B9%B3JavaWeb/"/>
    <url>/2022/06/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9F%A9%E9%A1%BA%E5%B9%B3JavaWeb/</url>
    
    <content type="html"><![CDATA[<h1 id="1-B-S软件开发架构简述"><a href="#1-B-S软件开发架构简述" class="headerlink" title="1.B&#x2F;S软件开发架构简述"></a>1.B&#x2F;S软件开发架构简述</h1><h2 id="1-1-Java-Web-技术体系图"><a href="#1-1-Java-Web-技术体系图" class="headerlink" title="1.1 Java Web 技术体系图"></a>1.1 Java Web 技术体系图</h2><ol><li>浏览器 B<br> 1. </li><li>服务器 S<ol><li>Tomcat + Nginx (web服务器 + 容器)<ol><li>web服务<ol><li>解析HTTP请求</li><li>做相应处理，比如调用对应的servlet或者返回对应的页面</li></ol></li><li>容器<ol><li>java</li><li>servlet</li><li>html</li><li>…</li></ol></li></ol></li><li>数据库 DB</li></ol></li><li>后端技术栈<ol><li>java基础</li><li>servlet + javabean (接收用户请求)</li><li>spring、spring MVC、mybatis、mybatis-plus &#x3D;&gt; SSM框架</li><li>springboot、spring cloud、spring cloud alibaba</li><li>rabbitMQ、rocketMQ</li><li>数据库</li></ol></li></ol><h1 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2.HTML"></a>2.HTML</h1><h2 id="2-6-HTML-标签"><a href="#2-6-HTML-标签" class="headerlink" title="2.6 HTML 标签"></a>2.6 HTML 标签</h2><h3 id="2-6-14-表单-form"><a href="#2-6-14-表单-form" class="headerlink" title="2.6.14 表单 form"></a>2.6.14 表单 form</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&#x27;url&#x27;</span> <span class="hljs-attr">method</span> =<span class="hljs-string">*</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>action：提交的服务器地址&#x2F;资源</li><li>method：提交方式，默认GET POST<ol><li>GET<ol><li>浏览器地址栏的地址是：action 属性[+?+请求参数]</li><li>请求参数格式是：name&#x3D;value&amp;name&#x3D;value</li><li>不安全</li><li>数据长度有限制，一般2k</li></ol></li><li>POST<ol><li>浏览器地址栏只有 action 属性值</li><li>提交的数据携带在 HTTP 请求中</li><li>相较于GET安全</li><li>理论上没有数据长度限制</li></ol></li></ol></li></ol><h1 id="3-CSS"><a href="#3-CSS" class="headerlink" title="3.CSS"></a>3.CSS</h1><h1 id="4-JavaScript"><a href="#4-JavaScript" class="headerlink" title="4.JavaScript"></a>4.JavaScript</h1><h1 id="5-DOM"><a href="#5-DOM" class="headerlink" title="5.DOM"></a>5.DOM</h1><h1 id="6-XML"><a href="#6-XML" class="headerlink" title="6.XML"></a>6.XML</h1><h2 id="6-3-XML-技术用于解决什么问题"><a href="#6-3-XML-技术用于解决什么问题" class="headerlink" title="6.3 XML 技术用于解决什么问题"></a>6.3 XML 技术用于解决什么问题</h2><ol><li>xml技术解决程序间数据传输的问题：&#x3D;&gt; json<ol><li>比如 qq 之间的数据传送，用 xml 格式来传送数据，具有良好的可读性，可维护性。</li></ol></li><li>xml 可以做配置文件</li><li>xml 可以充当小型的数据库 &#x3D;&gt; 程序自己的数据格式存放</li></ol><h2 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h2><ol><li>一个 XML 文件分为如下几部分内容<ol><li>文档声明</li><li>元素</li><li>属性</li><li>注释</li><li>CDATA区、特殊字符</li></ol></li><li>文档声明<ol><li><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code></li><li>xml声明放在xml文档第一行</li><li>version 文档规范</li><li>encoding 文档字符编码</li></ol></li><li>元素<ol><li>每个XML文档必须有且只有一个根元素</li><li>根元素是一个完全包括文档中其他所有元素的元素。</li><li>根元素的起始标记要放在所有其他元素的起始标记之前。</li><li>根元素的结束标记要放在所有其他元素的结束标记之后。</li><li>XML元素命名规制<ol><li>区分大小写，例如，&lt;P&gt;和&lt;p&gt;是两个不同的标记。</li><li>不能以数字开头。</li><li>不能包含空格。</li><li>名称中间不能包含冒号（:）。</li><li>如果标签单词需要间隔，建议使用下划线 比如 <book_title>hello&lt;&#x2F;book_title&gt;</li></ol></li></ol></li><li>属性<ol><li>属性值用双引号（”）或单引号（’）分隔（如果属性值中有’，用”分隔；有”，用’分隔）</li><li>一个元素可以有多个属性，它的基本格式为：&lt;元素名 属性名&#x3D;”属性值”&gt;</li><li>特定的属性名称在同一个元素标记中只能出现一次</li><li>属性值不能包括&amp; 字符</li></ol></li><li>CDATA节<ol><li>有些内容不想让解析引擎执行，而是当作原始内容处理(即当做普通文本)，可以使用 CDATA 包括起来，CDATA 节中的所有字符都会被当作简单文本，而不是 XML 标记</li><li>语法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;![CDATA[<br>这里可以把你输入的字符原样显示，不会解析 xml<br>]]&gt;<br></code></pre></td></tr></table></figure></li></ol></li><li>可以输入任意字符（除]]&gt;外）</li><li>不能嵌套</li></ol><h2 id="6-6-转义字符"><a href="#6-6-转义字符" class="headerlink" title="6.6 转义字符"></a>6.6 转义字符</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240419110916.png" alt="image.png|232"></p><h2 id="6-8-DOM4j"><a href="#6-8-DOM4j" class="headerlink" title="6.8 DOM4j"></a>6.8 DOM4j</h2><h3 id="6-8-2-XML-解析技术原理"><a href="#6-8-2-XML-解析技术原理" class="headerlink" title="6.8.2 XML 解析技术原理"></a>6.8.2 XML 解析技术原理</h3><ol><li>不管是 html 文件还是 xml 文件它们都是标记型文档，都可以使用 w3c 组织制定的dom 技术来解析</li><li>document 对象表示的是整个文档（可以是 html 文档，也可以是 xml 文档）</li><li>DOM将XML文档作为一个树形结构，树叶被定义为节点</li></ol><h3 id="6-8-3-XML-解析技术介绍"><a href="#6-8-3-XML-解析技术介绍" class="headerlink" title="6.8.3 XML 解析技术介绍"></a>6.8.3 XML 解析技术介绍</h3><ol><li>jdom 在 dom 基础上进行了封装</li><li>dom4j 又对 jdom 进行了封装。</li></ol><h3 id="6-8-4-DOM4J-介绍"><a href="#6-8-4-DOM4J-介绍" class="headerlink" title="6.8.4 DOM4J 介绍"></a>6.8.4 DOM4J 介绍</h3><ol><li>Dom4j 是一个简单、灵活的开放源代码的库(用于解析&#x2F;处理 XML 文件)</li><li>使用 Dom4j 开发，需下载 dom4j 相应的 jar 文件</li><li>获得Document对象的方式有三种<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式1 读取 XML 文件,获得 document 对象</span><br><span class="hljs-type">SAXReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>(); <span class="hljs-comment">//创建一个解析器</span><br><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> reader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/input.xml&quot;</span>));<span class="hljs-comment">//XML Document</span><br><span class="hljs-comment">// 方式2 解析 XML 形式的文本,得到 document 对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;members&gt;&lt;/members&gt;&quot;</span>;<br><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> DocumentHelper.parseText(text);<br><span class="hljs-comment">// 方式3 主动创建 document 对象</span><br><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> DocumentHelper.createDocument(); <span class="hljs-comment">//创建根节点</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> document.addElement(<span class="hljs-string">&quot;members&quot;</span>);<br></code></pre></td></tr></table></figure>P303</li></ol><h1 id="7-Tomcat"><a href="#7-Tomcat" class="headerlink" title="7.Tomcat"></a>7.Tomcat</h1><h2 id="7-2-WEB-开发介绍"><a href="#7-2-WEB-开发介绍" class="headerlink" title="7.2 WEB 开发介绍"></a>7.2 WEB 开发介绍</h2><ol><li>WEB服务器（主机）上供外界访问的Web资源分为<ol><li>静态资源：HTML，浏览的数据始终不变</li><li>动态资源：servlet、php等</li></ol></li></ol><h2 id="7-6-Tomcat"><a href="#7-6-Tomcat" class="headerlink" title="7.6 Tomcat"></a>7.6 Tomcat</h2><h3 id="7-6-4-Tomcat目录结构"><a href="#7-6-4-Tomcat目录结构" class="headerlink" title="7.6.4 Tomcat目录结构"></a>7.6.4 Tomcat目录结构</h3><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240419150604.png" alt="image.png|500"></p><ol><li>server.xml 用于配置 tomcat 的基本设置(启动端口，关闭端口, 主机名)</li><li>wex.xml 用于指定 tomcat 运行时配置(比如 servlet 等..)</li><li>webapps 目录是存放 web 应用，就是网站</li></ol><h3 id="7-6-8-Tomcat-服务中部署-WEB-应用"><a href="#7-6-8-Tomcat-服务中部署-WEB-应用" class="headerlink" title="7.6.8 Tomcat 服务中部署 WEB 应用"></a>7.6.8 Tomcat 服务中部署 WEB 应用</h3><ol><li>web应用组成<ol><li>一个 WEB 应用由多个 WEB 资源或其它文件组成，包括 html 文件、css 文件、js 文件、动态 web 页面、java 程序、支持 jar 包、配置文件等</li><li>开发人员在开发 web 应用时，按照规定目录结构存放这些文件。否则，在把 web 应用交给 web 服务器管理时，不仅可能会使web 应用无法访问，还会导致 web 服务器启动报错。</li></ol></li><li>javaweb工程目录结构<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240419150832.png" alt="image.png|437"></li><li>部署方式1：将web 工程的目录拷贝到 Tomcat 的 webapps 目录下<ol><li>news Web工程(目前都是静态资源 html, 图片)</li><li>将该news目录&#x2F;文件夹 拷贝到 Tomcat 的webapps目录下</li><li>浏览器输入： <a href="http://ip[域名]:port/news/子目录../文件名">http://ip[域名]:port/news/子目录../文件名</a></li></ol></li><li>部署方式2：通过配置文件来部署</li></ol><h2 id="7-7-IDEA-开发-JavaWeb-工程"><a href="#7-7-IDEA-开发-JavaWeb-工程" class="headerlink" title="7.7 IDEA 开发 JavaWeb 工程"></a>7.7 IDEA 开发 JavaWeb 工程</h2><h1 id="8-Servlet"><a href="#8-Servlet" class="headerlink" title="8.Servlet"></a>8.Servlet</h1><h2 id="8-3-什么是Servlet"><a href="#8-3-什么是Servlet" class="headerlink" title="8.3 什么是Servlet"></a>8.3 什么是Servlet</h2><ol><li>Servlet(基石)是 SpringMVC 的基础</li><li>Servlet(java 服务器小程序)，它的特点:<ol><li>由服务器端调用和执行的(一句话：是Tomcat解析和执行)</li><li>用java语言编写的, 本质就是Java类</li><li>按照Servlet规范开发的(除了tomcat-&gt;Servlet weblogic-&gt;Servlet)</li><li>Servlet是常驻内存</li><li>单例</li></ol></li></ol><h2 id="8-5-Servlet-基本使用"><a href="#8-5-Servlet-基本使用" class="headerlink" title="8.5 Servlet 基本使用"></a>8.5 Servlet 基本使用</h2><ol><li>servlet3.0 前使用 web.xml , servlet3.0 版本以后(包括 3.0)支持注解， 同时支持 web.xml配置</li><li>导入servlet-api.jar</li><li>实现servletRequest接口<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420102442.png" alt="image.png"></li><li>配置web.xml<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420103014.png" alt="image.png"></li></ol><h3 id="8-5-4-Servlet生命周期"><a href="#8-5-4-Servlet生命周期" class="headerlink" title="8.5.4 Servlet生命周期"></a>8.5.4 Servlet生命周期</h3><ol><li>主要有三个方法<ol><li>init()初始化阶段</li><li>service()处理浏览器请求阶段</li><li>destroy()终止阶段</li></ol></li><li>初始化阶段<ol><li>Servlet 容器(比如: Tomcat)加载 Servlet，加载完成后，Servlet 容器会创建一个 Servlet 实例并调用 init()方法，init()方法只会调用一次, Servlet 容器在下面的情况装载 Servlet：</li><li>Servlet 容器(Tomcat)启动时自动装载某些 servlet，实现这个需要在 web.xml 文件中添加&lt;load-on-startup&gt;1</load-on-startup>1 表示装载的顺序</li><li>在 Servlet 容器启动后，浏览器首次向 Servlet 发送请求</li><li>Servlet 重新装载时(比如 tomcat 进行 redeploy【redeploy 会销毁所有的 Servlet 实例】)，浏览器再向 Servlet 发送请求的第 1 次</li></ol></li><li>处理浏览器请求阶段(service 方法)<ol><li>每收到一个 http 请求，服务器就会产生一个新的线程去处理</li><li>创建一个用于封装 HTTP 请求消息的 ServletRequest 对象和一个代表 HTTP 响应消息的ServletResponse 对象</li><li>然后调用 Servlet 的 service()方法并将请求和响应对象作为参数传递进去</li></ol></li><li>终止阶段 destory 方法<ol><li>当web 应用被终止，或者Servlet 容器终止运行，或者Servlet 类重新装载时，会调用 destroy()</li></ol></li></ol><h3 id="8-5-5-GET-和-POST-请求的分发处理"><a href="#8-5-5-GET-和-POST-请求的分发处理" class="headerlink" title="8.5.5 GET 和 POST 请求的分发处理"></a>8.5.5 GET 和 POST 请求的分发处理</h3><ol><li>小技巧：ctrl_alt_b可以查看子接口</li></ol><h3 id="8-5-6-通过继承-HttpServlet-开发-Servlet"><a href="#8-5-6-通过继承-HttpServlet-开发-Servlet" class="headerlink" title="8.5.6 通过继承 HttpServlet 开发 Servlet"></a>8.5.6 通过继承 HttpServlet 开发 Servlet</h3><ol><li>在实际项目中，都是使用继承 HttpServlet 类开发 Servlet 程序，更加方便</li><li>HttpServlet 介绍<ol><li>通过继承 HttpServlet 开发一个 HiServlet</li><li>当浏览器 访问 <a href="http://localhost:8080/web">http://localhost:8080/web</a> 应用名&#x2F;hiServlet 时，后台输出 “hi HiServelt”</li></ol></li><li>具体的开发步骤<ol><li>编写一个类去继承 HttpServlet 类</li><li>根据业务需要重写 doGet 或 doPost 方法</li><li>到 web.xml 中的配置 Servlet 程序</li></ol></li></ol><h3 id="8-5-8-Servlet-注意事项和细节"><a href="#8-5-8-Servlet-注意事项和细节" class="headerlink" title="8.5.8 Servlet 注意事项和细节"></a>8.5.8 Servlet 注意事项和细节</h3><ol><li>Servlet 是一个供其他 Java 程序（Servlet 引擎）调用的 Java 类，不能独立运行</li><li>针对浏览器的多次 Servlet 请求，通常情况下，服务器只会创建一个 Servlet 实例对象，也就是说 Servlet 实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web 容器退出&#x2F;或者 redeploy 该 web 应用，servlet 实例对象才会销毁</li><li>在 Servlet 的整个生命周期内，init 方法只被调用一次。而对每次请求都导致 Servlet 引擎调用一次 servlet 的 service 方法</li><li>对于每次访问请求，Servlet 引擎都会创建一个新的 HttpServletRequest 请求对象和一个新的 HttpServletResponse 响应对象，然后将这两个对象作为参数传递给它调用的 Servlet的 service()方法，service 方法再根据请求方式分别调用 doXXX 方法</li><li>如果在&lt;servlet&gt;元素中配置了一个&lt;load-on-startup&gt;元素，那么 WEB 应用程序在启动时，就会装载并创建 Servlet 的实例对象、以及调用 Servlet 实例对象的 init()方法</li></ol><h2 id="8-6-Servlet-注解方式"><a href="#8-6-Servlet-注解方式" class="headerlink" title="8.6 Servlet - 注解方式"></a>8.6 Servlet - 注解方式</h2><ol><li>类继承HttpServlet</li><li>@WebServlet(urlPatterns &#x3D; {“&#x2F;ok1, &#x2F;ok2”})</li><li>重写doPost、doGet</li><li>注解是对包进行扫描，如果发现某个类是WebServlet修饰的，说明该类是Servlet，读取urlPattern的值</li></ol><h3 id="8-6-2-Servlet-urlPattern-配置"><a href="#8-6-2-Servlet-urlPattern-配置" class="headerlink" title="8.6.2 Servlet urlPattern 配置"></a>8.6.2 Servlet urlPattern 配置</h3><ol><li>精确匹配<ol><li>配置路径 : @WebServlet(“&#x2F;ok&#x2F;zs”)</li><li>访问 servlet: localhost:8080&#x2F;servlet&#x2F;ok&#x2F;zs</li></ol></li><li>目录匹配<ol><li>配置路径 : @WebServlet(“&#x2F;ok&#x2F;*”)</li><li>访问文件: localhost:8080&#x2F;servlet&#x2F;ok&#x2F;aaa localhost:8080&#x2F;servlet&#x2F;ok&#x2F;bbb</li></ol></li><li>扩展名匹配<ol><li>配置路径 : @WebServlet(“*.action”)</li><li>访问文件: localhost:8080&#x2F;hsp&#x2F;zs.action localhost:8080&#x2F;hsp&#x2F;ls.action</li><li>@WebServlet(“&#x2F;*.action”) , 不能带 &#x2F; , 否则 tomcat 报错</li></ol></li><li>任意匹配<ol><li>配置路径 : @WebServlet(“&#x2F;“) @WebServlet(“&#x2F;*“)</li><li>访问文件: localhost:8080&#x2F;hsp&#x2F;aaa localhost:8080&#x2F;hsp&#x2F;bbb</li></ol></li></ol><h3 id="注意事项和使用细节"><a href="#注意事项和使用细节" class="headerlink" title="注意事项和使用细节"></a>注意事项和使用细节</h3><ol><li>当 Servlet 配置了 “&#x2F;“, 会覆盖 tomcat 的 DefaultServlet, 当其他的 utl-pattern 都匹配不 上 时 ， 都 会 走 这 个 Servlet, 这 样 可 以 拦 截 到 其 它 静 态 资 源<ol><li>查看：tomcat&#x2F;conf&#x2F;web.xml , 配置的 DefaultServlet</li></ol></li><li>优先级遵守: 精确路径 &gt; 目录路径 &gt; 扩展名路径 &gt; &#x2F;* &gt; &#x2F;</li></ol><h2 id="8-8-关联篇：HTTP-协议！！"><a href="#8-8-关联篇：HTTP-协议！！" class="headerlink" title="8.8 关联篇：HTTP 协议！！"></a>8.8 关联篇：HTTP 协议！！</h2><h2 id="8-9-ServletConfig"><a href="#8-9-ServletConfig" class="headerlink" title="8.9 ServletConfig"></a>8.9 ServletConfig</h2><ol><li>ServletConfig 类是为 Servlet 程序的配置信息的类</li><li>Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建</li><li>Servlet 程序默认是第 1 次访问的时候创建，ServletConfig 在 Servlet 程序创建时，就创建一个对应的 ServletConfig 对 象</li><li>ServletConfig 类能干什么<ol><li>获取 Servlet 程序的 servlet-name 的值</li><li>获取初始化参数 init-param</li><li>获取 ServletContext 对象</li></ol></li></ol><h2 id="8-10-ServletContext"><a href="#8-10-ServletContext" class="headerlink" title="8.10 ServletContext"></a>8.10 ServletContext</h2><ol><li>ServletContext 是一个接口，它表示 Servlet 上下文对象</li><li>. 一个 web 工程，只有一个 ServletContext 对象实例</li><li>ServletContext 对象 是在 web 工程启动的时候创建，在 web 工程停止的时销毁</li><li>ServletContext 对象可以通过 ServletConfig.getServletContext 方法获得对 ServletContext对象的引用，也可以通过 this.getServletContext()来获得其对象的引用。</li><li>由于一个 WEB 应用中的所有 Servlet 共享同一个 ServletContext 对象，因此 Servlet 对象之间可以通过 ServletContext 对象来实现多个 Servlet 间通讯。ServletContext 对象通常也被称之为域对象。<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420181055.png" alt="image.png|475"></li><li>ServletContext 可以做什么<ol><li>获取 web.xml 中配置的上下文参数 context-param [信息和整个 web 应用相关，而不是属于某个 Servlet]</li><li>获取当前的工程路径，格式: &#x2F;工程路径 &#x3D;》 比如 &#x2F;servlet</li><li>获取工程部署后在服务器硬盘上的绝对路径(比如 :D:\hspedu_javaweb\servlet\out\artifacts\servlet_war_exploded)</li><li>像 Map 一样存取数据, 多个 Servlet 共享数据</li></ol></li></ol><h2 id="8-11-HttpServletRequest"><a href="#8-11-HttpServletRequest" class="headerlink" title="8.11 HttpServletRequest"></a>8.11 HttpServletRequest</h2><ol><li>HttpServletRequest 介绍<ol><li>HttpServletRequest 对象代表客户端的请求</li><li>当客户端&#x2F;浏览器通过 HTTP 协议访问服务器时，HTTP 请求头中的所有信息都封装在这个对象中</li><li>通过这个对象的方法，可以获得客户端这些信息</li></ol></li></ol><h3 id="8-11-3-HttpServletRequest-常用方法"><a href="#8-11-3-HttpServletRequest-常用方法" class="headerlink" title="8.11.3 HttpServletRequest 常用方法"></a>8.11.3 HttpServletRequest 常用方法</h3><ol><li>getRequestURI() 获取请求的资源路径 &#x2F;<a href="http://localhost:8080/">http://localhost:8080</a><font color="#6425d0">&#x2F;servlet&#x2F;loginServlet</font></li><li>getRequestURL() 获 取 请 求 的 统 一 资 源 定 位 符 （ 绝 对 路 径 ）<font color="#6425d0"><a href="http://localhost:8080/servlet/loginServlet">http://localhost:8080/servlet/loginServlet</a></font></li><li>getRemoteHost() 获取客户端的 主机, getRemoteAddr()</li><li>. getHeader() 获取请求头</li><li>getParameter() 获取请求的参数</li><li>getParameterValues() 获取请求的参数（多个值的时候使用） , 比如 checkbox, 返回的数组</li><li>getMethod() 获取请求的方式 GET 或 POST</li><li>setAttribute(key, value); 设置域数据</li><li>getAttribute(key); 获取域数据</li><li>getRequestDispatcher() 获取请求转发对象, 请求转发的核心对象</li></ol><h3 id="8-11-7-请求转发"><a href="#8-11-7-请求转发" class="headerlink" title="8.11.7 请求转发"></a>8.11.7 请求转发</h3><ol><li>实现请求转发：请求转发指一个 web 资源收到客户端请求后，通知服务器去调用另外一个 web 资源进行处理</li><li>HttpServletRequest 对象(也叫 Request 对象)提供了一个 getRequestDispatcher 方法，该方法返回一个 RequestDispatcher 对象，调用这个对象的 forward 方法可以实现请求转发</li><li>request 对象同时也是一个域对象，开发人员通过 request 对象在实现转发时，把数据通过 request 对象带给其它 web 资源处理<ol><li>setAttribute方法</li><li>getAttribute方法</li><li>removeAttribute方法</li><li>getAttributeNames方法</li></ol></li><li>请求转发注意事项和细节<ol><li>浏览器地址不会变化(地址会保留在第 1 个 servlet 的 url)</li><li>在同一次 HTTP 请求中，进行多次转发，仍然是一次 HTTP 请求</li><li>在同一次 HTTP 请求中，进行多次转发，多个 Servlet 可以共享 request 域&#x2F;对象的数据(因为始终是同一个 request 对象)</li><li>可以转发到 WEB-INF 目录下(后面做项目使用)</li><li>不能访问当前 WEB 工程外的资源</li><li>因为浏览器地址栏会停止在第一个 servlet ,如果你刷新页面，会再次发出请求(并且会带数据), 所以在支付页面情况下，不要使用请求转发，否则会造成重复支付<br> 8.12 HttpServletResponse</li></ol></li><li>每次 HTTP 请求，Tomcat 会创建一个 HttpServletResponse 对象传递给 Servlet 程序去使用</li><li>HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息，如果需要设置返回给客户端的信息，通过 HttpServletResponse 对象来进行设置即可</li><li>向客户端返回数据方法<ol><li>字节流 getOutputStream(); 常用于下载（处理二进制数据）</li><li>字符流 getWriter(); 常用于回传字符串</li><li>两个流同时只能使用一个。 使用了字节流，就不能再使用字符流，反之亦然</li></ol></li><li>请求重定向注意事项和细节<ol><li>最佳应用场景：网站迁移，比如原域名是 <a href="http://www.hsp.com/">www.hsp.com</a> 迁移到 <a href="http://www.hsp.cn/">www.hsp.cn</a> ，但是百度抓取的还是原来网址</li><li>浏览器地址会发生变化，本质是两次 http 请求.</li><li>不能共享 Request 域中的数据，本质是两次 http 请求，会生成两个 HttpServletRequest对象</li><li>不能重定向到 &#x2F;WEB-INF 下的资源</li><li>可以重定向到 Web 工程以外的资源， 比如 到 <a href="http://www.baidu.com/">www.baidu.com</a></li><li>重定向有两种方式<ol><li><code>resp.sendRedirect(&quot;/servlet&quot;)</code> 推荐</li><li><code>resp.setStatus(302)</code>  <code>resp.setHeader(&quot;Location&quot;,&quot;/servlet&quot;)</code></li></ol></li><li>动态获取到 application context</li></ol></li></ol><h1 id="10-手动实现-Tomcat-底层机制-自己设计-Servlet"><a href="#10-手动实现-Tomcat-底层机制-自己设计-Servlet" class="headerlink" title="10.手动实现 Tomcat 底层机制+ 自己设计 Servlet"></a>10.手动实现 Tomcat 底层机制+ 自己设计 Servlet</h1><h2 id="10-1-Maven"><a href="#10-1-Maven" class="headerlink" title="10.1 Maven"></a>10.1 Maven</h2><h2 id="10-2-Tomcat-整体架构分析"><a href="#10-2-Tomcat-整体架构分析" class="headerlink" title="10.2 Tomcat 整体架构分析"></a>10.2 Tomcat 整体架构分析</h2><ol><li>Tomcat 有三种运行模式（BIO, NIO, APR）, 因为老师核心讲解的是 Tomcat 如何接收客户端请求，解析请求, 调用 Servlet , 并返回结果的机制流程, 采用 BIO 线程模型来模拟.<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240421111307.png" alt="image.png|500"></li></ol><h1 id="11-WEB-工程路径专题"><a href="#11-WEB-工程路径专题" class="headerlink" title="11.WEB 工程路径专题"></a>11.WEB 工程路径专题</h1><h2 id="11-2-工程路径解决方案"><a href="#11-2-工程路径解决方案" class="headerlink" title="11.2 工程路径解决方案"></a>11.2 工程路径解决方案</h2><ol><li>解决方案：相对路径<ol><li>页面所有的相对路径，在默认情况下，都会参考当前浏览器地址栏的路径 <a href="http://ip:port/工程名/">http://ip:port/工程名/</a> + 资源来进行跳转</li><li>如果需要指定页面相对路径参考的的路径，可以使用 base 标签来指定</li></ol></li><li>解决方案：base 标签<ol><li>base 标签是 HTML 语言中的基准网址标记，它是一个单标签，位于网页头部文件的 head标签内</li><li>一个页面最多只能使用一个 base 元素，用来提供一个指定的默认目标，是一种表达路径和连接网址的标记</li><li>常见的 url 路径形式分别有相对路径与绝对路径，如果 base 标签指定了目标，浏览器将通过这个目标来解析当前文档中的所有相对路径，包括的标签有（a、img、link、form）</li><li>浏览器解析时会在路径前加上 base 给的目标，而页面中的相对路径也都转换成了绝对路径。使用了 base 标签就应带上 href 属性和 target 属性</li></ol></li></ol><h2 id="11-3-WEB-工程路径注意事项和细节"><a href="#11-3-WEB-工程路径注意事项和细节" class="headerlink" title="11.3 WEB 工程路径注意事项和细节"></a>11.3 WEB 工程路径注意事项和细节</h2><ol><li>在实际开发中，路径都使用绝对路径，而不是相对路径</li><li>在 javaWeb 中 路径最后带 &#x2F; 和 不带 &#x2F; 含义不同, 一定要小心:<ol><li>比如 &lt;&#x2F;a href&#x3D;”&#x2F;a&#x2F;servlet03”&gt;网址</a> : servlet03 表示资源</li><li>&lt;&#x2F;a href&#x3D;”&#x2F;a&#x2F;servlet03&#x2F;“&gt;网址</a> : servlet03 表示路径</li></ol></li><li>特别说明：重定向 response.sendRediect(“&#x2F;“); 这条语句虽然是在服务器执行的，但是服务器是把斜杠 &#x2F; 发送给浏览器解析。因此得到地址 <a href="http://ip[域名]:port/">http://ip[域名]:port/</a></li></ol><h1 id="9-HTTP协议"><a href="#9-HTTP协议" class="headerlink" title="9.HTTP协议"></a>9.HTTP协议</h1><h2 id="9-7-什么是-HTTP-协议"><a href="#9-7-什么是-HTTP-协议" class="headerlink" title="9.7 什么是 HTTP 协议"></a>9.7 什么是 HTTP 协议</h2><ol><li>超文本传输协议(HTTP，HyperText Transfer Protocol)是工作在 tcp&#x2F;ip 协议基础上的,所有的 WWW 文件都遵守这个标准。</li><li>. http1.0 短连接 http1.1 长连接</li><li>http 是 TCP&#x2F;IP 协议的一个应用层协议,http 也是我们 web 开发的基础</li></ol><h2 id="9-9-页面请求的一个问题"><a href="#9-9-页面请求的一个问题" class="headerlink" title="9.9 页面请求的一个问题"></a>9.9 页面请求的一个问题</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420172554.png" alt="image.png|500"></p><ol><li>当访问 test.html 页面时, 问浏览器发出几次 http 请求?<ol><li>答：一共 3 次</li><li>第一次请求的 test.html当浏览器解析发现 test.html 中有 &lt;img src&#x3D;”imgs&#x2F;1.png” width&#x3D;”300px”&gt;&lt;img src&#x3D;”imgs&#x2F;2.png”&gt;</li><li>会向服务器继续发请求，要 1.png 和 2.png, 一共 3 次</li></ol></li></ol><h2 id="9-5-HTTP-请求包分析-GET"><a href="#9-5-HTTP-请求包分析-GET" class="headerlink" title="9.5 HTTP 请求包分析(GET)"></a>9.5 HTTP 请求包分析(GET)</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420172713.png" alt="image.png|500"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420173654.png" alt="image.png|500"></p><h2 id="9-6-HTTP-请求包分析-POST"><a href="#9-6-HTTP-请求包分析-POST" class="headerlink" title="9.6 HTTP 请求包分析(POST)"></a>9.6 HTTP 请求包分析(POST)</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420173846.png" alt="image.png|500"></p><h2 id="9-7-GET-请求-POST-请求分别有哪些"><a href="#9-7-GET-请求-POST-请求分别有哪些" class="headerlink" title="9.7 GET 请求 POST 请求分别有哪些?"></a>9.7 GET 请求 POST 请求分别有哪些?</h2><ol><li>GET 请求有哪些<ol><li>form 标签 method&#x3D;get [指定]</li><li>a 标签</li><li>link 标签引入 css [以get方式来获取资源]</li><li>Script 标签引入 js 文件 [以get方式来获取资源]</li><li>img 标签引入图片 [以get请求来获取图片]</li><li>iframe 引入 html 页面</li><li>在浏览器地址栏中输入地址后敲回车[用的比较多]</li></ol></li><li>POST 请求有哪些<ol><li>form 标签 method&#x3D;post</li></ol></li><li>HTTP 请求中怎样选择 Get 和 Post 方式<ol><li>传输的数据大小区别<ol><li>get 传送的数据量较小。不能大于 2KB(不同浏览器不一样)。</li><li>post 传送的数据量较大。一般默认不受限制。</li></ol></li><li>什么情况下使用 post 请求<ol><li>post 请求是会在浏览器上隐藏參数部分的，在安全要求的部分都会使用到 POST 请求。如用户登录。数据增删改等等。都会把參数隐藏起来，这样就不会通过你的请求暴露你的參数格式</li><li>在向 server 传递数据较大的时候。使用 POST，get 是有限制的, 比如发帖, 上传文件</li></ol></li><li>什么情况下使用 get 方式呢<ol><li>在前台页面展示，比如分页内容等，可以保留传递参数, 可用来非常好的分享和传播,POST 中链接地址是不变化的。</li></ol></li><li>建议<ol><li>get 方式的安全性较 Post 方式要差些。包括机密信息的话。建议用 Post 数据提交方式；</li><li>在做数据查询时。建议用 Get 方式；而在做数据加入、改动或删除时，建议用 Post</li></ol></li></ol></li></ol><h2 id="9-8-HTTP-响应包分析"><a href="#9-8-HTTP-响应包分析" class="headerlink" title="9.8 HTTP 响应包分析"></a>9.8 HTTP 响应包分析</h2><ol><li>HTTP 响应包括 3 个部分<ol><li>响应行</li><li>响应头</li><li>响应体<br> <img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420174318.png" alt="image.png|500"></li></ol></li></ol><h2 id="9-9-常用的状态码说明"><a href="#9-9-常用的状态码说明" class="headerlink" title="9.9 常用的状态码说明"></a>9.9 常用的状态码说明</h2><ol><li>状态行<ol><li>格式： HTTP版本号 状态码 原因叙述&lt;CRLF&gt;</li><li>举例：HTTP&#x2F;1.1 200 OK</li></ol></li><li>状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5类<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420174444.png" alt="image.png"></li></ol><h2 id="9-10-MIME-类型"><a href="#9-10-MIME-类型" class="headerlink" title="9.10 MIME 类型"></a>9.10 MIME 类型</h2><ol><li>MIME 是 HTTP 协议中数据类型。多功能 Internet 邮件扩充服务</li><li>MIME 类型的格式是”大类型&#x2F;小类型”，并与某一种文件的扩展名相对应<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240420174619.png" alt="image.png|500"></li></ol><h1 id="12-Web-开发会话技术-Cookie-Session"><a href="#12-Web-开发会话技术-Cookie-Session" class="headerlink" title="12 Web 开发会话技术 -Cookie&amp;Session"></a>12 Web 开发会话技术 -Cookie&amp;Session</h1><h2 id="12-1-会话"><a href="#12-1-会话" class="headerlink" title="12.1 会话"></a>12.1 会话</h2><ol><li>会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个 web 资源，然后关闭浏览器，整个过程称之为一个会话</li><li>会话过程中要解决的一些问题？<ol><li>每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，服务器要想办法为每个用户保存这些数据</li></ol></li><li>会话的两种技术<ol><li>Session</li><li>Cookie</li></ol></li></ol><h2 id="12-2-Cookie-有什么用"><a href="#12-2-Cookie-有什么用" class="headerlink" title="12.2 Cookie 有什么用"></a>12.2 Cookie 有什么用</h2><ol><li>Cookie(小甜饼)是客户端技术，服务器把每个用户的数据以 cookie 的形式写给用户各自的浏览器。</li><li>当用户使用浏览器再去访问服务器中的 web 资源时，就会带着各自的数据去。</li><li>Cookie 是服务器在客户端保存用户的信息，比如登录名，浏览历史等, 就可以以 cookie方式保存</li><li>Cookie 信息就像是小甜饼(cookie 中文)一样，数据量并不大，服务器端在需要的时候可以从客户端&#x2F;浏览器读取(http 协议)</li></ol><h2 id="12-4-cookie-基本使用"><a href="#12-4-cookie-基本使用" class="headerlink" title="12.4 cookie 基本使用"></a>12.4 cookie 基本使用</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240421140944.png" alt="image.png|500"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240421140951.png" alt="image.png|377"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240421140956.png" alt="image.png|313"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240421141003.png" alt="image.png|433"></p><h2 id="12-7-cookie-生命周期"><a href="#12-7-cookie-生命周期" class="headerlink" title="12.7 cookie 生命周期"></a>12.7 cookie 生命周期</h2><ol><li>Cookie 的生命周期指的是如何管理 Cookie 什么时候被销毁（删除）</li><li>setMaxAge()<ol><li>正数，表示在指定的秒数后过期</li><li>负数，表示浏览器关闭，Cookie 就会被删除（默认值是-1）</li><li>0，表示马上删除 Cookie</li></ol></li></ol><h2 id="12-8-cookie-有效路径"><a href="#12-8-cookie-有效路径" class="headerlink" title="12.8 cookie 有效路径"></a>12.8 cookie 有效路径</h2><ol><li>Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。</li><li>path属性是通过请求的地址来进行有效的过滤</li><li>规则<br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240421141700.png" alt="image.png|332"></li></ol><h2 id="12-10-Cookie-注意事项和细节"><a href="#12-10-Cookie-注意事项和细节" class="headerlink" title="12.10 Cookie 注意事项和细节"></a>12.10 Cookie 注意事项和细节</h2><ol><li>一个 Cookie 只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）</li><li>一个 WEB 站点可以给一个浏览器发送多个 Cookie，一个浏览器也可以存储多个 WEB 站点提供的 Cookie</li><li>cookie 的总数量没有限制，但是每个域名的 COOKIE 数量和每个 COOKIE 的大小是有限制的 (不同的浏览器限制不同, 知道即可) , Cookie 不适合存放数据量大的信息</li><li>注意，删除 cookie 时，path 必须一致，否则不会删除</li></ol><h2 id="12-11-session-有什么用"><a href="#12-11-session-有什么用" class="headerlink" title="12.11 session 有什么用"></a>12.11 session 有什么用</h2><ol><li>Session 是服务器端技术，服务器在运行时为每一个用户的浏览器创建一个其独享的session 对象&#x2F;集合</li><li>由于 session 为各个用户浏览器独享，所以用户在访问服务器的不同页面时，可以从各自的 session 中读取&#x2F;添加数据, 从而完成相应任务</li></ol><h2 id="12-12-session-基本原理"><a href="#12-12-session-基本原理" class="headerlink" title="12.12 session 基本原理"></a>12.12 session 基本原理</h2><ol><li>当用户打开浏览器，访问某个网站, 操作 session 时，服务器就会在内存(在服务端)为该浏览器分配一个 session 对象，该 session 对象被这个浏览器独占</li><li>这个 session 对象也可看做是一个容器&#x2F;集合,session 对象默认存在时间为 30min(这是在tomcat&#x2F;conf&#x2F;web.xml)，也可修改</li></ol><h2 id="12-13-session-常用方法"><a href="#12-13-session-常用方法" class="headerlink" title="12.13 session 常用方法"></a>12.13 session 常用方法</h2><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240421162910.png" alt="image.png|500"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240421162921.png" alt="image.png|500"></p><h2 id="12-15-session-生命周期"><a href="#12-15-session-生命周期" class="headerlink" title="12.15 session 生命周期"></a>12.15 session 生命周期</h2><ol><li>public void setMaxInactiveInterval(int interval) 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。</li><li>值为正数的时候，设定 Session 的超时时长。</li><li>负数表示永不超时</li><li>public int getMaxInactiveInterval()获取 Session 的超时时间</li><li>public void invalidate() 让当前 Session 会话立即无效</li><li>如果没有调用 setMaxInactiveInterval() 来指定 Session 的生命时长，Tomcat 会以 Session默认时长为准，Session 默认的超时为 30 分钟， 可以在 tomcat 的 web.xml 设置</li><li>Session 的生命周期指的是 ：客户端&#x2F;浏览器两次请求最大间隔时长，而不是累积时长。</li><li>底层: Tomcat 用一个线程来轮询会话状态，如果某个会话的空闲时间超过设定的最大值，则将该会话销毁</li></ol><h1 id="13-服务器渲染技术-JSP"><a href="#13-服务器渲染技术-JSP" class="headerlink" title="13.服务器渲染技术 -JSP"></a>13.服务器渲染技术 -JSP</h1><h2 id="13-3-为什么需要-JSP"><a href="#13-3-为什么需要-JSP" class="headerlink" title="13.3 为什么需要 JSP"></a>13.3 为什么需要 JSP</h2><ol><li>jsp&#x3D;html+java 片段+标签+javascript+css</li></ol><h2 id="13-5-JSP基本介绍"><a href="#13-5-JSP基本介绍" class="headerlink" title="13.5 JSP基本介绍"></a>13.5 JSP基本介绍</h2><ol><li>JSP 全称是 Java Server Pages，Java 的服务器页面</li><li>JSP 这门技术的最大的特点在于，写 JSP 就像在写 HTML</li><li>相比 html 而言，html 只能为用户提供静态数据，而 JSP 技术允许在页面中嵌套 java 代码，为用户提供动态数据</li><li>相比 Servlet 而言，Servlet 很难对数据进行排版，而 jsp 除了可以用 java 代码产 生动态数据的同时，也很容易对数据进行排版</li><li>jsp 技术基于 Servlet, 你可以理解成 JSP 就是对 Servlet 的包装</li></ol><h2 id="13-7-JSP-运行原理"><a href="#13-7-JSP-运行原理" class="headerlink" title="13.7 JSP 运行原理"></a>13.7 JSP 运行原理</h2><ol><li>jsp 页面本质是一个 Servlet 程序, 其性能是和 java 关联的</li><li>第 1 次访问 jsp 页面的时候。Tomcat 服务器会把 jsp 页面解析成为一个 java 源文件。并 且 对 它 进 行 编 译 成 为 .class 字 节 码 程 序 。</li></ol><h2 id="13-8-page-指令-常用的"><a href="#13-8-page-指令-常用的" class="headerlink" title="13.8 page 指令(常用的)"></a>13.8 page 指令(常用的)</h2><h2 id="以下开始简写"><a href="#以下开始简写" class="headerlink" title="以下开始简写"></a>以下开始简写</h2><ol><li>JSP常用脚本 584<ol><li>声明脚本</li><li>表达式脚本</li><li>代码脚本</li></ol></li><li>JSP 注释 593</li><li>JSP 内置对象 593</li><li>JSP 域对象 599</li><li>JSP 请求转发标签 605</li><li>EL 614<ol><li>常用输出形式 616</li><li>运算操作 621</li><li>隐含对象 626</li></ol></li><li>JSTL 631</li></ol><h1 id="14-JavaWeb-三大组件之监听器-Listener"><a href="#14-JavaWeb-三大组件之监听器-Listener" class="headerlink" title="14.JavaWeb 三大组件之监听器 Listener"></a>14.JavaWeb 三大组件之监听器 Listener</h1><ol><li>JavaWeb 的三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器</li><li>Listener 监听器介绍 646</li><li>JavaWeb 的监听器 648<ol><li>ServletContextListener 监听器</li><li>ServletContextAttributeListener 监听器</li><li>…</li></ol></li></ol><h1 id="15-JavaWeb-三大组件之-过滤器-Filter"><a href="#15-JavaWeb-三大组件之-过滤器-Filter" class="headerlink" title="15.JavaWeb 三大组件之 过滤器 Filter"></a>15.JavaWeb 三大组件之 过滤器 Filter</h1><ol><li>Filter 过滤器它的作用是：拦截请求，过滤响应</li><li>Filter 过滤器 url-pattern 666</li><li>Filter 过滤器生命周期</li><li>FilterConfig</li><li>FilterChain 过滤器链</li></ol><h1 id="16-JavaScript-开发利器之-jQuery"><a href="#16-JavaScript-开发利器之-jQuery" class="headerlink" title="16.JavaScript 开发利器之 jQuery"></a>16.JavaScript 开发利器之 jQuery</h1><h1 id="17-数据交换和异步请求-JSON-Ajax"><a href="#17-数据交换和异步请求-JSON-Ajax" class="headerlink" title="17.数据交换和异步请求 - JSON &amp; Ajax"></a>17.数据交换和异步请求 - JSON &amp; Ajax</h1><ol><li>JSON 对象和字符串对象转换 842</li><li>Json 在 java中使用</li><li>Ajax 基本介绍 851<ol><li>$.ajax 方法 865</li><li>$.get 请求和$.post 请求</li><li>$.getJSON</li></ol></li></ol><h1 id="18-线程数据共享和安全-ThreadLocal"><a href="#18-线程数据共享和安全-ThreadLocal" class="headerlink" title="18.线程数据共享和安全 -ThreadLocal"></a>18.线程数据共享和安全 -ThreadLocal</h1><ol><li>什么是ThreadLocal 870</li></ol><h1 id="20"><a href="#20" class="headerlink" title="20"></a>20</h1><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240422002709.png" alt="image.png"><br><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240422002714.png" alt="image.png"></p><h1 id="功能02-会员注册前端JS校验"><a href="#功能02-会员注册前端JS校验" class="headerlink" title="功能02 - 会员注册前端JS校验"></a>功能02 - 会员注册前端JS校验</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li>验证用户名：必须字母，数字下划线组成，并且长度为 6 到 10 位</li><li>验证密码：必须由字母，数字下划线组成，并且长度为 6 到 10 位</li><li>邮箱格式验证：常规验证即可</li><li>验证码：后面实现</li></ol><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ol><li>使用jQuery + 正则表达式</li><li>绑定事件，按要求验证，如果有错误，给出提示信息</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li>Ctrl + Home</li><li>Ctrl + End<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html">$(function ()&#123;  <br>    // 绑定点击事件  <br>    $(&quot;#sub-btn&quot;).click(function ()&#123;  <br>        //获取到到输入的用户名  <br>        var usernameVal = $(&quot;#username&quot;).val();  <br>        // 编写正则表达式来进行验证.  <br>        var usernamePattern = /^\w&#123;6,10&#125;$/;  <br>        //验证  <br>        if (!usernamePattern.test(usernameVal)) &#123;  <br>            //展示错误提示, jquery属性过滤器  <br>            $(&quot;span[class=&#x27;errorMsg&#x27;]&quot;).text(&quot;用户名格式不对, 需要6-10字符&quot;);  <br>            return false;//不提交 , 返回false  <br>        &#125;  <br>        //完成对密码的校验  <br>        var passwordVal = $(&quot;#password&quot;).val();  <br>        var passwordPattern = /^\w&#123;6,10&#125;$/;  <br>        if (!passwordPattern.test(passwordVal)) &#123;  <br>            //展示密码错误提示-基本过滤器, 希望小伙伴感到知识不是每个都是新  <br>            //信心-》潜意识我学过.  <br>            $(&quot;span.errorMsg&quot;).text(&quot;密码格式不对, 需要6-10字符&quot;);  <br>            return false;        &#125;  <br>        //两次密码相同  <br>        //得到第二次输入密码  <br>        var repwdVal = $(&quot;#repwd&quot;).val();  <br>        if (repwdVal != passwordVal) &#123;  <br>            $(&quot;span.errorMsg&quot;).text(&quot;输入的两次密码不同&quot;);  <br>            return false;        &#125;  <br>        //验证邮箱  <br>        //得到邮箱 =&gt; 去看html  <br>        var emailVal = $(&quot;#email&quot;).val();  <br>        //老师说明 在java中，正则表达式的转义是\\, 在js 正则表达式 转义是\  <br>        //如果你看不懂，回看java正则表达式  <br>        var emailPattern = /^[\w-]+@([a-zA-Z]+\.)+[a-zA-Z]+$/; //偷懒-&gt;java  <br>        if (!emailPattern.test(emailVal)) &#123;  <br>            $(&quot;span.errorMsg&quot;).text(&quot;电子邮件格式不对&quot;);  <br>            return false;        &#125;  <br>        //到这里就全部过关. =&gt; 我们暂时不提交，显示验证通过信息  <br>        $(&quot;span.errorMsg&quot;).text(&quot;验证通过...&quot;);  <br>        //目前我们写了后台，当验证通过时，就提交给后台  <br>        return true;  <br>    &#125;)  <br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ol><li>会员注册信息，验证通过后</li><li>提交给服务器，如果用户名在数据库中已经存在，后台给出提示信息，并返回重新注册</li><li>如果用户名没有在数据库中，完成注册，并返回注册成功的页面</li></ol><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p><img src="https://obsidian-1315850689.cos.ap-nanjing.myqcloud.com/obsidian/pic/20240422011431.png" alt="image.png"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li>数据库建表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database if <span class="hljs-keyword">exists</span> home_furnishing;  <br><span class="hljs-keyword">create</span> database home_furnishing;  <br>use home_furnishing;  <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">member</span>(  <br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,  <br>    username <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span>,  <br>    password <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,  <br>    email <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>)  <br>)engine INNODB;  <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">member</span>(username,password,email) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;hsp@hsp.net&#x27;</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">member</span>;<br></code></pre></td></tr></table></figure></li><li>javabean<ol><li>一定要提供一个无参构造器，底层使用一个反射创建Memeber对象</li><li>全参构造器</li><li>get  set方法</li><li>toString方法</li></ol></li><li>DAO<ol><li>复制粘贴 BasicDAO</li><li>复制粘贴 JDBCUtilsByDruid连接池</li><li>设置 druid.properties<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#key=value  </span><br><span class="hljs-attr">driverClassName</span>=com.mysql.jdbc.Driver  <br><span class="hljs-attr">url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/home_furnishing?rewriteBatchedStatements=<span class="hljs-literal">true</span>  <span class="hljs-comment"># 批处理</span><br><span class="hljs-attr">username</span>=root  <br><span class="hljs-attr">password</span>=<span class="hljs-number">12345</span>  <br><span class="hljs-comment">#initial connection Size  </span><br><span class="hljs-attr">initialSize</span>=<span class="hljs-number">10</span>  <br><span class="hljs-comment">#min idle connecton size  </span><br><span class="hljs-attr">minIdle</span>=<span class="hljs-number">5</span>  <br><span class="hljs-comment">#max active connection size  </span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-number">50</span>  <br><span class="hljs-comment">#max wait time (5000 mil seconds)  </span><br><span class="hljs-attr">maxWait</span>=<span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure></li></ol></li><li>Test<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtilsByDruidTest</span> &#123;  <br>    <span class="hljs-meta">@Test</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;  <br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();  <br>        System.out.println(<span class="hljs-string">&quot;connection= &quot;</span> + connection);  <br>        JDBCUtilsByDruid.close(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, connection);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>报错<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">4</span>月 <span class="hljs-number">22</span>, <span class="hljs-number">2024</span> <span class="hljs-number">1</span>:<span class="hljs-number">39</span>:<span class="hljs-number">18</span> 上午 com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.JakartaCommonsLoggingImpl</span> info<br>信息: &#123;dataSource-<span class="hljs-number">1</span>&#125; inited<br>com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.exceptions</span><span class="hljs-selector-class">.jdbc4</span><span class="hljs-selector-class">.MySQLNonTransientConnectionException</span>: Could not create connection to database server.<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance0</span>(Native Method)<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance</span>(NativeConstructorAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">77</span>)<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance</span>(DelegatingConstructorAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">45</span>)<br>at java.base/java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Constructor</span><span class="hljs-selector-class">.newInstanceWithCaller</span>(Constructor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">499</span>)<br>at java.base/java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Constructor</span><span class="hljs-selector-class">.newInstance</span>(Constructor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">480</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.Util</span><span class="hljs-selector-class">.handleNewInstance</span>(Util<span class="hljs-selector-class">.java</span>:<span class="hljs-number">404</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.Util</span><span class="hljs-selector-class">.getInstance</span>(Util<span class="hljs-selector-class">.java</span>:<span class="hljs-number">387</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.SQLError</span><span class="hljs-selector-class">.createSQLException</span>(SQLError<span class="hljs-selector-class">.java</span>:<span class="hljs-number">919</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.SQLError</span><span class="hljs-selector-class">.createSQLException</span>(SQLError<span class="hljs-selector-class">.java</span>:<span class="hljs-number">898</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.SQLError</span><span class="hljs-selector-class">.createSQLException</span>(SQLError<span class="hljs-selector-class">.java</span>:<span class="hljs-number">887</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.SQLError</span><span class="hljs-selector-class">.createSQLException</span>(SQLError<span class="hljs-selector-class">.java</span>:<span class="hljs-number">862</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.ConnectionImpl</span><span class="hljs-selector-class">.connectOneTryOnly</span>(ConnectionImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">2331</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.ConnectionImpl</span><span class="hljs-selector-class">.createNewIO</span>(ConnectionImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">2084</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.ConnectionImpl</span>.&lt;init&gt;(ConnectionImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">795</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.JDBC4Connection</span>.&lt;init&gt;(JDBC4Connection<span class="hljs-selector-class">.java</span>:<span class="hljs-number">44</span>)<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance0</span>(Native Method)<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance</span>(NativeConstructorAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">77</span>)<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingConstructorAccessorImpl</span><span class="hljs-selector-class">.newInstance</span>(DelegatingConstructorAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">45</span>)<br>at java.base/java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Constructor</span><span class="hljs-selector-class">.newInstanceWithCaller</span>(Constructor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">499</span>)<br>at java.base/java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Constructor</span><span class="hljs-selector-class">.newInstance</span>(Constructor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">480</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.Util</span><span class="hljs-selector-class">.handleNewInstance</span>(Util<span class="hljs-selector-class">.java</span>:<span class="hljs-number">404</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.ConnectionImpl</span><span class="hljs-selector-class">.getInstance</span>(ConnectionImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">400</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.NonRegisteringDriver</span><span class="hljs-selector-class">.connect</span>(NonRegisteringDriver<span class="hljs-selector-class">.java</span>:<span class="hljs-number">327</span>)<br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidAbstractDataSource</span><span class="hljs-selector-class">.createPhysicalConnection</span>(DruidAbstractDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1558</span>)<br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidAbstractDataSource</span><span class="hljs-selector-class">.createPhysicalConnection</span>(DruidAbstractDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1623</span>)<br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.init</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">861</span>)<br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.getConnection</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1229</span>)<br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.getConnection</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1225</span>)<br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.getConnection</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">90</span>)<br>at com<span class="hljs-selector-class">.hspedu</span><span class="hljs-selector-class">.furns</span><span class="hljs-selector-class">.utils</span><span class="hljs-selector-class">.JDBCUtilsByDruid</span><span class="hljs-selector-class">.getConnection</span>(JDBCUtilsByDruid<span class="hljs-selector-class">.java</span>:<span class="hljs-number">58</span>)<br>at com<span class="hljs-selector-class">.hspedu</span><span class="hljs-selector-class">.furns</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.JDBCUtilsByDruidTest</span><span class="hljs-selector-class">.getConnection</span>(JDBCUtilsByDruidTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">12</span>)<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke0</span>(Native Method)<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">77</span>)<br>at java.base/jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">43</span>)<br>at java.base/java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span><span class="hljs-selector-class">.invoke</span>(Method<span class="hljs-selector-class">.java</span>:<span class="hljs-number">568</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ReflectionUtils</span><span class="hljs-selector-class">.invokeMethod</span>(ReflectionUtils<span class="hljs-selector-class">.java</span>:<span class="hljs-number">725</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.MethodInvocation</span><span class="hljs-selector-class">.proceed</span>(MethodInvocation<span class="hljs-selector-class">.java</span>:<span class="hljs-number">60</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span>.InvocationInterceptorChain<span class="hljs-variable">$ValidatingInvocation</span><span class="hljs-selector-class">.proceed</span>(InvocationInterceptorChain<span class="hljs-selector-class">.java</span>:<span class="hljs-number">131</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.TimeoutExtension</span><span class="hljs-selector-class">.intercept</span>(TimeoutExtension<span class="hljs-selector-class">.java</span>:<span class="hljs-number">149</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.TimeoutExtension</span><span class="hljs-selector-class">.interceptTestableMethod</span>(TimeoutExtension<span class="hljs-selector-class">.java</span>:<span class="hljs-number">140</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.TimeoutExtension</span><span class="hljs-selector-class">.interceptTestMethod</span>(TimeoutExtension<span class="hljs-selector-class">.java</span>:<span class="hljs-number">84</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span>.ExecutableInvoker<span class="hljs-variable">$ReflectiveInterceptorCall</span>.lambda<span class="hljs-variable">$ofVoidMethod</span>$<span class="hljs-number">0</span>(ExecutableInvoker<span class="hljs-selector-class">.java</span>:<span class="hljs-number">115</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.ExecutableInvoker</span>.lambda<span class="hljs-variable">$invoke</span>$<span class="hljs-number">0</span>(ExecutableInvoker<span class="hljs-selector-class">.java</span>:<span class="hljs-number">105</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span>.InvocationInterceptorChain<span class="hljs-variable">$InterceptedInvocation</span><span class="hljs-selector-class">.proceed</span>(InvocationInterceptorChain<span class="hljs-selector-class">.java</span>:<span class="hljs-number">106</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.InvocationInterceptorChain</span><span class="hljs-selector-class">.proceed</span>(InvocationInterceptorChain<span class="hljs-selector-class">.java</span>:<span class="hljs-number">64</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.InvocationInterceptorChain</span><span class="hljs-selector-class">.chainAndInvoke</span>(InvocationInterceptorChain<span class="hljs-selector-class">.java</span>:<span class="hljs-number">45</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.InvocationInterceptorChain</span><span class="hljs-selector-class">.invoke</span>(InvocationInterceptorChain<span class="hljs-selector-class">.java</span>:<span class="hljs-number">37</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.ExecutableInvoker</span><span class="hljs-selector-class">.invoke</span>(ExecutableInvoker<span class="hljs-selector-class">.java</span>:<span class="hljs-number">104</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.ExecutableInvoker</span><span class="hljs-selector-class">.invoke</span>(ExecutableInvoker<span class="hljs-selector-class">.java</span>:<span class="hljs-number">98</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.descriptor</span><span class="hljs-selector-class">.TestMethodTestDescriptor</span>.lambda<span class="hljs-variable">$invokeTestMethod</span>$<span class="hljs-number">7</span>(TestMethodTestDescriptor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">214</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.ThrowableCollector</span><span class="hljs-selector-class">.execute</span>(ThrowableCollector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.descriptor</span><span class="hljs-selector-class">.TestMethodTestDescriptor</span><span class="hljs-selector-class">.invokeTestMethod</span>(TestMethodTestDescriptor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">210</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.descriptor</span><span class="hljs-selector-class">.TestMethodTestDescriptor</span><span class="hljs-selector-class">.execute</span>(TestMethodTestDescriptor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">135</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.descriptor</span><span class="hljs-selector-class">.TestMethodTestDescriptor</span><span class="hljs-selector-class">.execute</span>(TestMethodTestDescriptor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">66</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">6</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">151</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.ThrowableCollector</span><span class="hljs-selector-class">.execute</span>(ThrowableCollector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">8</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">141</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.Node</span><span class="hljs-selector-class">.around</span>(Node<span class="hljs-selector-class">.java</span>:<span class="hljs-number">137</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">9</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">139</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.ThrowableCollector</span><span class="hljs-selector-class">.execute</span>(ThrowableCollector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span><span class="hljs-selector-class">.executeRecursively</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">138</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span><span class="hljs-selector-class">.execute</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">95</span>)<br>at java.base/java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.forEach</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1511</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.SameThreadHierarchicalTestExecutorService</span><span class="hljs-selector-class">.invokeAll</span>(SameThreadHierarchicalTestExecutorService<span class="hljs-selector-class">.java</span>:<span class="hljs-number">41</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">6</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">155</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.ThrowableCollector</span><span class="hljs-selector-class">.execute</span>(ThrowableCollector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">8</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">141</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.Node</span><span class="hljs-selector-class">.around</span>(Node<span class="hljs-selector-class">.java</span>:<span class="hljs-number">137</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">9</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">139</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.ThrowableCollector</span><span class="hljs-selector-class">.execute</span>(ThrowableCollector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span><span class="hljs-selector-class">.executeRecursively</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">138</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span><span class="hljs-selector-class">.execute</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">95</span>)<br>at java.base/java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.forEach</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1511</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.SameThreadHierarchicalTestExecutorService</span><span class="hljs-selector-class">.invokeAll</span>(SameThreadHierarchicalTestExecutorService<span class="hljs-selector-class">.java</span>:<span class="hljs-number">41</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">6</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">155</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.ThrowableCollector</span><span class="hljs-selector-class">.execute</span>(ThrowableCollector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">8</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">141</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.Node</span><span class="hljs-selector-class">.around</span>(Node<span class="hljs-selector-class">.java</span>:<span class="hljs-number">137</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span>.lambda<span class="hljs-variable">$executeRecursively</span>$<span class="hljs-number">9</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">139</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.ThrowableCollector</span><span class="hljs-selector-class">.execute</span>(ThrowableCollector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">73</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span><span class="hljs-selector-class">.executeRecursively</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">138</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.NodeTestTask</span><span class="hljs-selector-class">.execute</span>(NodeTestTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">95</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.SameThreadHierarchicalTestExecutorService</span><span class="hljs-selector-class">.submit</span>(SameThreadHierarchicalTestExecutorService<span class="hljs-selector-class">.java</span>:<span class="hljs-number">35</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.HierarchicalTestExecutor</span><span class="hljs-selector-class">.execute</span>(HierarchicalTestExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">57</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.engine</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.hierarchical</span><span class="hljs-selector-class">.HierarchicalTestEngine</span><span class="hljs-selector-class">.execute</span>(HierarchicalTestEngine<span class="hljs-selector-class">.java</span>:<span class="hljs-number">54</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.EngineExecutionOrchestrator</span><span class="hljs-selector-class">.execute</span>(EngineExecutionOrchestrator<span class="hljs-selector-class">.java</span>:<span class="hljs-number">107</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.EngineExecutionOrchestrator</span><span class="hljs-selector-class">.execute</span>(EngineExecutionOrchestrator<span class="hljs-selector-class">.java</span>:<span class="hljs-number">88</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.EngineExecutionOrchestrator</span>.lambda<span class="hljs-variable">$execute</span>$<span class="hljs-number">0</span>(EngineExecutionOrchestrator<span class="hljs-selector-class">.java</span>:<span class="hljs-number">54</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.EngineExecutionOrchestrator</span><span class="hljs-selector-class">.withInterceptedStreams</span>(EngineExecutionOrchestrator<span class="hljs-selector-class">.java</span>:<span class="hljs-number">67</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.EngineExecutionOrchestrator</span><span class="hljs-selector-class">.execute</span>(EngineExecutionOrchestrator<span class="hljs-selector-class">.java</span>:<span class="hljs-number">52</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.DefaultLauncher</span><span class="hljs-selector-class">.execute</span>(DefaultLauncher<span class="hljs-selector-class">.java</span>:<span class="hljs-number">114</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.DefaultLauncher</span><span class="hljs-selector-class">.execute</span>(DefaultLauncher<span class="hljs-selector-class">.java</span>:<span class="hljs-number">86</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span>.DefaultLauncherSession<span class="hljs-variable">$DelegatingLauncher</span><span class="hljs-selector-class">.execute</span>(DefaultLauncherSession<span class="hljs-selector-class">.java</span>:<span class="hljs-number">86</span>)<br>at org<span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.platform</span><span class="hljs-selector-class">.launcher</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.SessionPerRequestLauncher</span><span class="hljs-selector-class">.execute</span>(SessionPerRequestLauncher<span class="hljs-selector-class">.java</span>:<span class="hljs-number">53</span>)<br>at com<span class="hljs-selector-class">.intellij</span><span class="hljs-selector-class">.junit5</span><span class="hljs-selector-class">.JUnit5IdeaTestRunner</span><span class="hljs-selector-class">.startRunnerWithArgs</span>(JUnit5IdeaTestRunner<span class="hljs-selector-class">.java</span>:<span class="hljs-number">57</span>)<br>at com<span class="hljs-selector-class">.intellij</span><span class="hljs-selector-class">.rt</span><span class="hljs-selector-class">.junit</span>.IdeaTestRunner<span class="hljs-variable">$Repeater</span>$<span class="hljs-number">1</span><span class="hljs-selector-class">.execute</span>(IdeaTestRunner<span class="hljs-selector-class">.java</span>:<span class="hljs-number">38</span>)<br>at com<span class="hljs-selector-class">.intellij</span><span class="hljs-selector-class">.rt</span><span class="hljs-selector-class">.execution</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.TestsRepeater</span><span class="hljs-selector-class">.repeat</span>(TestsRepeater<span class="hljs-selector-class">.java</span>:<span class="hljs-number">11</span>)<br>at com<span class="hljs-selector-class">.intellij</span><span class="hljs-selector-class">.rt</span><span class="hljs-selector-class">.junit</span>.IdeaTestRunner<span class="hljs-variable">$Repeater</span><span class="hljs-selector-class">.startRunnerWithArgs</span>(IdeaTestRunner<span class="hljs-selector-class">.java</span>:<span class="hljs-number">35</span>)<br>at com<span class="hljs-selector-class">.intellij</span><span class="hljs-selector-class">.rt</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.JUnitStarter</span><span class="hljs-selector-class">.prepareStreamsAndStart</span>(JUnitStarter<span class="hljs-selector-class">.java</span>:<span class="hljs-number">232</span>)<br>at com<span class="hljs-selector-class">.intellij</span><span class="hljs-selector-class">.rt</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.JUnitStarter</span><span class="hljs-selector-class">.main</span>(JUnitStarter<span class="hljs-selector-class">.java</span>:<span class="hljs-number">55</span>)<br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NullPointerException</span>: Cannot invoke <span class="hljs-string">&quot;java.util.Map.get(Object)&quot;</span> because <span class="hljs-string">&quot;this.serverVariables&quot;</span> is null<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.ConnectionImpl</span><span class="hljs-selector-class">.getServerCharset</span>(ConnectionImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">3004</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.MysqlIO</span><span class="hljs-selector-class">.sendConnectionAttributes</span>(MysqlIO<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1908</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.MysqlIO</span><span class="hljs-selector-class">.proceedHandshakeWithPluggableAuthentication</span>(MysqlIO<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1837</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.MysqlIO</span><span class="hljs-selector-class">.doHandshake</span>(MysqlIO<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1207</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.ConnectionImpl</span><span class="hljs-selector-class">.coreConnect</span>(ConnectionImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">2254</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.ConnectionImpl</span><span class="hljs-selector-class">.connectOneTryOnly</span>(ConnectionImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">2285</span>)<br>... <span class="hljs-number">88</span> more<br>connection= null<br></code></pre></td></tr></table></figure>解决：导入包<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 或使用最新的版本 --&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>DAO  接口及对应的实现<ol><li>设计DAO接口的方法</li><li>实现对应的接口</li></ol></li><li>service 层 接口和对应实现类<ol><li>设计 接口</li><li>实现接口</li></ol></li><li>web层<ol><li>写servlet，web.iml设置</li><li>写servlet<ol><li>判断是否存在</li><li>插入数据</li><li>转发给ok</li><li>转发给fail</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【胡思02】收藏网页-生财有术</title>
    <link href="/2022/03/28/%E3%80%90%E8%83%A1%E6%80%9D02%E3%80%91%E7%94%9F%E8%B4%A2%E6%9C%89%E6%9C%AF/"/>
    <url>/2022/03/28/%E3%80%90%E8%83%A1%E6%80%9D02%E3%80%91%E7%94%9F%E8%B4%A2%E6%9C%89%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ixj2n96xjg.feishu.cn/docx/HY99dPzghoqnTTxZYzJcisDgnxh">风向标掘金，免费带领1000➕互联网小白天涯项目捡钱，汇总千人经验的保姆级实操手册分享! - 飞书云文档</a><br><a href="https://k0z8o16zas8.feishu.cn/docx/SUTKd7wdDoAg2Exv7hoc8m0BnOK">ChatGPT 投喂指南 - 飞书云文档</a><br><a href="https://docs.qq.com/doc/DSU10dE9pdHdtWnNn">微信视频号百宝书（持续更新）</a><br><a href="https://docs.qq.com/sheet/DSWhMaUFnWG1oWWZB?tab=BB08J2">视频号选品表（李诚）</a><br><a href="https://wchekk4hs9.feishu.cn/docx/Gn5NdifvBorUbdxvGl6ceQgXnpg">新手小白如何借助生财小航海每月多赚 2 万元（附：小航海项目筛选模型） - 飞书云文档</a><br><a href="https://vfqxua5lvd.feishu.cn/docx/WRqQd64xqoYxXexWorYcmDmrnfh">玩赚Chatgpt社群精益创业的七天实录 - 飞书云文档</a><br><a href="https://pznme756ly.feishu.cn/docx/K9WSdh9exoe2jFxPKkPc1uUunXb">身体残疾卧床 3 年，我在人生最低谷加入生财有术，有哪些成长？ - 飞书云文档</a><br><a href="https://rxmgihbc4u.feishu.cn/docx/HeTJdquunoD6zOxZ2DUcLspOnEf">《从自媒体小白到十一个月变现80W的私域IP操盘手，挽歌的社群运营之旅》 - 飞书云文档</a><br><a href="https://k170ac9yh31.feishu.cn/docx/PlpQdDbzkoaZoMxPf3dczRiunhc">《公众号爆文进阶教程》 - 飞书云文档</a><br><a href="https://i2mok5xev6.feishu.cn/docx/Y0hGduYtnot9WIxB1excr6S0nde">我如何在视频号深耕一个小类目，半年赚15w - 飞书云文档</a><br><a href="https://ev0ft8k60w2.feishu.cn/docx/MdGjdeGoWoxP89xzb8KcSTTnntf">AI + 公众号矩阵，一个月跑通项目，变现1 万 + 复盘 - 飞书云文档</a><br><a href="https://o0yvn3o31a.feishu.cn/docx/PLped9nHNonAMnxA5yBcBgMBnTb">视频号儿女祝福流量变现副业，起号后单天收益1500+，实操一条龙玩法分享给你 - 飞书云文档</a><br><a href="https://nxzg0il06d4.feishu.cn/docx/GCzGd8fnlo3JkSx4p9ccW3uTnqc">制造业无货源带货—我是如何从0到1靠卖豆浆机20天赚9000+？ - 飞书云文档</a><br><a href="https://www.yuque.com/maoxiaodd/operation/fex5ygyhcwimtony">怎么安全使用微信（从注册到封号）</a><br><a href="https://iv8irdz7945.feishu.cn/docx/C8Dmd7AYwoeGv1x2RkkcF06Rnuc">10 月 30 日《公众号爆文自动化流程极致提效全解秘（附各类提效脚本》@JsonChao - 飞书云文档</a><br><a href="https://k4h4dcpi91.feishu.cn/docx/BH96dfPkBoyUgFx4EaQcOkIOndc">视频号带货4个月收益百万，风口已至！ - 飞书云文档</a><br><a href="https://md8vbz6pkh.feishu.cn/docx/K1ovdE2QyoKkIUxXcOHcEJC7n5c">《100万GMV达成，视频号短视频挂车投流最新玩法》 - 飞书云文档</a><br><a href="https://ex5bha8e8ip.feishu.cn/docx/BBnmd2RgFoItqXxazMrcQdIxn6g">10月航海生财有术分享 - 飞书云文档</a><br><a href="https://k874t2qh8w.feishu.cn/docx/LOqwdvj9IoGBnqx4sqbcgGM1ntd">视频号万粉，两个月变现5万，起底营销号起号变现的全流程 - 飞书云文档</a><br><a href="https://y2mt3o47i3.feishu.cn/docx/Ixx1dnbCVo4ZA8xrMcqcUYsGn8d">8个月赚40W复盘分享 - 飞书云文档</a><br><a href="https://cxqeimz77vr.feishu.cn/docx/UArddC9JsoXN7JxmLoWcgtm3n8C">AI+简历修改，首月盈利7000+ - 飞书云文档</a><br><a href="https://ry5hwpuf7b.feishu.cn/wiki/LiT2woqpHi4kKPkJ2bPcQaSsnZf">飞书云文档</a><br><a href="https://i2iygt5qes.feishu.cn/docx/DzxGdGJzvoCvLQxTJ5wcYFvMnXc">RPA+heygen10倍提升视频产出率 - 飞书云文档</a><br><a href="https://maum12vwcsk.feishu.cn/docx/Tg6vdGqW3oWw4ExVJpMc9DGqnyd">收入30万+的AI线上兼职项目复盘 - 飞书云文档</a><br><a href="https://mas0abfc08d.feishu.cn/docx/Dnred0RIBoBOYdx6NviciauynHh">三年AI图像工程师跟你分享，无限贴近真人的调教方法，助力AI变现 - 飞书云文档</a><br><a href="https://ia0969wpr2.feishu.cn/docx/UAJod7O8oo8Fj4xIVlec5huFnhg">如何使用GPT-4做推特用户分析 - 飞书云文档</a><br><a href="https://oee5lr7gsk.feishu.cn/docx/IpwmdwCIwovTVlx13Qfc1OFTnle">成为自由职业者的20个必备特质 - 飞书云文档</a><br><a href="https://p03a4vs9s2.feishu.cn/docx/Re2PdelRboSTx1xYtrTcxYRZncd">保姆级！得物好物变现项目，每月多赚2W！ - 飞书云文档</a><br><a href="https://ivvygw9y2ti.feishu.cn/docx/I43JdLvW4ocpg8xSYfnce0Vknrh">从0到1在TEMU上实现月入10W+,我是这么做的 - 飞书云文档</a><br><a href="https://vfl52b71kz.feishu.cn/docx/Z9fUdBLAao5oIdxD65ocb0KonVh">从直播卖课到深耕高中升学规划，一年变现300万+的经历分享 - 飞书云文档</a><br><a href="https://kfeoftapye.feishu.cn/docx/RS4IdDCUJo2cx1xQAYmcDpftnhe">一个支付行业新手，3个月从0到63426！ - 飞书云文档</a><br><a href="https://ukhdgfrsah.feishu.cn/docx/DzVRd33iOorkk8xieUgcAH88nic">从亏损1000w到月销5000w，7k字复盘私域电商盈亏经验 - 飞书云文档</a><br><a href="https://p9pw261qxw.feishu.cn/docx/WASldT54bo3StIxgFhYcDeLWnnJ">月饼短视频带货，两个月利润50w，我是怎么做到的？ - 飞书云文档</a><br><a href="https://kcd0oe2dxd.feishu.cn/docx/Os65dnJRlopq0ax2tabci9mvnpf">每周工作1天，兼职做小红书店铺月入10W+ - 飞书云文档</a><br><a href="https://r6kr7evxni.feishu.cn/wiki/NGDIwvlfVio8pzkgC3sc83OLn8d">高客单定制游，第一个月学员出单率30％➕的经验分享 - 飞书云文档</a><br><a href="https://t3vl04fm23.feishu.cn/docx/XljodVzAioBhRRxYmACcZIWynBg?302from=wiki">史上最强ChatGPT+小红书去重文案方法——5min快速出爆款 - 飞书云文档</a><br><a href="https://wq71epaod4q.feishu.cn/docx/ItGCdx84voNjcWxrI6IclXAYnfb">我95后女生，副业小镇卖炸鸡，只用了5个月，让20平小店月营业额10w，好吃到顾客复购60次！ - 飞书云文档</a><br><a href="https://fwsgkdbb3og.feishu.cn/docx/WIz8dl3g3o5V8GxvuU2cgmdunEh">小白如何快速低成本上手城市民宿 - 飞书云文档</a><br><a href="https://jxuhnr0sl8z.feishu.cn/docx/XCSNduej1oRdbZxBUzxc54Brnic">靠公众号流量主月入10万，40岁+宝妈终于找回了自信 - 飞书云文档</a><br><a href="https://ktuszl372b.feishu.cn/docx/BgxOdsgqNom98UxMctVcJHbunrb">《如何通过影刀RPA提升抖音图文10倍跟款的效率》@Leeka - 飞书云文档</a><br><a href="https://p8y34fwle2.feishu.cn/docx/JzKCdIcnFoYXPFxdB4xcdNiUnqe">如何利用影刀RPA进行多平台分发 - 飞书云文档</a><br><a href="https://ry5hwpuf7b.feishu.cn/docx/OQdZdGoXaorykxxIWpTc35Jenfc?useEs6=0">《流量密码！AI幻术终极教程，3步做出百万爆款视频！》 - 飞书云文档</a><br><a href="https://n28vbku1px.feishu.cn/wiki/Yh3Bwuk4zin9VckOFy4cer9wn2d">《0基础变现20w+，如何从0~1做口播，打造刷屏级爆款？》 - 飞书云文档</a><br><a href="https://sif8f6uboze.feishu.cn/docx/JqJ5d9WJ8o3HsfxDX4Scf4vfnPb">超全的AI工具生成PPT的思路和使用指南, 收获培训奖励1000 - 飞书云文档</a><br><a href="https://mwgg37pdpl.feishu.cn/docx/JdjUdvwKxo25yWxh06tcZzzAnxd">体制内二宝妈的副业探索之路 - 飞书云文档</a><br><a href="https://shimo.im/docs/pUOy4mfAEiIGGp11/read">深度 | 关于AIGC商业化的13个非共识认知（8000字长文）</a><br><a href="https://fwsgkdbb3og.feishu.cn/docx/VF75dim8AoRcaKxq9fGceh90nyg?useEs6=0">全职宝妈在重庆做民宿从0收入到月入3w+的经历分享 - 飞书云文档</a><br><a href="https://io8trrjfk3.feishu.cn/wiki/DWvcwNOGgipiT8kjQ83cSM6mnOc">房租五千，月营收38万，月利润8万的零食店是怎么做到的 - 飞书云文档</a><br><a href="https://rm1nv0sw1r.feishu.cn/docx/IZLid1QW0olfErxVEUqcyQ5xnZe">《保姆级视频号爆款内容涨粉》 - 飞书云文档</a><br><a href="https://k4h4dcpi91.feishu.cn/docx/VlR0dRPw1onLDCxevL5cbaWTnph?useEs6=0">《视频号航海：如何内容变现》 - 飞书云文档</a><br><a href="https://gzwzdskj.feishu.cn/docx/CxSDdrFKKoageExi3BwcIvq4nhb">挖掘公务员需求，打造自动化赚钱系统，两年十万单复盘 - 飞书云文档</a><br><a href="https://kkehvdiodf.feishu.cn/docx/NQOTd2uu4or84YxPdPPcGrLTngf">新项目5个月50W，复盘我们做冷门蓝海项目如何获取流量的。 - 飞书云文档</a><br><a href="https://f6uz5wrpjh.feishu.cn/docx/V06XdxQBxoAJQ8x9bPxcOVQnnud">All in小红书6个月，扭亏为盈变现70w+ - 飞书云文档</a><br><a href="https://b16xnqwk20.feishu.cn/docx/PBuidkuXpoXNGuxHsY1caWJsnWd">小红书单月卖课15W的秘密 - 飞书云文档</a><br><a href="https://lspknkwu7b.feishu.cn/wiki/CqR1w4xEqifz6EkvhnOcbCcynJc">系统做抖音的流程（1）：做抖音必须要先解决的问题——定位 - 飞书云文档</a><br><a href="https://aso41gpxhm.feishu.cn/docx/Mv1Xds3Esoz7VrxaxoiciLmsn0f">实体这样做抖音，才能赚大钱， - 飞书云文档</a><br><a href="https://lspknkwu7b.feishu.cn/wiki/ALctwvFqpiIRBvkiOXPcNyAgnzb?useEs6=0">生财的一句话，让我单月变现15w+，喂饭级教程怎么从0-1做一个赚钱的抖音号 - 飞书云文档</a><br><a href="https://fieghf3pzz6.feishu.cn/wiki/KOuZw6qqMirqo4kvWpacJHqNnkc">GPT辅助写作的SOP（分享版） - 飞书云文档</a><br><a href="https://bc8fd5oefm.feishu.cn/docx/F8VxdpYUxovdgkxVeTpcPZLXn4P">使用gpt，小白不用一行代码就可以爬虫 - 飞书云文档</a><br><a href="https://pcuddnfsui.feishu.cn/docx/XQUkdUD9Mo8B3SxHuq9clX2gnEt">播客最近那么火，普通人适合入局吗？ - 飞书云文档</a><br><a href="https://oee5lr7gsk.feishu.cn/docx/XYn1dDI9eoVCKOxBSeAcZY3YnJe?useEs6=0">续篇 - 25个提高微信成交率的小技巧（26 - 50） - 飞书云文档</a><br><a href="https://j7329dxmbu.feishu.cn/docx/W7nudn38IoxRuyxz1tpcrJOZnnd">职场IP品牌活动，四天收入近8w，普通职场人如何通过IP+内容+活动突破职场天花板 - 飞书云文档</a><br><a href="https://www.yuque.com/maoxiaodd/knowledge/hvfidh">分享一下我的知识管理系统</a><br><a href="https://superhuang.feishu.cn/wiki/XHJnw19sXigYnQkYdu0cUQ0cnjd">AI时代创作核心竞争力：看他如何与Claude深度结合，进化内容生产力（5千字干货！） - 飞书云文档</a><br><a href="https://wugz3cl7dd.feishu.cn/docx/V5JpdhySsoIJirxcw4DcKkOInhg">初创企业设立形式及股权架构全分享 ————架构没搭对，利润全交税 - 飞书云文档</a><br><a href="https://fp22b5b6ot.feishu.cn/docx/YeZqd7dAaoJJM2xPvCec3XKzn6b">52 条个人知识管理经验分享 - 飞书云文档</a><br><a href="https://txt6wm3b04b.feishu.cn/docx/F1v8drS3OoE3zyxCULmcukaPntZ">AiGC运营：小红书爆款概率预测分析（一） - 飞书云文档</a><br><a href="https://www.yuque.com/wilsondu/un6rt6/bu3zqu9gqcqdk0o9?singleDoc#">公众号AI写作，原创情感文写作prompt开源，5分钟一篇情感故事</a><br><a href="https://exoc5s8ly88.feishu.cn/docx/W7HLdHsuRoWTFpxxw0Sc9oNenmf">ChatGPT提词字典-互联网行业 - 飞书云文档</a><br><a href="https://sif8f6uboze.feishu.cn/docx/H2C2devTSoZBRUx1m6YcOoFynuh">万字解读ChatGPT提示词最佳实践 - 飞书云文档</a><br><a href="https://vchmk6v2g8.feishu.cn/docx/JZvYd2Qv0oEJsPxcmoXcb13wnsb">实战使用GPT辅助开发一款自动化程序经验分享 - 飞书云文档</a><br><a href="https://jngw0yct19.feishu.cn/docx/GUHld91qQobms8x35tbcOUlSnZb">打造“不出镜”个人IP，10个月变现7位数的方法论！ - 飞书云文档</a><br><a href="https://i0i7zmraov0.feishu.cn/docx/AUFtddQyKozkegxnCmhcLbh2nqn">通过“做废8个账号”找到“正确道路”的故事 - 飞书云文档</a><br><a href="https://docs.qq.com/doc/DSnByc2J5a01NYkpn">生财人必备的法律常识442问 20211015</a><br><a href="https://rxc7lnelf7.feishu.cn/docx/CXdxdRBwQo0UXvxQLDschE2pndd">顺势而为：视频号口播实拍带货，单条视频变现14w+，像素级拆解！ - 飞书云文档</a><br><a href="https://rxc7lnelf7.feishu.cn/docx/CXdxdRBwQo0UXvxQLDschE2pndd">顺势而为：视频号口播实拍带货，单条视频变现14w+，像素级拆解！ - 飞书云文档</a><br><a href="https://qv4zhbe2wa.feishu.cn/docx/U2lPdc1ayoNSPUxgsNfcEXrXn1d">选品神器，任意下载爆款视频素材[C级] - 飞书云文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【胡思01】Ctrl+F的最大搜索范围是多少</title>
    <link href="/2022/03/26/%E3%80%90%E8%83%A1%E6%80%9D01%E3%80%91Ctrl+F%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91/"/>
    <url>/2022/03/26/%E3%80%90%E8%83%A1%E6%80%9D01%E3%80%91Ctrl+F%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91/</url>
    
    <content type="html"><![CDATA[<p>今天在一个有上百万字符的txt文件中使用<code>Ctrl+F</code>可以正常搜索出需要的内容，不禁就想<code>Ctrl+F</code>的最大搜索范围是多大，难道是无穷大吗？</p><p>Ctrl+F（以及其他文本搜索功能）常用的字符串匹配算法有多种，不同的应用程序会选择不同的算法来平衡性能和准确性。以下是几种常见的字符串匹配算法，它们被用于类似 Ctrl+F 这样的搜索功能中。</p><h3 id="1-朴素字符串匹配算法（Naive-String-Matching-Algorithm）"><a href="#1-朴素字符串匹配算法（Naive-String-Matching-Algorithm）" class="headerlink" title="1. 朴素字符串匹配算法（Naive String Matching Algorithm）"></a>1. <strong>朴素字符串匹配算法（Naive String Matching Algorithm）</strong></h3><p>这是最简单的字符串匹配算法，其工作原理非常直观：从目标文本的每个字符开始，逐一对比目标子串，直到找到完全匹配的子串位置。具体流程如下：</p><ul><li>将搜索词（模式串）与文本中的子串进行逐字符比较。</li><li>若不匹配，移动一个字符，继续下一次比较。<br><strong>优点</strong>：实现简单，易于理解。<br><strong>缺点</strong>：对于长文本和大规模匹配，效率较低，时间复杂度为 (O(n \times m))，其中 (n) 是文本长度，(m) 是模式串长度。</li></ul><h3 id="2-KMP-算法（Knuth-Morris-Pratt-Algorithm）"><a href="#2-KMP-算法（Knuth-Morris-Pratt-Algorithm）" class="headerlink" title="2. KMP 算法（Knuth-Morris-Pratt Algorithm）"></a>2. <strong>KMP 算法（Knuth-Morris-Pratt Algorithm）</strong></h3><p>KMP 算法通过预处理模式串，创建一个“部分匹配表”（Partial Match Table），以避免不必要的字符比较。在匹配过程中，当遇到不匹配时，KMP 算法不必回溯到原先的文本位置，而是利用部分匹配表，跳过一些字符。<br><strong>流程</strong>：</p><ul><li>预处理模式串，创建部分匹配表，记录每个位置之前的前缀与后缀的匹配情况。</li><li>在实际搜索时，遇到不匹配字符时，跳过不可能匹配的位置，避免重复比较。<br><strong>优点</strong>：大大减少了重复的字符比较，时间复杂度为 (O(n + m))。<br><strong>缺点</strong>：实现相对复杂，尤其是部分匹配表的构建。</li></ul><h3 id="3-Boyer-Moore-算法（Boyer-Moore-Algorithm）"><a href="#3-Boyer-Moore-算法（Boyer-Moore-Algorithm）" class="headerlink" title="3. Boyer-Moore 算法（Boyer-Moore Algorithm）"></a>3. <strong>Boyer-Moore 算法（Boyer-Moore Algorithm）</strong></h3><p>Boyer-Moore 是另一个高效的字符串匹配算法，它从模式串的最后一个字符开始比较，如果不匹配，则利用两种规则来跳过尽可能多的字符：</p><ul><li><strong>坏字符规则（Bad Character Rule）</strong>：在发生不匹配时，模式串直接跳过不匹配的字符，移动到与文本匹配的字符位置。</li><li><strong>好后缀规则（Good Suffix Rule）</strong>：如果匹配到一部分模式串，且接下来发生不匹配，则根据已匹配的部分向前移动模式串。<br><strong>优点</strong>：在实际操作中非常高效，尤其在模式串较长时，能够跳过大量字符，时间复杂度在最优情况下接近 (O(n&#x2F;m))。<br><strong>缺点</strong>：最坏情况下复杂度为 (O(n \times m))，且实现复杂。</li></ul><h3 id="4-Rabin-Karp-算法"><a href="#4-Rabin-Karp-算法" class="headerlink" title="4. Rabin-Karp 算法"></a>4. <strong>Rabin-Karp 算法</strong></h3><p>Rabin-Karp 算法利用哈希函数进行字符串匹配。它首先计算模式串的哈希值，然后在文本的每个子串上滑动，计算当前子串的哈希值。如果两个哈希值相同，再逐字符比较确认。<br><strong>流程</strong>：</p><ul><li>计算模式串的哈希值。</li><li>从文本中逐个提取长度等于模式串的子串，并计算其哈希值。</li><li>如果哈希值相等，再进行逐字符比较。<br><strong>优点</strong>：当需要搜索多个模式串时效率较高，哈希计算的时间复杂度为 (O(n))。<br><strong>缺点</strong>：哈希冲突可能导致需要进行更多比较，最坏情况时间复杂度为 (O(n \times m))。</li></ul><h3 id="5-Aho-Corasick-算法"><a href="#5-Aho-Corasick-算法" class="headerlink" title="5. Aho-Corasick 算法"></a>5. <strong>Aho-Corasick 算法</strong></h3><p>Aho-Corasick 是一种基于有限自动机的字符串匹配算法，特别适用于多模式匹配。该算法首先通过构建一个状态机，将多个模式串组织在一起，然后一次性在文本中匹配所有模式。<br><strong>优点</strong>：非常适合在文本中同时搜索多个模式串，时间复杂度为 (O(n + m + z))，其中 (z) 是找到的匹配数量。<br><strong>缺点</strong>：构建状态机需要额外的空间和时间。</p><h3 id="底层实现的选择"><a href="#底层实现的选择" class="headerlink" title="底层实现的选择"></a>底层实现的选择</h3><p>Ctrl+F 这样的功能，常根据具体情况选择不同的算法。比如，浏览器中 Ctrl+F 的实现可能选择简单的朴素算法，因为网页通常不长，算法的简易性可以满足需求。而在大型文档处理工具中，如 PDF 阅读器、IDE 等，则更可能使用 KMP 或 Boyer-Moore 这样的高效算法，以提高搜索性能。<br>总的来说，Ctrl+F 的底层实现通常会根据具体应用的需求选择合适的字符串匹配算法，既能满足高效搜索，又能适应不同的文件规模和环境。</p><p>Ctrl+F 搜索的范围并不是完全“无限大”的。它的实际搜索范围取决于搜索所在的文本大小和应用的技术限制。具体底层实现方式可以从以下几个方面理解：</p><h3 id="1-搜索范围与数据读取"><a href="#1-搜索范围与数据读取" class="headerlink" title="1. 搜索范围与数据读取"></a>1. <strong>搜索范围与数据读取</strong></h3><p>Ctrl+F 在执行时，首先会加载当前显示的页面或文档内容。如果文档很大，程序会分段加载这些内容，逐步进行搜索。浏览器或文本编辑器通常会在后台动态加载剩余内容，从而允许搜索在未完全显示的文本中继续进行，但这种操作受限于计算机内存和性能。对于在线文档或网页，搜索范围通常是整个已经加载的页面【7†source】【9†source】。</p><h3 id="2-全文索引和搜索算法"><a href="#2-全文索引和搜索算法" class="headerlink" title="2. 全文索引和搜索算法"></a>2. <strong>全文索引和搜索算法</strong></h3><p>在底层，Ctrl+F 通过匹配算法（如简单的字符串匹配算法）进行工作。它会通过遍历整个文档的字符，查找用户输入的关键词。对于大文件或数据库系统，通常会先建立“全文索引”，这是一种优化手段，使得搜索效率更高。在这种情况下，程序可以直接通过索引找到匹配的词，而不是逐字符搜索【9†source】。</p><h3 id="3-软件的限制与优化"><a href="#3-软件的限制与优化" class="headerlink" title="3. 软件的限制与优化"></a>3. <strong>软件的限制与优化</strong></h3><p>不同软件对 Ctrl+F 功能的限制不同。例如，像 IntelliJ IDEA 等开发工具默认会显示最多 100 个搜索结果，但可以通过设置增加上限【8†source】。此外，一些文本编辑器可能会限制每次搜索的文本块大小，以减少系统资源消耗。浏览器中，如果一个网页的文本量非常大，Ctrl+F 的搜索效率可能会降低，甚至导致浏览器崩溃。这是因为浏览器需要将整个文档加载到内存中进行匹配。</p><h3 id="4-内存和性能的影响"><a href="#4-内存和性能的影响" class="headerlink" title="4. 内存和性能的影响"></a>4. <strong>内存和性能的影响</strong></h3><p>搜索范围的大小受到设备的内存和性能影响。如果内存较小或文档非常大（如几十万行的代码文件或几百页的PDF），搜索的响应速度会变慢，甚至可能因为内存不足导致搜索失败。因此，虽然理论上搜索的范围可以非常大，但实际操作中，受硬件条件的限制。</p><p>总结来说，Ctrl+F 的底层实现依赖于字符串匹配算法，搜索范围依赖于所搜索文本的加载方式、应用的优化手段以及设备的硬件条件。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
